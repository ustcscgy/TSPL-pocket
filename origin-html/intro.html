<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Introduction</title>
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g0"></a>
<a name="./intro:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch1.png"><img src="canned/jph.png">
</div>
<h1>Chapter 1. Introduction<a name="CHPTINTRO"></a></h1>





<p>
Scheme is a general-purpose computer programming language.
It is a high-level language, supporting operations on structured
data such as strings, lists, and vectors, as well as operations on
more traditional data such as numbers and characters.
While Scheme is often identified with symbolic
applications, its rich set of data types and flexible
control structures make it a truly versatile language.
Scheme has been employed to write text editors, optimizing
compilers, operating systems, graphics packages, expert systems,
numerical applications, financial analysis packages,
virtual reality systems,
and practically every other type of application imaginable.
Scheme is a fairly simple language to learn, since it is based
on a handful of syntactic forms and semantic concepts and
since the interactive nature of most implementations encourages
experimentation.
Scheme is a challenging language to understand fully, however;
developing the ability to use its full potential requires careful study
and practice.

<p>
Scheme programs are highly portable across versions of
the same Scheme implementation on different machines, because machine
dependencies are almost completely hidden from the programmer.
They are also portable across different implementations because of the
efforts of a group of Scheme language designers who have published
a series of reports,
the "<a name="./intro:s0"></a>Revised Reports" on Scheme.
The most recent, the 
"Revised<sup>6</sup> Report"&nbsp;[<a class=citation href="bibliography.html#g242">24</a>], emphasizes portability
through a set of standard libraries and a standard mechanism for
defining new portable libraries and top-level programs.

<p>
Although some early Scheme systems were inefficient and slow,
many newer compiler-based implementations are fast, with programs
running on par with equivalent programs written in
lower-level languages.
The relative inefficiency that sometimes remains results from run-time
checks that support generic arithmetic and help programmers
detect and correct various common
programming errors.
These checks may be disabled in many implementations.

<p>
<p>Scheme supports many types of data values, or
<a name="./intro:s1"></a><i>objects</i>, including characters, strings, symbols,
lists or vectors of objects, and a full set of numeric data types,
including complex, real, and arbitrary-precision rational numbers.

<p>
The storage required to hold the contents of an object is
<a name="./intro:s2"></a>dynamically allocated as
necessary and retained until no longer needed, then automatically
deallocated, typically by a
<a name="./intro:s3"></a><i>garbage collector</i> that
periodically recovers the storage used by inaccessible objects.
Simple atomic values, such as small integers, characters, booleans,
and the empty list, are typically represented as immediate values and
thus incur no allocation or deallocation overhead.

<p>
Regardless of representation,
all objects are <a name="./intro:s4"></a><i>first-class</i> data values;
because they are retained indefinitely, they may be passed freely
as arguments to procedures, returned as values from procedures, and
combined to form new objects.
This is in contrast with many other languages where composite data
values such as arrays are either statically allocated and never
deallocated, allocated on entry to a block of code and unconditionally
deallocated on exit from the block, or explicitly allocated <i>and</i>
deallocated by the programmer.

<p>
Scheme is a call-by-value language, but for at least mutable objects (objects
that can be modified), the values are <a name="./intro:s5"></a>pointers
to the actual storage.
These pointers remain behind the scenes, however, and programmers need
not be conscious of them except to understand that the storage for an
object is not copied when an object is passed to or returned from
a procedure.

<p>
<a name="./intro:s6"></a>At the heart of the Scheme language is a
small core of syntactic forms from which all other forms are built.
These core forms, a set of extended syntactic forms derived from
them, and a set of <a name="./intro:s7"></a>primitive procedures
make up the full Scheme language.
An <a name="./intro:s8"></a>interpreter or <a name="./intro:s9"></a>compiler for Scheme
can be quite small and potentially fast and highly reliable.
The extended syntactic forms and many primitive procedures can be
defined in Scheme itself, simplifying the implementation and
increasing reliability.

<p>
Scheme programs share a common printed representation with Scheme
data structures.
As a result, any Scheme program has a natural and obvious internal
representation as a Scheme object.
For example, <a name="./intro:s10"></a>variables and syntactic <a name="./intro:s11"></a>keywords correspond to
symbols, while structured syntactic forms correspond to lists.
This representation is the basis for the syntactic extension
facilities
provided by Scheme for the definition of new syntactic
forms in terms of existing syntactic forms and procedures.
It also facilitates the implementation of interpreters, compilers, and
other program transformation tools for Scheme directly in Scheme, as
well as program transformation tools for other languages in Scheme.

<p>
<p>Scheme variables and keywords are
<a name="./intro:s12"></a><i>lexically scoped</i>, and
Scheme programs are
<a name="./intro:s13"></a><i>block-structured</i>.
Identifiers may be imported into a program or library or bound locally
within a given block of code such as a library, program, or procedure
body.
A local <a name="./intro:s14"></a>binding is visible only lexically, i.e., within the program text
that makes up the particular block of code.
An occurrence of an identifier of the same name outside this block
refers to a different binding; if no binding for the identifier
exists outside
the block, then the reference is invalid.
Blocks may be nested, and a binding in
one block may <a name="./intro:s15"></a><i>shadow</i> a binding for an identifier
of the same name in a surrounding block.
The <i>scope</i> of a binding is the block in which the bound identifier
is visible
minus any portions of the block in which the identifier is
shadowed.
Block structure and lexical scoping help create
programs that are
modular, easy to read, easy to maintain, and reliable.
Efficient code for lexical scoping is possible because a compiler
can determine before program evaluation the scope of all bindings
and the binding to which each identifier reference resolves.
This does not mean, of course, that a compiler can determine the
values of all variables, since the actual values are not computed
in most cases until the program executes.

<p>
<p>In most languages, a <a name="./intro:s16"></a>procedure definition is simply the association
of a name with a block of code.
Certain variables local to the block are the parameters of the
procedure.
In some languages, a procedure definition may appear within another
block or procedure so long as the procedure is invoked only during
execution of the enclosing block.
In others, procedures can be defined only at top level.
In Scheme, a procedure definition may appear within another block or
procedure, and the procedure may be invoked at any time thereafter,
even if the enclosing block has completed its execution.
To support <a name="./intro:s17"></a>lexical scoping, a procedure carries the lexical context
(environment) along with its code.

<p>
Furthermore, Scheme procedures are not always named.
Instead, procedures are <a name="./intro:s18"></a>first-class data
objects like strings
or numbers, and variables are bound to procedures in the same way they
are bound to other objects.

<p>
As with procedures in most other languages, Scheme procedures may
be recursive.
That is, any procedure may invoke itself directly or indirectly.
Many algorithms are most elegantly or efficiently specified recursively.
A special case of <a name="./intro:s19"></a>recursion, called <a name="./intro:s20"></a>tail recursion, is used to
express <a name="./intro:s21"></a>iteration, or <a name="./intro:s22"></a>looping.
A <a name="./intro:s23"></a><i>tail call</i> occurs when one procedure directly returns the result of
invoking another procedure; <i>tail recursion</i> occurs when
a procedure recursively tail-calls itself, directly or indirectly.
Scheme implementations are required to implement tail calls as
jumps (gotos), so the storage overhead normally associated with recursion
is avoided.
As a result, Scheme programmers need master only simple procedure calls
and recursion and need not be burdened with the usual assortment
of looping constructs.

<p>
<p>Scheme supports the definition of arbitrary control structures with
<a name="./intro:s24"></a><i>continuations</i>.
A continuation is a procedure that embodies the remainder of a program
at a given point in the program.
A continuation may be obtained at any time during the execution of a
program.
As with other procedures, a continuation is a first-class object and
may be invoked at any time after its creation.
Whenever it is invoked, the program immediately continues from the
point where the continuation was obtained.
Continuations allow the implementation of complex control mechanisms
including explicit backtracking, multithreading, and coroutines.

<p>
<a name="./intro:s25"></a>Scheme also allows programmers to define new syntactic forms, or
<i>syntactic extensions</i>, by writing transformation procedures that
determine how each new syntactic form maps to existing syntactic forms.
These transformation procedures are themselves expressed in Scheme
with the help of a convenient high-level pattern language that automates
syntax checking, input deconstruction, and output reconstruction.
By default, lexical scoping is maintained through the transformation
process, but the programmer can exercise control over the scope of all
identifiers appearing in the output of a transformer.
Syntactic extensions are useful for defining new language constructs,
for emulating language constructs found in other languages, for
achieving the effects of in-line code expansion, and even for
emulating entire languages in Scheme.
Most large Scheme programs are built from a mix of
syntactic extensions and procedure definitions.

<p>
<p>Scheme evolved from the <a name="./intro:s26"></a>Lisp language and is considered to be a
dialect of Lisp.
Scheme inherited from Lisp the treatment of values as first-class
objects, several important data types, including symbols and lists,
and the representation of programs as objects, among other things.
Lexical scoping and block structure are features taken from
<a name="./intro:s27"></a>Algol 60&nbsp;[<a class=citation href="bibliography.html#g239">21</a>].
Scheme was the first Lisp dialect to adopt lexical scoping and block
structure, first-class procedures, the treatment of tail
calls as jumps, continuations, and lexically scoped syntactic
extensions.

<p>
<a name="./intro:s28"></a>Common Lisp&nbsp;[<a class=citation href="bibliography.html#g245">27</a>] and Scheme are both contemporary Lisp
languages, and the development of each has been influenced by the other.
Like Scheme but unlike earlier Lisp languages, Common Lisp
adopted lexical scoping and first-class procedures, although
Common Lisp's syntactic extension facility does not
respect lexical scoping.
Common Lisp's evaluation rules for procedures are different
from the evaluation rules for other objects, however, and it maintains a
separate namespace for procedure variables, thereby inhibiting
the use of procedures as first-class objects.
Also, Common Lisp does not support continuations or require proper
treatment of tail calls,
but it does support several less general control structures not found
in Scheme.
While the two languages are similar, Common
Lisp includes more specialized constructs, while Scheme includes
more general-purpose building blocks out of which such constructs (and
others) may be built.

<p>
<p>The remainder of this chapter describes Scheme's syntax and naming
conventions and the typographical conventions used throughout this
book.

<p>

<h3><a name="g1"></a><a name="./intro:h1"></a>Section 1.1. Scheme Syntax<a name="SECTINTROSYNTAX"></a></h3>



<p>
Scheme programs are made up of keywords, variables, <a name="./intro:s29"></a>structured forms,
constant data (numbers, characters, strings, quoted vectors, quoted
lists, quoted symbols, etc.), whitespace, and comments.

<p>
Keywords, variables, and symbols are collectively called
<a name="./intro:s30"></a>identifiers.
Identifiers may be formed from letters, digits, and certain special
characters, including <tt>?</tt>, <tt>!</tt>, <tt>.</tt>, <tt>+</tt>,
<tt>-</tt>, <tt>*</tt>, <tt>/</tt>, <tt>&lt;</tt>, <tt>=</tt>, <tt>&gt;</tt>,
<tt>:</tt>, <tt>$</tt>, <tt>%</tt>, <tt>^</tt>, <tt>&amp;</tt>, <tt>_</tt>,
<tt>~</tt>, and <tt>@</tt>, as well as a set of additional Unicode
characters.
Identifiers cannot start with an at sign&nbsp;(&nbsp;<tt>@</tt>&nbsp;) and
normally cannot start with any character that can start
a number, i.e., a digit, plus sign&nbsp;(&nbsp;<tt>+</tt>&nbsp;), minus sign&nbsp;(&nbsp;<tt>-</tt>&nbsp;), or
decimal point&nbsp;(&nbsp;<tt>.</tt>&nbsp;).
Exceptions are&nbsp;<tt>+</tt>,&nbsp;<tt>-</tt>, and&nbsp;<tt>...</tt>, which are valid identifiers,
and any identifier starting with <tt>-&gt;</tt>.
For example, <tt>hi</tt>, <tt>Hello</tt>, <tt>n</tt>, <tt>x</tt>, <tt>x3</tt>, <tt>x+2</tt>, and <tt>?$&amp;*!!!</tt> are all
identifiers.
Identifiers are delimited by whitespace, comments, parentheses, brackets, string
(double) quotes&nbsp;(&nbsp;<tt>"</tt>&nbsp;), and hash marks(&nbsp;<tt>#</tt>&nbsp;).
A delimiter or any other Unicode character may be included anywhere within the
name of an identifier as an escape of the form <tt>\x<i>sv</i>;</tt>,
where <tt><i>sv</i></tt> is the scalar value of the character in hexadecimal
notation.

<p>
There is no inherent limit on the length of a Scheme identifier;
programmers may use as many characters as necessary.
Long identifiers are no substitute for comments, however, and
frequent use of long identifiers can make a program difficult to
format and consequently difficult to read.  
A good rule is to use short identifiers when the scope of the identifier
is small and longer identifiers when the scope is larger.

<p>
Identifiers may be written in any mix of upper- and lower-case letters,
and case is significant, i.e., two identifiers are different even if
they differ only in case.
For example, <tt>abcde</tt>, <tt>Abcde</tt>, <tt>AbCdE</tt>, and <tt>ABCDE</tt>
all refer to different identifiers.
This is a change from previous versions of the Revised Report.

<p>
Structured forms and <a name="./intro:s31"></a>list constants are enclosed
within parentheses, e.g., <tt>(a&nbsp;b&nbsp;c)</tt> or <tt>(*&nbsp;(-&nbsp;x&nbsp;2)&nbsp;y)</tt>.
The <a name="./intro:s32"></a>empty list is written <a name="./intro:s33"></a><tt>()</tt>.
<a name="./intro:s34"></a>Matched sets of brackets
(&nbsp;<tt>[</tt>&nbsp;<tt>]</tt>&nbsp;) may be used in place of parentheses and are
often used to set off the subexpressions of certain standard
syntactic forms for readability, as shown in examples throughout this book.
Vectors are written similarly to lists, except that they are
preceded by <tt>#(</tt> and terminated by <tt>)</tt>, e.g.,
<tt>#(this&nbsp;is&nbsp;a&nbsp;vector&nbsp;of&nbsp;symbols)</tt>.
Bytevectors are written as sequences of unsigned byte values (exact
integers in the range 0 through 255) bracketed by <tt>#vu8(</tt> and
<tt>)</tt>, e.g., <tt>#vu8(3&nbsp;250&nbsp;45&nbsp;73)</tt>.

<p>
Strings are enclosed in double quotation marks, e.g.,
<tt>"I&nbsp;am&nbsp;a&nbsp;string"</tt>.
Characters are preceded by <tt>#\</tt>, e.g., <tt>#\a</tt>.
Case is important within character and string constants, as within
identifiers.
Numbers may be written as integers, e.g., -123, as ratios, e.g., 1/2,
in floating-point or scientific notation,
e.g., 1.3 or 1e23, or as complex numbers in rectangular or polar
notation, e.g., 1.3-2.7i or -1.2@73.
Case is not important in the syntax of a number.
The <a name="./intro:s35"></a>boolean values representing <a name="./intro:s36"></a><i>true</i> and <a name="./intro:s37"></a><i>false</i>
are written <a name="./intro:s38"></a><tt>#t</tt> and <a name="./intro:s39"></a><tt>#f</tt>.
Scheme conditional expressions actually treat <tt>#f</tt> as false and all
other objects as true, so
<tt>3</tt>, <tt>0</tt>, <tt>()</tt>, <tt>"false"</tt>, and <tt>nil</tt> all count as true.

<p>
Details of the syntax for each type 
of constant data are given in the individual
sections of Chapter&nbsp;<a href="objects.html#g106">6</a> and in the formal syntax of
Scheme starting on page&nbsp;<a href="grammar.html#APPENDIXFORMALSYNTAX">455</a>.

<p>
Scheme <a name="./intro:s40"></a>expressions may span several lines, and no explicit
terminator is required.
Since the number of <a name="./intro:s41"></a>whitespace characters (spaces and newlines)
between expressions is not
significant, Scheme programs should be indented to show the structure
of the code in a way that makes the code as readable as possible.
<a name="./intro:s42"></a>Comments may appear on any line of a Scheme program, between
a <a name="./intro:s43"></a><a name="./intro:s44"></a>semicolon (&nbsp;<tt>;</tt>&nbsp;) and the end of the line.
Comments explaining a particular Scheme expression are normally placed
at the same indentation level as the expression, on the line before
the expression.
Comments explaining a procedure or group of procedures are normally
placed before the procedures, without indentation.
Multiple comment characters are often used to set off the latter kind of
comment, e.g., <tt>;;;&nbsp;The&nbsp;following&nbsp;procedures&nbsp;...</tt>.

<p>
Two other forms of comments are supported: block comments and datum comments.
Block comments are delimited by <tt>#|</tt> and <tt>|#</tt> pairs, and may be
nested.
A datum comment consists of a <tt>#;</tt> prefix and the datum (printed data value)
that follows it.
Datum comments are typically used to comment out individual definitions
or expressions.
For example, <tt>(three&nbsp;#;(not&nbsp;four)&nbsp;element&nbsp;list)</tt> is just what it says.
Datum comments may also be nested, though <tt>#;#;(a)(b)</tt> has the
somewhat nonobvious effect of commenting out both <tt>(a)</tt> and
<tt>(b)</tt>.

<p>
Some Scheme values, such as procedures and ports, do not have standard
printed representations and can thus never appear as a constant in the
printed syntax of a program.
This book uses the notation <tt>#&lt;<i>description</i>&gt;</tt> when showing the
output of an operation that returns such a value, e.g.,
<tt>#&lt;procedure&gt;</tt> or <tt>#&lt;port&gt;</tt>.

<p>

<h3><a name="g2"></a><a name="./intro:h2"></a>Section 1.2. Scheme Naming Conventions<a name="SECTINTRONAMING"></a></h3>



<p>
Scheme's <a name="./intro:s45"></a>naming conventions are designed to provide a high degree
of regularity.
The following is a list of these naming conventions:

<p>
<ul>
<li>Predicate names end in a
<a name="./intro:s46"></a><a name="./intro:s47"></a>question mark (&nbsp;<tt>?</tt>&nbsp;).
Predicates are procedures that return a true or false
answer, such as <tt>eq?</tt>, <tt>zero?</tt>, and <tt>string=?</tt>.
The common numeric comparators <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>,
and <tt>&gt;=</tt> are exceptions to this naming convention.

<p>
<li>Type <a name="./intro:s48"></a>predicates, such as <tt>pair?</tt>, are created from
the name of the type, in this case <tt>pair</tt>, and the question mark.

<p>
<li>The names of most character, string, and vector
procedures start with the prefix <tt>char-</tt>, <tt>string-</tt>, and
<tt>vector-</tt>, e.g., <tt>string-append</tt>.
(The names of some list procedures start with <tt>list-</tt>, but most
do not.)

<p>
<li>The names of procedures that convert an object of
one type into an object of another type are written as
<a name="./intro:s49"></a><tt><i>type<sub>1</sub></i>-&gt;<i>type<sub>2</sub></i></tt>,
e.g., <tt>vector-&gt;list</tt>.

<p>
<li>The names of procedures and syntactic forms
that cause side effects end with an
<a name="./intro:s50"></a><a name="./intro:s51"></a>exclamation point (&nbsp;<tt>!</tt>&nbsp;).
These include <tt>set!</tt> and <tt>vector-set!</tt>.
Procedures that perform input or output technically cause <a name="./intro:s52"></a>side effects,
but their names are exceptions to this rule.
</ul>
<p>

<p>
Programmers should employ these same conventions in their own code whenever
possible.


<p>

<h3><a name="g3"></a><a name="./intro:h3"></a>Section 1.3. Typographical and Notational Conventions<a name="SECTINTRONOTATION"></a></h3>



<p>
A standard procedure or syntactic form whose sole purpose is to perform
some side effect is said to return <a name="./intro:s53"></a><i>unspecified</i>.
This means that an implementation is free to return any number of
values, each of which can be any Scheme object,
as the value of the procedure or syntactic form.
Do not count on these values being the same across implementations, the
same across versions of the same implementation, or even the same across
two uses of the procedure or syntactic form.
Some Scheme systems routinely use a special object to represent
unspecified values.
Printing of this object is often suppressed by interactive Scheme
systems, so that the values of expressions returning unspecified values 
are not printed.

<p>
<a name="./intro:s54"></a>While most standard procedures return a single value, the language
supports procedures that return zero, one, more than one, or even a
variable number of values via the mechanisms described in
Section&nbsp;<a href="control.html#g104">5.8</a>.
Some standard expressions can evaluate to multiple values if one of their
subexpressions evaluates to multiple values, e.g., by calling a procedure
that returns multiple values.
When this situation can occur, an expression is said to return "the
values" rather than simply "the value" of its subexpression.
Similarly, a standard procedure that returns the values resulting from a
call to a procedure argument is said to return the values returned by the
procedure argument.

<p>
<a name="./intro:s55"></a>This book uses the words "must" and "should" to
describe program requirements, such as the requirement to provide an index
that is less than the length of the vector in a call to
<tt>vector-ref</tt>.
If the word "must" is used, it means that the requirement is enforced
by the implementation, i.e., an exception is raised, usually with
condition type <tt>&amp;assertion</tt>.
If the word "should" is used, an exception may or may not be raised,
and if not, the behavior of the program is undefined.

<p>
<a name="./intro:s56"></a>The phrase "syntax violation" is used to
describe a situation in which a program is malformed.
Syntax violations are detected prior to program execution.
When a syntax violation is detected, an exception of type <tt>&amp;syntax</tt>
is raised and the program is not executed.

<p>
The typographical conventions used in this book are straightforward.
All Scheme objects are printed in a <tt>typewriter</tt> typeface, just as they
are to be typed at the keyboard.
This includes syntactic keywords, variables, constant
objects, Scheme expressions, and example programs.
An <i>italic</i> typeface is used to set off syntax variables in
the descriptions of syntactic forms and arguments in the descriptions of
procedures.
Italics are also used to set off technical terms the first time they
appear.
In general, names of syntactic forms and procedures are never
capitalized, even at the beginning of a sentence.
The same is true for syntax variables written in italics.

<p>
In the description of a syntactic form or procedure, one or more prototype
patterns show the syntactic form or forms or the correct number or numbers
of arguments for an application of the procedure.
The keyword or procedure name is given in typewriter font,
as are parentheses.
The remaining pieces of the syntax or arguments are shown in italics,
using a name that implies the type of expression or argument expected
by the syntactic form or procedure.
Ellipses are used to specify
zero or more occurrences of a subexpression or argument.
For example, <tt>(or&nbsp;<i>expr</i>&nbsp;...)</tt> describes the <tt>or</tt>
syntactic form, which has zero or more subexpressions, and
<tt>(member&nbsp;<i>obj</i>&nbsp;<i>list</i>)</tt> describes the <tt>member</tt>
procedure, which expects two arguments, an object and a list.

<p>
A syntax violation occurs if the structure of a syntactic form does
not match its prototype.
Similarly, an exception with condition type <tt>&amp;assertion</tt> is raised
if the number of arguments passed to a standard procedure does not match
what it is specified to receive.
An exception with condition type <tt>&amp;assertion</tt> is also raised if a
standard procedure receives an argument whose type is not the
type implied by its name or does not meet other criteria given in
the description of the procedure.
For example, the prototype for <tt>vector-set!</tt> is

<p>

<p><tt>(vector-set!&nbsp;<i>vector</i>&nbsp;<i>n</i>&nbsp;<i>obj</i>)</tt>
<p>and the description says that
<tt><i>n</i></tt> must be an exact nonnegative integer strictly less than
the length of <tt><i>vector</i></tt>.
Thus, <tt>vector-set!</tt> must receive three arguments, the first
of which must be a vector, the second of which must be an exact nonnegative
integer less than the length of the vector, and the third of which may
be any Scheme value.
Otherwise, an exception with condition type <tt>&amp;assertion</tt> is
raised.

<p>
In most cases, the type of argument required is obvious, as with
<tt><i>vector</i></tt>, <tt><i>obj</i></tt>, or <tt><i>binary-input-port</i></tt>.
In others, primarily within the descriptions of numeric routines,
abbreviations are used, such as <tt><i>int</i></tt> for integer, <tt><i>exint</i></tt>
for exact integer, and <tt><i>fx</i></tt> for fixnum.
These abbreviations are explained at the start of the sections
containing the affected entries.




<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
