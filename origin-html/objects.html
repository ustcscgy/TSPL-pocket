<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Operations on Objects</title>
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g106"></a>
<a name="./objects:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch6.png"><img src="canned/jph.png">
</div>
<h1>Chapter 6. Operations on Objects<a name="CHPTOBJECTS"></a></h1>





<p>
This chapter describes the <a name="./objects:s0"></a>operations on objects, including lists,
numbers, characters, strings, vectors, bytevectors, symbols, booleans, hashtables, and enumerations.
The first section covers constant objects and quotation.
The second section describes generic equivalence predicates for
comparing two objects and predicates for determining the type
of an object.
Later sections describe procedures that deal primarily with one of
the object types mentioned above.
There is no section treating operations on procedures, since the only
operation defined specifically for procedures is application, and this
is described in Chapter&nbsp;<a href="control.html#g96">5</a>.
Operations on ports are covered in the more general discussion of
input and output in Chapter&nbsp;<a href="io.html#g121">7</a>.
A mechanism for defining new data types is described in
Chapter&nbsp;<a href="records.html#g138">9</a>.

<p>

<h3><a name="g107"></a><a name="./objects:h1"></a>Section 6.1. Constants and Quotation<a name="SECTQUOTING"></a></h3>



<p>
<a name="./objects:s1"></a><span class=formdef><b>syntax</b>: <tt><i>constant</i></tt></span>
<br>
<b>returns: </b><tt><i>constant</i></tt>

<p><tt><i>constant</i></tt> is any self-evaluating constant, i.e., a number,
boolean, character, string, or bytevector.
Constants are immutable; see the note in the description of
<tt>quote</tt> below.

<p>

<p><tt>3.2&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.2<br>

#f&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

#\c&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\c<br>

"hi"&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"hi"<br>

#vu8(3&nbsp;4&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(3&nbsp;4&nbsp;5)</tt>
<p><a name="./objects:s2"></a><span class=formdef><b>syntax</b>: <tt>(quote&nbsp;<i>obj</i>)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>'<i>obj</i></tt></span>
<br>
<b>returns: </b><tt><i>obj</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>'<i>obj</i></tt> is equivalent to <tt>(quote&nbsp;<i>obj</i>)</tt>.
The abbreviated form is converted into the longer form by the Scheme
reader (see <tt>read</tt>).

<p>
<tt>quote</tt> inhibits the normal evaluation rule for
<tt><i>obj</i></tt>, allowing <tt><i>obj</i></tt> to be employed as <a name="./objects:s3"></a>data.
Although any Scheme object may be quoted, quotation is not necessary
for self-evaluating <a name="./objects:s4"></a>constants, i.e., numbers, booleans,
characters, strings, and bytevectors.

<p>
Quoted and self-evaluating constants are immutable.
That is, programs should not alter a constant via <tt>set-car!</tt>,
<tt>string-set!</tt>, etc., and implementations are permitted to raise
an exception with condition type <tt>&amp;assertion</tt> if such an
alteration is attempted.
If an attempt to alter an immutable object is undetected, the behavior of
the program is unspecified.
An implementation may choose to share storage among different
constants to save space.

<p>

<p><tt>(+&nbsp;2&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5<br>

'(+&nbsp;2&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(+&nbsp;2&nbsp;3)<br>

(quote&nbsp;(+&nbsp;2&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(+&nbsp;2&nbsp;3)<br>

'a&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

'cons&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;cons<br>

'()&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

'7&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;7</tt>
<p><a name="./objects:s5"></a><span class=formdef><b>syntax</b>: <tt>(quasiquote&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>`<i>obj</i></tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(unquote&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>,<i>obj</i></tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(unquote-splicing&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>,@<i>obj</i></tt></span>
<br>
<b>returns: </b>see below
 <br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>`<i>obj</i></tt> is equivalent to <tt>(quasiquote&nbsp;<i>obj</i>)</tt>,
<tt>,<i>obj</i></tt> is equivalent to <tt>(unquote&nbsp;<i>obj</i>)</tt>, and
<tt>,@<i>obj</i></tt> is equivalent to <tt>(unquote-splicing&nbsp;<i>obj</i>)</tt>.
The abbreviated forms are converted into the longer forms by the
Scheme reader (see <tt>read</tt>).

<p>
<tt>quasiquote</tt> is similar to <tt>quote</tt>, but it allows parts
of the quoted text to be "unquoted."
Within a <tt>quasiquote</tt> expression,
<tt>unquote</tt> and <tt>unquote-splicing</tt> subforms are evaluated,
and everything else is quoted, i.e., left unevaluated.
The value of each <tt>unquote</tt> subform is inserted into the output
in place of the <tt>unquote</tt> form, while the value of each
<tt>unquote-splicing</tt> subform is spliced into the surrounding list
or vector structure.
<tt>unquote</tt> and <tt>unquote-splicing</tt> are valid only within
<tt>quasiquote</tt> expressions.

<p>
<tt>quasiquote</tt> expressions may be nested, with each <tt>quasiquote</tt>
introducing a new level of quotation and each <tt>unquote</tt> or
<tt>unquote-splicing</tt> taking away a level of quotation.
An expression nested within <i>n</i> <tt>quasiquote</tt> expressions must
be within <i>n</i> <tt>unquote</tt> or <tt>unquote-splicing</tt> expressions to
be evaluated.

<p>

<p><tt>`(+&nbsp;2&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(+&nbsp;2&nbsp;3)
<br>
<br>
`(+&nbsp;2&nbsp;,(*&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(+&nbsp;2&nbsp;12)<br>

`(a&nbsp;b&nbsp;(,(+&nbsp;2&nbsp;3)&nbsp;c)&nbsp;d)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;(5&nbsp;c)&nbsp;d)<br>

`(a&nbsp;b&nbsp;,(reverse&nbsp;'(c&nbsp;d&nbsp;e))&nbsp;f&nbsp;g)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;(e&nbsp;d&nbsp;c)&nbsp;f&nbsp;g)<br>

(let&nbsp;([a&nbsp;1]&nbsp;[b&nbsp;2])<br>

&nbsp;&nbsp;`(,a&nbsp;.&nbsp;,b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;.&nbsp;2)
<br>
<br>
`(+&nbsp;,@(cdr&nbsp;'(*&nbsp;2&nbsp;3)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(+&nbsp;2&nbsp;3)<br>

`(a&nbsp;b&nbsp;,@(reverse&nbsp;'(c&nbsp;d&nbsp;e))&nbsp;f&nbsp;g)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;e&nbsp;d&nbsp;c&nbsp;f&nbsp;g)<br>

(let&nbsp;([a&nbsp;1]&nbsp;[b&nbsp;2])<br>

&nbsp;&nbsp;`(,a&nbsp;,@b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;.&nbsp;2)<br>

`#(,@(list&nbsp;1&nbsp;2&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(1&nbsp;2&nbsp;3)
<br>
<br>
'`,(cons&nbsp;'a&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;`,(cons&nbsp;'a&nbsp;'b)<br>

`',(cons&nbsp;'a&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;'(a&nbsp;.&nbsp;b)</tt>
<p><tt>unquote</tt> and <tt>unquote-splicing</tt> forms with zero or more than
one subform are valid only in splicing (list or
vector) contexts.
<tt>(unquote&nbsp;<i>obj</i>&nbsp;...)</tt> is equivalent to
<tt>(unquote&nbsp;<i>obj</i>)&nbsp;...</tt>, and
<tt>(unquote-splicing&nbsp;<i>obj</i>&nbsp;...)</tt> is equivalent to
<tt>(unquote-splicing&nbsp;<i>obj</i>)&nbsp;...</tt>.
These forms are primarily useful as intermediate forms in the output
of the <tt>quasiquote</tt> expander.
They support certain useful nested quasiquotation
idioms&nbsp;[<a class=citation href="bibliography.html#g221">3</a>], such as <tt>,@,@</tt>, which has the
effect of a doubly indirect splicing when used within a doubly nested
and doubly evaluated <tt>quasiquote</tt> expression.

<p>

<p><tt>`(a&nbsp;(unquote)&nbsp;b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b)<br>

`(a&nbsp;(unquote&nbsp;(+&nbsp;3&nbsp;3))&nbsp;b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;6&nbsp;b)<br>

`(a&nbsp;(unquote&nbsp;(+&nbsp;3&nbsp;3)&nbsp;(*&nbsp;3&nbsp;3))&nbsp;b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;6&nbsp;9&nbsp;b)
<br>
<br>
(let&nbsp;([x&nbsp;'(m&nbsp;n)])&nbsp;``(a&nbsp;,@,@x&nbsp;f))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;`(a&nbsp;(unquote-splicing&nbsp;m&nbsp;n)&nbsp;f)<br>

(let&nbsp;([x&nbsp;'(m&nbsp;n)])<br>

&nbsp;&nbsp;(eval&nbsp;`(let&nbsp;([m&nbsp;'(b&nbsp;c)]&nbsp;[n&nbsp;'(d&nbsp;e)])&nbsp;`(a&nbsp;,@,@x&nbsp;f))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(environment&nbsp;'(rnrs))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e&nbsp;f)</tt>
<p><tt>unquote</tt> and <tt>unquote-splicing</tt> are auxiliary keywords for
<tt>quasiquote</tt>.
It is a syntax violation to reference these identifiers except in contexts
where they are recognized as auxiliary keywords.


<p>

<h3><a name="g108"></a><a name="./objects:h2"></a>Section 6.2. Generic Equivalence and Type Predicates<a name="SECTGENERIC"></a></h3>



<p>
This section describes the basic Scheme <a name="./objects:s6"></a>predicates (procedures
returning one of the boolean values <a name="./objects:s7"></a><tt>#t</tt> or <a name="./objects:s8"></a><tt>#f</tt>) for
determining the type of an object or the equivalence of two objects.
The <a name="./objects:s9"></a>equivalence predicates <tt>eq?</tt>, <tt>eqv?</tt>, and <tt>equal?</tt>
are discussed first, followed by the type predicates.

<p>
<a name="./objects:s10"></a><span class=formdef><b>procedure</b>: <tt>(eq?&nbsp;<i>obj<sub>1</sub></i>&nbsp;<i>obj<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj<sub>1</sub></i></tt> and <tt><i>obj<sub>2</sub></i></tt> are identical, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>In most Scheme systems, two objects are considered identical if they
are represented internally by the same pointer value and distinct
(not identical) if they are represented internally by different pointer
values, although other criteria, such as time-stamping, are possible.

<p>
Although the particular rules for <a name="./objects:s11"></a>object identity
vary somewhat from system to system, the following rules always hold.

<p>
<ul>
<li>Two objects of different types
(booleans, the empty list, pairs, numbers, characters, strings,
vectors, symbols, and procedures)
are distinct.

<p>
<li>Two objects of the same type with different contents or values are distinct.

<p>
<li>The boolean object <tt>#t</tt> is identical to itself wherever it
appears, and <tt>#f</tt> is identical to itself wherever it appears,
but <tt>#t</tt> and <tt>#f</tt> are distinct.

<p>
<li>The empty list <tt>()</tt> is identical to itself wherever it appears.

<p>
<li>Two symbols are identical if and only if they have the same name (by
<tt>string=?</tt>).

<p>
<li>A constant pair, vector, string, or bytevector is identical to itself, as is a
pair, vector, string, or bytevector created by an application of <tt>cons</tt>,
<tt>vector</tt>, <tt>string</tt>, <tt>make-bytevector</tt>, etc.
Two pairs, vectors, strings, or bytevectors created by different applications
of <tt>cons</tt>, <tt>vector</tt>, <tt>string</tt>, <tt>make-bytevector</tt>,
etc., are distinct.
One consequence is that <tt>cons</tt>, for example, may be used to create
a unique object distinct from all other objects.

<p>
<li>Two procedures that may behave differently are distinct.
A procedure created by an evaluation of a
<tt>lambda</tt> expression is identical to itself.
Two procedures created by the same <tt>lambda</tt> expression at different
times, or by similar <tt>lambda</tt> expressions, may or may not be
distinct.
</ul>
<p>

<p>
<tt>eq?</tt> cannot be used to compare numbers and characters
reliably.
Although every inexact number is distinct from every exact number,
two exact numbers, two inexact numbers, or two characters with the
same value may or may not be identical.

<p>
Since constant objects are immutable, i.e., programs should not modify them via
<tt>vector-set!</tt>, <tt>set-car!</tt>, or any other structure mutation
operation,
all or portions of different quoted constants or self-evaluating
literals may be represented internally by the same object.
Thus, <tt>eq?</tt> may return <tt>#t</tt> when applied to equal parts of different
immutable constants.

<p>
<tt>eq?</tt> is most often used to compare symbols or to check for
pointer equivalence of allocated objects, e.g., pairs, vectors,
or record instances.

<p>

<p><tt>(eq?&nbsp;'a&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;#t&nbsp;'t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;"abc"&nbsp;'abc)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;"hi"&nbsp;'(hi))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;#f&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(eq?&nbsp;9/2&nbsp;7/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;3.4&nbsp;53344)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;3&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;1/3&nbsp;#i1/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(eq?&nbsp;9/2&nbsp;9/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(eq?&nbsp;3.4&nbsp;(+&nbsp;3.0&nbsp;.4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(let&nbsp;([x&nbsp;(*&nbsp;12345678987654321&nbsp;2)])<br>

&nbsp;&nbsp;(eq?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i>
<br>
<br>
(eq?&nbsp;#\a&nbsp;#\b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;#\a&nbsp;#\a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(let&nbsp;([x&nbsp;(string-ref&nbsp;"hi"&nbsp;0)])<br>

&nbsp;&nbsp;(eq?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i>
<br>
<br>
(eq?&nbsp;#t&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq?&nbsp;#f&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq?&nbsp;#t&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;(null?&nbsp;'())&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq?&nbsp;(null?&nbsp;'(a))&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(eq?&nbsp;(cdr&nbsp;'(a))&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(eq?&nbsp;'a&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq?&nbsp;'a&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;'a&nbsp;(string-&gt;symbol&nbsp;"a"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(eq?&nbsp;'(a)&nbsp;'(b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;'(a)&nbsp;'(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(let&nbsp;([x&nbsp;'(a&nbsp;.&nbsp;b)])&nbsp;(eq?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(cons&nbsp;'a&nbsp;'b)])<br>

&nbsp;&nbsp;(eq?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq?&nbsp;(cons&nbsp;'a&nbsp;'b)&nbsp;(cons&nbsp;'a&nbsp;'b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(eq?&nbsp;"abc"&nbsp;"cba")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;"abc"&nbsp;"abc")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(let&nbsp;([x&nbsp;"hi"])&nbsp;(eq?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(string&nbsp;#\h&nbsp;#\i)])&nbsp;(eq?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq?&nbsp;(string&nbsp;#\h&nbsp;#\i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;#\h&nbsp;#\i))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(eq?&nbsp;'#vu8(1)&nbsp;'#vu8(1))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(eq?&nbsp;'#vu8(1)&nbsp;'#vu8(2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(let&nbsp;([x&nbsp;(make-bytevector&nbsp;10&nbsp;0)])<br>

&nbsp;&nbsp;(eq?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(make-bytevector&nbsp;10&nbsp;0)])<br>

&nbsp;&nbsp;(eq?&nbsp;x&nbsp;(make-bytevector&nbsp;10&nbsp;0)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(eq?&nbsp;'#(a)&nbsp;'#(b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;'#(a)&nbsp;'#(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(let&nbsp;([x&nbsp;'#(a)])&nbsp;(eq?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(vector&nbsp;'a)])<br>

&nbsp;&nbsp;(eq?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq?&nbsp;(vector&nbsp;'a)&nbsp;(vector&nbsp;'a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(eq?&nbsp;car&nbsp;car)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq?&nbsp;car&nbsp;cdr)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;x)])<br>

&nbsp;&nbsp;(eq?&nbsp;f&nbsp;f))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([f&nbsp;(lambda&nbsp;()&nbsp;(lambda&nbsp;(x)&nbsp;x))])<br>

&nbsp;&nbsp;(eq?&nbsp;(f)&nbsp;(f)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(eq?&nbsp;(lambda&nbsp;(x)&nbsp;x)&nbsp;(lambda&nbsp;(y)&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i>
<br>
<br>
(let&nbsp;([f&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;x&nbsp;(+&nbsp;x&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x))])<br>

&nbsp;&nbsp;(eq?&nbsp;(f&nbsp;0)&nbsp;(f&nbsp;0)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s12"></a><span class=formdef><b>procedure</b>: <tt>(eqv?&nbsp;<i>obj<sub>1</sub></i>&nbsp;<i>obj<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj<sub>1</sub></i></tt> and <tt><i>obj<sub>2</sub></i></tt> are equivalent, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>eqv?</tt> is similar to <tt>eq?</tt> except <tt>eqv?</tt>
is guaranteed to return <tt>#t</tt> for two characters that are considered
equal by <tt>char=?</tt> and two numbers that are (a) considered
equal by <tt>=</tt> and (b) cannot be distinguished by any other
operation besides <tt>eq?</tt> and <tt>eqv?</tt>.
A consequence of (b) is that <tt>(eqv?&nbsp;-0.0&nbsp;+0.0)</tt> is <tt>#f</tt> even
though <tt>(=&nbsp;-0.0&nbsp;+0.0)</tt> is <tt>#t</tt> in systems that distinguish
<tt>-0.0</tt> and <tt>+0.0</tt>, such as those based on IEEE floating-point
arithmetic.
This is because operations such as <tt>/</tt> can expose the difference:

<p>

<p><tt>(/&nbsp;1.0&nbsp;-0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-inf.0<br>

(/&nbsp;1.0&nbsp;+0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;+inf.0</tt>
<p>Similarly, although 3.0 and 3.0+0.0i are considered numerically equal,
they are not considered equivalent by <tt>eqv?</tt> if -0.0 and
0.0 have different representations.

<p>

<p><tt>(=&nbsp;3.0+0.0i&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;3.0+0.0i&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>The boolean value returned by <tt>eqv?</tt> is not specified when the
arguments are NaNs.

<p>

<p><tt>(eqv?&nbsp;+nan.0&nbsp;(/&nbsp;0.0&nbsp;0.0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i></tt>
<p><tt>eqv?</tt> is less implementation-dependent but generally more
expensive than <tt>eq?</tt>.

<p>

<p><tt>(eqv?&nbsp;'a&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;#t&nbsp;'t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;"abc"&nbsp;'abc)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;"hi"&nbsp;'(hi))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;#f&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(eqv?&nbsp;9/2&nbsp;7/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;3.4&nbsp;53344)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;3&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;1/3&nbsp;#i1/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(eqv?&nbsp;9/2&nbsp;9/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;3.4&nbsp;(+&nbsp;3.0&nbsp;.4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(*&nbsp;12345678987654321&nbsp;2)])<br>

&nbsp;&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(eqv?&nbsp;#\a&nbsp;#\b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;#\a&nbsp;#\a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(string-ref&nbsp;"hi"&nbsp;0)])<br>

&nbsp;&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(eqv?&nbsp;#t&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;#f&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;#t&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;(null?&nbsp;'())&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;(null?&nbsp;'(a))&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(eqv?&nbsp;(cdr&nbsp;'(a))&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(eqv?&nbsp;'a&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;'a&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;'a&nbsp;(string-&gt;symbol&nbsp;"a"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(eqv?&nbsp;'(a)&nbsp;'(b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;'(a)&nbsp;'(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(let&nbsp;([x&nbsp;'(a&nbsp;.&nbsp;b)])&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(cons&nbsp;'a&nbsp;'b)])<br>

&nbsp;&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;(cons&nbsp;'a&nbsp;'b)&nbsp;(cons&nbsp;'a&nbsp;'b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(eqv?&nbsp;"abc"&nbsp;"cba")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;"abc"&nbsp;"abc")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(let&nbsp;([x&nbsp;"hi"])&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(string&nbsp;#\h&nbsp;#\i)])&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;(string&nbsp;#\h&nbsp;#\i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;#\h&nbsp;#\i))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(eqv?&nbsp;'#vu8(1)&nbsp;'#vu8(1))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(eqv?&nbsp;'#vu8(1)&nbsp;'#vu8(2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(let&nbsp;([x&nbsp;(make-bytevector&nbsp;10&nbsp;0)])<br>

&nbsp;&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(make-bytevector&nbsp;10&nbsp;0)])<br>

&nbsp;&nbsp;(eqv?&nbsp;x&nbsp;(make-bytevector&nbsp;10&nbsp;0)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(eqv?&nbsp;'#(a)&nbsp;'#(b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eqv?&nbsp;'#(a)&nbsp;'#(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(let&nbsp;([x&nbsp;'#(a)])&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(vector&nbsp;'a)])<br>

&nbsp;&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;(vector&nbsp;'a)&nbsp;(vector&nbsp;'a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(eqv?&nbsp;car&nbsp;car)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eqv?&nbsp;car&nbsp;cdr)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;x)])<br>

&nbsp;&nbsp;(eqv?&nbsp;f&nbsp;f))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([f&nbsp;(lambda&nbsp;()&nbsp;(lambda&nbsp;(x)&nbsp;x))])<br>

&nbsp;&nbsp;(eqv?&nbsp;(f)&nbsp;(f)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(eqv?&nbsp;(lambda&nbsp;(x)&nbsp;x)&nbsp;(lambda&nbsp;(y)&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i>
<br>
<br>
(let&nbsp;([f&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;x&nbsp;(+&nbsp;x&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x))])<br>

&nbsp;&nbsp;(eqv?&nbsp;(f&nbsp;0)&nbsp;(f&nbsp;0)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s13"></a><span class=formdef><b>procedure</b>: <tt>(equal?&nbsp;<i>obj<sub>1</sub></i>&nbsp;<i>obj<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj<sub>1</sub></i></tt> and <tt><i>obj<sub>2</sub></i></tt> have the same
structure and contents, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>Two objects are equal if they are equivalent according to <tt>eqv?</tt>,
strings that are <tt>string=?</tt>, bytevectors that are <tt>bytevector=?</tt>,
pairs whose cars and cdrs are equal, or
vectors of the same length whose corresponding elements are equal.

<p>
<tt>equal?</tt> is required to terminate even for cyclic arguments and
return <tt>#t</tt> "if and only if the (possibly infinite) unfoldings of
its arguments into regular trees are equal as ordered trees"&nbsp;[<a class=citation href="bibliography.html#g242">24</a>].
In essence, two values are equivalent, in the sense of <tt>equal?</tt>,
if the structure of the two objects cannot be distinguished by any
composition of pair and vector accessors along with the
<tt>eqv?</tt>, <tt>string=?</tt>, and <tt>bytevector=?</tt> procedures for
comparing data at the leaves.

<p>
Implementing <tt>equal?</tt> efficiently is tricky&nbsp;[<a class=citation href="bibliography.html#g219">1</a>], and
even with a good implementation, it is likely to be more expensive than
either <tt>eqv?</tt> or <tt>eq?</tt>.

<p>

<p><tt>(equal?&nbsp;'a&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;#t&nbsp;'t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;"abc"&nbsp;'abc)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;"hi"&nbsp;'(hi))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;#f&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(equal?&nbsp;9/2&nbsp;7/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;3.4&nbsp;53344)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;3&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;1/3&nbsp;#i1/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(equal?&nbsp;9/2&nbsp;9/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(equal?&nbsp;3.4&nbsp;(+&nbsp;3.0&nbsp;.4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(*&nbsp;12345678987654321&nbsp;2)])<br>

&nbsp;&nbsp;(equal?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(equal?&nbsp;#\a&nbsp;#\b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;#\a&nbsp;#\a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(string-ref&nbsp;"hi"&nbsp;0)])<br>

&nbsp;&nbsp;(equal?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(equal?&nbsp;#t&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(equal?&nbsp;#f&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(equal?&nbsp;#t&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;(null?&nbsp;'())&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(equal?&nbsp;(null?&nbsp;'(a))&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(equal?&nbsp;(cdr&nbsp;'(a))&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(equal?&nbsp;'a&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(equal?&nbsp;'a&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;'a&nbsp;(string-&gt;symbol&nbsp;"a"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(equal?&nbsp;'(a)&nbsp;'(b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;'(a)&nbsp;'(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;'(a&nbsp;.&nbsp;b)])&nbsp;(equal?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(cons&nbsp;'a&nbsp;'b)])<br>

&nbsp;&nbsp;(equal?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(equal?&nbsp;(cons&nbsp;'a&nbsp;'b)&nbsp;(cons&nbsp;'a&nbsp;'b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(equal?&nbsp;"abc"&nbsp;"cba")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;"abc"&nbsp;"abc")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;"hi"])&nbsp;(equal?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(string&nbsp;#\h&nbsp;#\i)])&nbsp;(equal?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(equal?&nbsp;(string&nbsp;#\h&nbsp;#\i)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string&nbsp;#\h&nbsp;#\i))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(equal?&nbsp;'#vu8(1)&nbsp;'#vu8(1))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(equal?&nbsp;'#vu8(1)&nbsp;'#vu8(2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(let&nbsp;([x&nbsp;(make-bytevector&nbsp;10&nbsp;0)])<br>

&nbsp;&nbsp;(equal?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(make-bytevector&nbsp;10&nbsp;0)])<br>

&nbsp;&nbsp;(equal?&nbsp;x&nbsp;(make-bytevector&nbsp;10&nbsp;0)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(equal?&nbsp;'#(a)&nbsp;'#(b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(equal?&nbsp;'#(a)&nbsp;'#(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;'#(a)])&nbsp;(equal?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;(vector&nbsp;'a)])<br>

&nbsp;&nbsp;(equal?&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(equal?&nbsp;(vector&nbsp;'a)&nbsp;(vector&nbsp;'a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(equal?&nbsp;car&nbsp;car)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(equal?&nbsp;car&nbsp;cdr)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;x)])<br>

&nbsp;&nbsp;(equal?&nbsp;f&nbsp;f))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([f&nbsp;(lambda&nbsp;()&nbsp;(lambda&nbsp;(x)&nbsp;x))])<br>

&nbsp;&nbsp;(equal?&nbsp;(f)&nbsp;(f)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i><br>

(equal?&nbsp;(lambda&nbsp;(x)&nbsp;x)&nbsp;(lambda&nbsp;(y)&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>unspecified</i>
<br>
<br>
(let&nbsp;([f&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;x&nbsp;(+&nbsp;x&nbsp;1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x))])<br>

&nbsp;&nbsp;(equal?&nbsp;(f&nbsp;0)&nbsp;(f&nbsp;0)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(equal?<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;(cons&nbsp;'x&nbsp;'x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;x&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;x&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;x)<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;(cons&nbsp;'x&nbsp;'x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;x&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;x&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;x&nbsp;x)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s14"></a><span class=formdef><b>procedure</b>: <tt>(boolean?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is either <tt>#t</tt> or <tt>#f</tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>boolean?</tt> is equivalent to
<tt>(lambda&nbsp;(x)&nbsp;(or&nbsp;(eq?&nbsp;x&nbsp;#t)&nbsp;(eq?&nbsp;x&nbsp;#f)))</tt>.

<p>

<p><tt>(boolean?&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(boolean?&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(or&nbsp;(boolean?&nbsp;'t)&nbsp;(boolean?&nbsp;'()))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s15"></a><span class=formdef><b>procedure</b>: <tt>(null?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is the empty list, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>null?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(eq?&nbsp;x&nbsp;'()))</tt>.

<p>

<p><tt>(null?&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(null?&nbsp;'(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(null?&nbsp;(cdr&nbsp;'(a)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(null?&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(null?&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s16"></a><span class=formdef><b>procedure</b>: <tt>(pair?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a pair, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(pair?&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(pair?&nbsp;'(3&nbsp;.&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(pair?&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(pair?&nbsp;'#(a&nbsp;b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(pair?&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s17"></a><span class=formdef><b>procedure</b>: <tt>(number?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a number object, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(complex?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a complex number object, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(real?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a real number object, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(rational?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a rational number object, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(integer?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an integer object, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>These predicates form a hierarchy: any integer is rational, any
rational is real, any real is complex, and any complex is numeric.
Most implementations do not provide internal representations for
irrational numbers, so all real numbers are typically rational
as well.

<p>
The <tt>real?</tt>, <tt>rational?</tt>, and <tt>integer?</tt> predicates do
not recognize as real, rational, or integer complex numbers with inexact
zero imaginary parts.

<p>

<p><tt>(integer?&nbsp;1901)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(rational?&nbsp;1901)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(real?&nbsp;1901)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(complex?&nbsp;1901)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(number?&nbsp;1901)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(integer?&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(rational?&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(real?&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(complex?&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(number?&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(integer?&nbsp;7+0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(rational?&nbsp;7+0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(real?&nbsp;7+0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(complex?&nbsp;7+0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(number?&nbsp;7+0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(integer?&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(rational?&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(real?&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(complex?&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(number?&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(integer?&nbsp;-2.345)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(rational?&nbsp;-2.345)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(real?&nbsp;-2.345)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(complex?&nbsp;-2.345)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(number?&nbsp;-2.345)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(integer?&nbsp;7.0+0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(rational?&nbsp;7.0+0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(real?&nbsp;7.0+0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(complex?&nbsp;7.0+0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(number?&nbsp;7.0+0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(integer?&nbsp;3.2-2.01i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(rational?&nbsp;3.2-2.01i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(real?&nbsp;3.2-2.01i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(complex?&nbsp;3.2-2.01i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(number?&nbsp;3.2-2.01i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(integer?&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(rational?&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(real?&nbsp;"3")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(complex?&nbsp;'#(1&nbsp;2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(number?&nbsp;#\a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s18"></a><span class=formdef><b>procedure</b>: <tt>(real-valued?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a real number, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(rational-valued?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a rational number, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(integer-valued?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an integer, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>These predicates are similar to <tt>real?</tt>, <tt>rational?</tt>, and
<tt>integer?</tt>, but treat as real, rational, or integral complex numbers
with inexact zero imaginary parts.

<p>

<p><tt>(integer-valued?&nbsp;1901)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(rational-valued?&nbsp;1901)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(real-valued?&nbsp;1901)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(integer-valued?&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(rational-valued?&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(real-valued?&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(integer-valued?&nbsp;7+0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(rational-valued?&nbsp;7+0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(real-valued?&nbsp;7+0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(integer-valued?&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(rational-valued?&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(real-valued?&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(integer-valued?&nbsp;-2.345)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(rational-valued?&nbsp;-2.345)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(real-valued?&nbsp;-2.345)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(integer-valued?&nbsp;7.0+0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(rational-valued?&nbsp;7.0+0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(real-valued?&nbsp;7.0+0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(integer-valued?&nbsp;3.2-2.01i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(rational-valued?&nbsp;3.2-2.01i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(real-valued?&nbsp;3.2-2.01i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>As with <tt>real?</tt>, <tt>rational?</tt>, and <tt>integer?</tt>, these
predicates return <tt>#f</tt> for all non-numeric values.

<p>

<p><tt>(integer-valued?&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(rational-valued?&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(real-valued?&nbsp;"3")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s19"></a><span class=formdef><b>procedure</b>: <tt>(char?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a character, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(char?&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(char?&nbsp;97)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(char?&nbsp;#\a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(char?&nbsp;"a")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(char?&nbsp;(string-ref&nbsp;(make-string&nbsp;1)&nbsp;0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s20"></a><span class=formdef><b>procedure</b>: <tt>(string?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a string, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(string?&nbsp;"hi")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(string?&nbsp;'hi)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(string?&nbsp;#\h)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s21"></a><span class=formdef><b>procedure</b>: <tt>(vector?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a vector, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(vector?&nbsp;'#())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(vector?&nbsp;'#(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(vector?&nbsp;(vector&nbsp;'a&nbsp;'b&nbsp;'c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(vector?&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(vector?&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(vector?&nbsp;"abc")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s22"></a><span class=formdef><b>procedure</b>: <tt>(symbol?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a symbol, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(symbol?&nbsp;'t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(symbol?&nbsp;"t")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(symbol?&nbsp;'(t))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(symbol?&nbsp;#\t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(symbol?&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(symbol?&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s23"></a><span class=formdef><b>procedure</b>: <tt>(procedure?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a procedure, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(procedure?&nbsp;car)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(procedure?&nbsp;'car)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(procedure?&nbsp;(lambda&nbsp;(x)&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(procedure?&nbsp;'(lambda&nbsp;(x)&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(call/cc&nbsp;procedure?)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s24"></a><span class=formdef><b>procedure</b>: <tt>(bytevector?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a bytevector, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(bytevector?&nbsp;#vu8())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(bytevector?&nbsp;'#())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(bytevector?&nbsp;"abc")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s25"></a><span class=formdef><b>procedure</b>: <tt>(hashtable?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a hashtable, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>(hashtable?&nbsp;(make-eq-hashtable))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(hashtable?&nbsp;'(not&nbsp;a&nbsp;hash&nbsp;table))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p>
<h3><a name="g109"></a><a name="./objects:h3"></a>Section 6.3. Lists and Pairs<a name="SECTPAIRS"></a></h3>



<p>
<a name="./objects:s26"></a>The pair, or <a name="./objects:s27"></a><i>cons cell</i>, is the most fundamental of Scheme's
structured object types.
The most common use for pairs is to build <a name="./objects:s28"></a>lists, which are
ordered sequences of pairs linked one to the next by the
<a name="./objects:s29"></a><i>cdr</i> field.
The elements of the list occupy the <a name="./objects:s30"></a><i>car</i>
fields of the pairs.
The cdr of the last pair in a <a name="./objects:s31"></a><i>proper list</i> is
the empty list, <tt>()</tt>; the cdr of the last pair in an
<a name="./objects:s32"></a><i>improper list</i> can be anything other than
<tt>()</tt>.

<p>
Pairs may be used to construct <a name="./objects:s33"></a>binary trees.
Each pair in the tree structure is an internal node of the binary tree;
its car and cdr are the children of the node.

<p>
Proper lists are printed as sequences of objects separated by whitespace
and enclosed in parentheses.
Matching pairs of <a name="./objects:s34"></a>brackets
(&nbsp;<tt>[</tt>&nbsp;<tt>]</tt>&nbsp;) may be used in place of parentheses.
For example, <tt>(1&nbsp;2&nbsp;3)</tt> and <tt>(a&nbsp;[nested&nbsp;list])</tt> are proper lists.
The empty list is written as <tt>()</tt>.

<p>
Improper lists and trees require a slightly more complex syntax.
A single pair is written as two objects separated by whitespace and a dot,
e.g., <tt>(a&nbsp;.&nbsp;b)</tt>.
<a name="./objects:s35"></a>This is referred to as <i>dotted-pair notation</i>.
Improper lists and trees are also written in dotted-pair notation; the dot
appears wherever necessary, e.g., <tt>(1&nbsp;2&nbsp;3&nbsp;.&nbsp;4)</tt> or <tt>((1&nbsp;.&nbsp;2)&nbsp;.&nbsp;3)</tt>.
Proper lists may be written in dotted-pair notation as well.
For example, <tt>(1&nbsp;2&nbsp;3)</tt> may be written as <tt>(1&nbsp;.&nbsp;(2&nbsp;.&nbsp;(3&nbsp;.&nbsp;())))</tt>.

<p>
<a name="./objects:s36"></a>It is possible to create a circular list or a cyclic
graph by destructively
altering the car or cdr field of a pair, using <tt>set-car!</tt> or <tt>set-cdr!</tt>.
Such lists are not considered proper lists.

<p>
Procedures that accept a <tt><i>list</i></tt> argument
are required to detect that the list is improper only to the extent that they
actually traverse the list far enough either (a) to attempt to operate on a
non-list tail or (b) to loop indefinitely due to a circularity.
For example, <tt>member</tt> need not detect that a list is improper if it
actually finds the element being sought, and <tt>list-ref</tt> need never
detect circularities, because its recursion is bounded by the index
argument.

<p>
<a name="./objects:s37"></a><span class=formdef><b>procedure</b>: <tt>(cons&nbsp;<i>obj<sub>1</sub></i>&nbsp;<i>obj<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>a new pair whose car and cdr are <tt><i>obj<sub>1</sub></i></tt> and <tt><i>obj<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>cons</tt> is the pair constructor procedure.
<tt><i>obj<sub>1</sub></i></tt> becomes the car and <tt><i>obj<sub>2</sub></i></tt> becomes the cdr of the
new pair.

<p>

<p><tt>(cons&nbsp;'a&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a)<br>

(cons&nbsp;'a&nbsp;'(b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(cons&nbsp;3&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(3&nbsp;.&nbsp;4)</tt>
<p><a name="./objects:s38"></a><span class=formdef><b>procedure</b>: <tt>(car&nbsp;<i>pair</i>)</tt></span>
<br>
<b>returns: </b>the car of <tt><i>pair</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The empty list is not a pair, so the argument must not be the empty list.

<p>

<p><tt>(car&nbsp;'(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(car&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(car&nbsp;(cons&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3</tt>
<p><a name="./objects:s39"></a><span class=formdef><b>procedure</b>: <tt>(cdr&nbsp;<i>pair</i>)</tt></span>
<br>
<b>returns: </b>the cdr of <tt><i>pair</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The empty list is not a pair, so the argument must not be the empty list.

<p>

<p><tt>(cdr&nbsp;'(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(cdr&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c)<br>

(cdr&nbsp;(cons&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><a name="./objects:s40"></a><span class=formdef><b>procedure</b>: <tt>(set-car!&nbsp;<i>pair</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;mutable-pairs)</tt>

<p><tt>set-car!</tt> changes the car of <tt><i>pair</i></tt> to <tt><i>obj</i></tt>.

<p>

<p><tt>(let&nbsp;([x&nbsp;(list&nbsp;'a&nbsp;'b&nbsp;'c)])<br>

&nbsp;&nbsp;(set-car!&nbsp;x&nbsp;1)<br>

&nbsp;&nbsp;x)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;b&nbsp;c)</tt>
<p><a name="./objects:s41"></a><span class=formdef><b>procedure</b>: <tt>(set-cdr!&nbsp;<i>pair</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;mutable-pairs)</tt>

<p><tt>set-cdr!</tt> changes the cdr of <tt><i>pair</i></tt> to <tt><i>obj</i></tt>.

<p>

<p><tt>(let&nbsp;([x&nbsp;(list&nbsp;'a&nbsp;'b&nbsp;'c)])<br>

&nbsp;&nbsp;(set-cdr!&nbsp;x&nbsp;1)<br>

&nbsp;&nbsp;x)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;.&nbsp;1)</tt>
<p><a name="./objects:s42"></a><span class=formdef><b>procedure</b>: <tt>(caar&nbsp;<i>pair</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(cadr&nbsp;<i>pair</i>)</tt></span>

























<img src="math/tspl/3.gif" alt="<graphic>"> <br>
<span class=formdef><b>procedure</b>: <tt>(cddddr&nbsp;<i>pair</i>)</tt></span>
<br>
<b>returns: </b>the caar, cadr, ..., or cddddr of <tt><i>pair</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>These procedures are defined as the composition of up to four <tt>car</tt>s
and <tt>cdr</tt>s.
The <tt>a</tt>'s and <tt>d</tt>'s between the <tt>c</tt> and <tt>r</tt> represent the
application of <tt>car</tt> or <tt>cdr</tt> in order from right to left.
For example, the procedure <tt>cadr</tt> applied to a pair yields the <tt>car</tt>
of the <tt>cdr</tt> of the pair and is equivalent to
<tt>(lambda&nbsp;(x)&nbsp;(car&nbsp;(cdr&nbsp;x)))</tt>.

<p>

<p><tt>(caar&nbsp;'((a)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(cadr&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(cdddr&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(d)<br>

(cadadr&nbsp;'(a&nbsp;(b&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;c</tt>
<p><a name="./objects:s43"></a><span class=formdef><b>procedure</b>: <tt>(list&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a list of <tt><i>obj</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>list</tt> is equivalent to <tt>(lambda&nbsp;x&nbsp;x)</tt>.

<p>

<p><tt>(list)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(list&nbsp;1&nbsp;2&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3)<br>

(list&nbsp;3&nbsp;2&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(3&nbsp;2&nbsp;1)</tt>
<p><a name="./objects:s44"></a><span class=formdef><b>procedure</b>: <tt>(cons*&nbsp;<i>obj</i>&nbsp;...&nbsp;<i>final-obj</i>)</tt></span>
<br>
<b>returns: </b>a list of <tt><i>obj</i>&nbsp;...</tt> terminated by <tt><i>final-obj</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p>If the objects <tt><i>obj</i>&nbsp;...</tt> are omitted, the result is simply
<tt><i>final-obj</i></tt>.
Otherwise, a list of <tt><i>obj</i>&nbsp;...</tt> is constructed, as with <tt>list</tt>, except
that the final cdr field is <tt><i>final-obj</i></tt> instead of <tt>()</tt>.
If <tt><i>final-obj</i></tt> is not a list, the result is an improper list.

<p>

<p><tt>(cons*&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(cons*&nbsp;'(a&nbsp;b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b)<br>

(cons*&nbsp;'a&nbsp;'b&nbsp;'c)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;.&nbsp;c)<br>

(cons*&nbsp;'a&nbsp;'b&nbsp;'(c&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)</tt>
<p><a name="./objects:s45"></a><span class=formdef><b>procedure</b>: <tt>(list?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a proper list, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>list?</tt> must return <tt>#f</tt> for all improper lists, including cyclic
lists.
A definition of <tt>list?</tt> is shown on page&nbsp;<a href="further.html#defn:list?">67</a>.

<p>

<p><tt>(list?&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(list?&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(list?&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(list?&nbsp;'(3&nbsp;.&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(list?&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(let&nbsp;([x&nbsp;(list&nbsp;'a&nbsp;'b&nbsp;'c)])<br>

&nbsp;&nbsp;(set-cdr!&nbsp;(cddr&nbsp;x)&nbsp;x)<br>

&nbsp;&nbsp;(list?&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s46"></a><span class=formdef><b>procedure</b>: <tt>(length&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>the number of elements in <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>length</tt> may be defined as follows, using an adaptation of the
hare and tortoise algorithm used for the definition of <tt>list?</tt>
on page&nbsp;<a href="further.html#defn:list?">67</a>.

<p>

<p><tt>(define&nbsp;length<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;improper-list<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violation&nbsp;'length&nbsp;"not&nbsp;a&nbsp;proper&nbsp;list"&nbsp;x)))
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([h&nbsp;x]&nbsp;[t&nbsp;x]&nbsp;[n&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;h)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([h&nbsp;(cdr&nbsp;h)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(pair?&nbsp;h)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eq?&nbsp;h&nbsp;t)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(improper-list)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;(cdr&nbsp;h)&nbsp;(cdr&nbsp;t)&nbsp;(+&nbsp;n&nbsp;2)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;h)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;n&nbsp;1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(improper-list))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;h)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(improper-list))))))
<br>
<br>
(length&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(length&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(length&nbsp;'(a&nbsp;b&nbsp;.&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception</i><br>

(length<br>

&nbsp;&nbsp;(let&nbsp;([ls&nbsp;(list&nbsp;'a&nbsp;'b)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-cdr!&nbsp;(cdr&nbsp;ls)&nbsp;ls)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception</i><br>

&nbsp;&nbsp;&nbsp;&nbsp;ls))<br>

(length<br>

&nbsp;&nbsp;(let&nbsp;([ls&nbsp;(list&nbsp;'a&nbsp;'b)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set-car!&nbsp;(cdr&nbsp;ls)&nbsp;ls)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

&nbsp;&nbsp;&nbsp;&nbsp;ls))</tt>
<p><a name="./objects:s47"></a><span class=formdef><b>procedure</b>: <tt>(list-ref&nbsp;<i>list</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the <tt><i>n</i></tt>th element (zero-based) of <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer less than
the length of <tt><i>list</i></tt>.
<tt>list-ref</tt> may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;list-ref<a name="defn:list-ref"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(ls&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(car&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-ref&nbsp;(cdr&nbsp;ls)&nbsp;(-&nbsp;n&nbsp;1)))))
<br>
<br>
(list-ref&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(list-ref&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(list-ref&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;c</tt>
<p><a name="./objects:s48"></a><span class=formdef><b>procedure</b>: <tt>(list-tail&nbsp;<i>list</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the <tt><i>n</i></tt>th tail (zero-based) of <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer less than or equal to
the length of <tt><i>list</i></tt>.
The result is not a copy; the tail is <tt>eq?</tt> to the <tt><i>n</i></tt>th cdr of
<tt><i>list</i></tt> (or to <tt><i>list</i></tt> itself, if <tt><i>n</i></tt> is zero).

<p>
<tt>list-tail</tt> may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;list-tail<a name="defn:list-tail"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(ls&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ls<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list-tail&nbsp;(cdr&nbsp;ls)&nbsp;(-&nbsp;n&nbsp;1)))))
<br>
<br>
(list-tail&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(list-tail&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(c)<br>

(list-tail&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(list-tail&nbsp;'(a&nbsp;b&nbsp;c&nbsp;.&nbsp;d)&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(c&nbsp;.&nbsp;d)<br>

(list-tail&nbsp;'(a&nbsp;b&nbsp;c&nbsp;.&nbsp;d)&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;d<br>

(let&nbsp;([x&nbsp;(list&nbsp;1&nbsp;2&nbsp;3)])<br>

&nbsp;&nbsp;(eq?&nbsp;(list-tail&nbsp;x&nbsp;2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cddr&nbsp;x)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s49"></a><span class=formdef><b>procedure</b>: <tt>(append)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(append&nbsp;<i>list</i>&nbsp;...&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>the concatenation of the input lists
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>append</tt> returns a new list consisting of the elements of the first
list followed by the elements of the second list, the elements of the
third list, and so on.
The new list is made from new pairs for all arguments but the last; the
last (which need not be a list) is merely placed at the end of
the new structure.
<tt>append</tt> may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;append<br>

&nbsp;&nbsp;(lambda&nbsp;args<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([ls&nbsp;'()]&nbsp;[args&nbsp;args])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ls<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;g&nbsp;([ls&nbsp;ls])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;(car&nbsp;args)&nbsp;(cdr&nbsp;args))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;ls)&nbsp;(g&nbsp;(cdr&nbsp;ls)))))))))
<br>
<br>
(append&nbsp;'(a&nbsp;b&nbsp;c)&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(append&nbsp;'()&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(append&nbsp;'(a&nbsp;b)&nbsp;'(c&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)<br>

(append&nbsp;'(a&nbsp;b)&nbsp;'c)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;.&nbsp;c)<br>

(let&nbsp;([x&nbsp;(list&nbsp;'b)])<br>

&nbsp;&nbsp;(eq?&nbsp;x&nbsp;(cdr&nbsp;(append&nbsp;'(a)&nbsp;x))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s50"></a><span class=formdef><b>procedure</b>: <tt>(reverse&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a new list containing the elements of <tt><i>list</i></tt> in reverse order
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>reverse</tt> may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;reverse<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;rev&nbsp;([ls&nbsp;ls]&nbsp;[new&nbsp;'()])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rev&nbsp;(cdr&nbsp;ls)&nbsp;(cons&nbsp;(car&nbsp;ls)&nbsp;new))))))
<br>
<br>
(reverse&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(reverse&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(c&nbsp;b&nbsp;a)</tt>
<p><a name="./objects:s51"></a><span class=formdef><b>procedure</b>: <tt>(memq&nbsp;<i>obj</i>&nbsp;<i>list</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(memv&nbsp;<i>obj</i>&nbsp;<i>list</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(member&nbsp;<i>obj</i>&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>the first tail of <tt><i>list</i></tt> whose car is equivalent to <tt><i>obj</i></tt>, or <tt>#f</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p>These procedures traverse the argument <tt><i>list</i></tt> in order, comparing the
elements of <tt><i>list</i></tt> against <tt><i>obj</i></tt>.
If an object equivalent to <tt><i>obj</i></tt> is found, the tail of the list whose
first element is that object is returned.
If the list contains more than one object equivalent to <tt><i>obj</i></tt>, the first
tail whose first element is equivalent to <tt><i>obj</i></tt> is returned.
If no object equivalent to <tt><i>obj</i></tt> is found, <tt>#f</tt> is returned.
The equivalence test for <tt>memq</tt> is <tt>eq?</tt>, for <tt>memv</tt> is <tt>eqv?</tt>,
and for <tt>member</tt> is <tt>equal?</tt>.

<p>
These procedures are most often used as predicates, but their names do not
end with a question mark because they return a useful true value in place
of <tt>#t</tt>.
<tt>memq</tt> may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;memq<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;ls)&nbsp;#f]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eq?&nbsp;(car&nbsp;ls)&nbsp;x)&nbsp;ls]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(memq&nbsp;x&nbsp;(cdr&nbsp;ls))])))</tt>
<p><tt>memv</tt> and <tt>member</tt> may be defined similarly, with <tt>eqv?</tt> and <tt>equal?</tt>
in place of <tt>eq?</tt>.

<p>

<p><tt>(memq&nbsp;'a&nbsp;'(b&nbsp;c&nbsp;a&nbsp;d&nbsp;e))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;d&nbsp;e)<br>

(memq&nbsp;'a&nbsp;'(b&nbsp;c&nbsp;d&nbsp;e&nbsp;g))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(memq&nbsp;'a&nbsp;'(b&nbsp;a&nbsp;c&nbsp;a&nbsp;d&nbsp;a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;c&nbsp;a&nbsp;d&nbsp;a)
<br>
<br>
(memv&nbsp;3.4&nbsp;'(1.2&nbsp;2.3&nbsp;3.4&nbsp;4.5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(3.4&nbsp;4.5)<br>

(memv&nbsp;3.4&nbsp;'(1.3&nbsp;2.5&nbsp;3.7&nbsp;4.9))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(let&nbsp;([ls&nbsp;(list&nbsp;'a&nbsp;'b&nbsp;'c)])<br>

&nbsp;&nbsp;(set-car!&nbsp;(memv&nbsp;'b&nbsp;ls)&nbsp;'z)<br>

&nbsp;&nbsp;ls)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;z&nbsp;c)
<br>
<br>
(member&nbsp;'(b)&nbsp;'((a)&nbsp;(b)&nbsp;(c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((b)&nbsp;(c))<br>

(member&nbsp;'(d)&nbsp;'((a)&nbsp;(b)&nbsp;(c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(member&nbsp;"b"&nbsp;'("a"&nbsp;"b"&nbsp;"c"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;("b"&nbsp;"c")
<br>
<br>
(let&nbsp;()<br>

&nbsp;&nbsp;(define&nbsp;member?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(member&nbsp;x&nbsp;ls)&nbsp;#t)))<br>

&nbsp;&nbsp;(member?&nbsp;'(b)&nbsp;'((a)&nbsp;(b)&nbsp;(c))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(define&nbsp;count-occurrences<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(memq&nbsp;x&nbsp;ls)&nbsp;=&gt;<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(count-occurrences&nbsp;x&nbsp;(cdr&nbsp;ls))&nbsp;1))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;0])))
<br>
<br>
(count-occurrences&nbsp;'a&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d&nbsp;a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2</tt>
<p><a name="./objects:s52"></a><span class=formdef><b>procedure</b>: <tt>(memp&nbsp;<i>procedure</i>&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>the first tail of <tt><i>list</i></tt> for whose car <tt><i>procedure</i></tt> returns true, or <tt>#f</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p><tt><i>procedure</i></tt> should accept one argument and return a single value.
It should not modify <tt><i>list</i></tt>.

<p>

<p><tt>(memp&nbsp;odd?&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;3&nbsp;4)<br>

(memp&nbsp;even?&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2&nbsp;3&nbsp;4)<br>

(let&nbsp;([ls&nbsp;(list&nbsp;1&nbsp;2&nbsp;3&nbsp;4)])<br>

&nbsp;&nbsp;(eq?&nbsp;(memp&nbsp;odd?&nbsp;ls)&nbsp;ls))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([ls&nbsp;(list&nbsp;1&nbsp;2&nbsp;3&nbsp;4)])<br>

&nbsp;&nbsp;(eq?&nbsp;(memp&nbsp;even?&nbsp;ls)&nbsp;(cdr&nbsp;ls)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(memp&nbsp;odd?&nbsp;'(2&nbsp;4&nbsp;6&nbsp;8))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s53"></a><span class=formdef><b>procedure</b>: <tt>(remq&nbsp;<i>obj</i>&nbsp;<i>list</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(remv&nbsp;<i>obj</i>&nbsp;<i>list</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(remove&nbsp;<i>obj</i>&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a list containing the elements of <tt><i>list</i></tt> with all occurrences of <tt><i>obj</i></tt> removed
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p>These procedures traverse the argument <tt><i>list</i></tt>, removing any objects
that are equivalent to <tt><i>obj</i></tt>.
The elements remaining in the output list are in the same order as they appear
in the input list.
If a tail of <tt><i>list</i></tt> (including <tt><i>list</i></tt> itself) contains no occurrences of 
<tt><i>obj</i></tt>, the corresponding tail of the result list may be the same
(by <tt>eq?</tt>) as the tail of the input list.

<p>
The equivalence test for <tt>remq</tt> is <tt>eq?</tt>,
for <tt>remv</tt> is <tt>eqv?</tt>,
and for <tt>remove</tt> is <tt>equal?</tt>.

<p>

<p><tt>(remq&nbsp;'a&nbsp;'(a&nbsp;b&nbsp;a&nbsp;c&nbsp;a&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c&nbsp;d)<br>

(remq&nbsp;'a&nbsp;'(b&nbsp;c&nbsp;d))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;c&nbsp;d)
<br>
<br>
(remv&nbsp;1/2&nbsp;'(1.2&nbsp;1/2&nbsp;0.5&nbsp;3/2&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1.2&nbsp;0.5&nbsp;3/2&nbsp;4)
<br>
<br>
(remove&nbsp;'(b)&nbsp;'((a)&nbsp;(b)&nbsp;(c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((a)&nbsp;(c))</tt>
<p><a name="./objects:s54"></a><span class=formdef><b>procedure</b>: <tt>(remp&nbsp;<i>procedure</i>&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a list of the elements of <tt><i>list</i></tt> for which <tt><i>procedure</i></tt> returns <tt>#f</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p><tt><i>procedure</i></tt> should accept one argument and return a single value.
It should not modify <tt><i>list</i></tt>.

<p>
<tt>remp</tt> applies <tt><i>procedure</i></tt> to each element of <tt><i>list</i></tt>
and returns a list containing only the elements for which
<tt><i>procedure</i></tt> returns <tt>#f</tt>.
The elements of the returned list appear in the same order as they
appeared in the original list.

<p>

<p><tt>(remp&nbsp;odd?&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2&nbsp;4)<br>

(remp<br>

&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(and&nbsp;(&gt;&nbsp;x&nbsp;0)&nbsp;(&lt;&nbsp;x&nbsp;10)))<br>

&nbsp;&nbsp;'(-5&nbsp;15&nbsp;3&nbsp;14&nbsp;-20&nbsp;6&nbsp;0&nbsp;-9))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(-5&nbsp;15&nbsp;14&nbsp;-20&nbsp;0&nbsp;-9)</tt>
<p><a name="./objects:s55"></a><span class=formdef><b>procedure</b>: <tt>(filter&nbsp;<i>procedure</i>&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a list of the elements of <tt><i>list</i></tt> for which <tt><i>procedure</i></tt> returns true
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p><tt><i>procedure</i></tt> should accept one argument and return a single value.
It should not modify <tt><i>list</i></tt>.

<p>
<tt>filter</tt> applies <tt><i>procedure</i></tt> to each element of <tt><i>list</i></tt>
and returns a new list containing only the elements for which
<tt><i>procedure</i></tt> returns true.
The elements of the returned list appear in the same order as they
appeared in the original list.

<p>

<p><tt>(filter&nbsp;odd?&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;3)<br>

(filter<br>

&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(and&nbsp;(&gt;&nbsp;x&nbsp;0)&nbsp;(&lt;&nbsp;x&nbsp;10)))<br>

&nbsp;&nbsp;'(-5&nbsp;15&nbsp;3&nbsp;14&nbsp;-20&nbsp;6&nbsp;0&nbsp;-9))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(3&nbsp;6)</tt>
<p><a name="./objects:s56"></a><span class=formdef><b>procedure</b>: <tt>(partition&nbsp;<i>procedure</i>&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p><tt><i>procedure</i></tt> should accept one argument and return a single value.
It should not modify <tt><i>list</i></tt>.

<p>
<tt>partition</tt> applies <tt><i>procedure</i></tt> to each element of <tt><i>list</i></tt>
and returns two values:
a new list containing only the elements for which
<tt><i>procedure</i></tt> returns true, and
a new list containing only the elements for which
<tt><i>procedure</i></tt> returns <tt>#f</tt>.
The elements of the returned lists appear in the same order as they
appeared in the original list.

<p>

<p><tt>(partition&nbsp;odd?&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;3)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;(2&nbsp;4)<br>

(partition<br>

&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(and&nbsp;(&gt;&nbsp;x&nbsp;0)&nbsp;(&lt;&nbsp;x&nbsp;10)))<br>

&nbsp;&nbsp;'(-5&nbsp;15&nbsp;3&nbsp;14&nbsp;-20&nbsp;6&nbsp;0&nbsp;-9))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(3&nbsp;6)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;(-5&nbsp;15&nbsp;14&nbsp;-20&nbsp;0&nbsp;-9)</tt>
<p>The values returned by <tt>partition</tt> can be obtained by calling
<tt>filter</tt> and <tt>remp</tt> separately, but this would require
two calls to <tt><i>procedure</i></tt> for each element of <tt><i>list</i></tt>.

<p>
<a name="./objects:s57"></a><span class=formdef><b>procedure</b>: <tt>(find&nbsp;<i>procedure</i>&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>the first element of <tt><i>list</i></tt> for which <tt><i>procedure</i></tt> returns true, or <tt>#f</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p><tt><i>procedure</i></tt> should accept one argument and return a single value.
It should not modify <tt><i>list</i></tt>.

<p>
<tt>find</tt> traverses the argument <tt><i>list</i></tt> in order, applying
<tt><i>procedure</i></tt> to each element in turn.
If <tt><i>procedure</i></tt> returns a true value for a given element, <tt>find</tt>
returns that element without applying <tt><i>procedure</i></tt> to the remaining elements.
If <tt><i>procedure</i></tt> returns <tt>#f</tt> for each element of <tt><i>list</i></tt>,
<tt>find</tt> returns <tt>#f</tt>.

<p>
If a program must distinguish between finding <tt>#f</tt> in the list
and finding no element at all, <tt>memp</tt> should be used instead.

<p>

<p><tt>(find&nbsp;odd?&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(find&nbsp;even?&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(find&nbsp;odd?&nbsp;'(2&nbsp;4&nbsp;6&nbsp;8))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(find&nbsp;not&nbsp;'(1&nbsp;a&nbsp;#f&nbsp;55))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s58"></a><a name="page:assq"></a>
<span class=formdef><b>procedure</b>: <tt>(assq&nbsp;<i>obj</i>&nbsp;<i>alist</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(assv&nbsp;<i>obj</i>&nbsp;<i>alist</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(assoc&nbsp;<i>obj</i>&nbsp;<i>alist</i>)</tt></span>
<br>
<b>returns: </b>first element of <tt><i>alist</i></tt> whose car is equivalent to <tt><i>obj</i></tt>, or <tt>#f</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p>The argument <tt><i>alist</i></tt> must be an <a name="./objects:s59"></a><i>association list</i>.
An association list is a proper list whose elements are key-value pairs
of the form <tt>(key&nbsp;.&nbsp;value)</tt>.
Associations are useful for storing information (values) associated with
certain objects (keys).

<p>
These procedures traverse the association list, testing each key for equivalence
with <tt><i>obj</i></tt>.
If an equivalent key is found, the key-value pair is returned.
Otherwise, <tt>#f</tt> is returned.

<p>
The equivalence test for <tt>assq</tt> is <tt>eq?</tt>,
for <tt>assv</tt> is <tt>eqv?</tt>,
and for <tt>assoc</tt> is <tt>equal?</tt>.
<tt>assq</tt> may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;assq<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(null?&nbsp;ls)&nbsp;#f]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(eq?&nbsp;(caar&nbsp;ls)&nbsp;x)&nbsp;(car&nbsp;ls)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else&nbsp;(assq&nbsp;x&nbsp;(cdr&nbsp;ls))])))</tt>
<p><tt>assv</tt> and <tt>assoc</tt> may be defined similarly, with <tt>eqv?</tt> and <tt>equal?</tt>
in place of <tt>eq?</tt>.

<p>

<p><tt>(assq&nbsp;'b&nbsp;'((a&nbsp;.&nbsp;1)&nbsp;(b&nbsp;.&nbsp;2)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;.&nbsp;2)<br>

(cdr&nbsp;(assq&nbsp;'b&nbsp;'((a&nbsp;.&nbsp;1)&nbsp;(b&nbsp;.&nbsp;2))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(assq&nbsp;'c&nbsp;'((a&nbsp;.&nbsp;1)&nbsp;(b&nbsp;.&nbsp;2)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(assv&nbsp;2/3&nbsp;'((1/3&nbsp;.&nbsp;1)&nbsp;(2/3&nbsp;.&nbsp;2)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2/3&nbsp;.&nbsp;2)<br>

(assv&nbsp;2/3&nbsp;'((1/3&nbsp;.&nbsp;a)&nbsp;(3/4&nbsp;.&nbsp;b)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(assoc&nbsp;'(a)&nbsp;'(((a)&nbsp;.&nbsp;a)&nbsp;(-1&nbsp;.&nbsp;b)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((a)&nbsp;.&nbsp;a)<br>

(assoc&nbsp;'(a)&nbsp;'(((b)&nbsp;.&nbsp;b)&nbsp;(a&nbsp;.&nbsp;c)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(let&nbsp;([alist&nbsp;(list&nbsp;(cons&nbsp;2&nbsp;'a)&nbsp;(cons&nbsp;3&nbsp;'b))])<br>

&nbsp;&nbsp;(set-cdr!&nbsp;(assv&nbsp;3&nbsp;alist)&nbsp;'c)<br>

&nbsp;&nbsp;alist)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;((2&nbsp;.&nbsp;a)&nbsp;(3&nbsp;.&nbsp;c))</tt>
<p>The interpreter given in Section&nbsp;<a href="examples.html#g187">12.7</a> represents
environments as association lists and uses <tt>assq</tt> for both
variable lookup and assignment.

<p>
<a name="./objects:s60"></a><span class=formdef><b>procedure</b>: <tt>(assp&nbsp;<i>procedure</i>&nbsp;<i>alist</i>)</tt></span>
<br>
<b>returns: </b>first element of <tt><i>alist</i></tt> for whose car <tt><i>procedure</i></tt> returns true, or <tt>#f</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;lists)</tt>, <tt>(rnrs)</tt>

<p><a name="./objects:s61"></a><tt><i>alist</i></tt> must be an <i>association list</i>.
An association list is a proper list whose elements are key-value pairs
of the form <tt>(key&nbsp;.&nbsp;value)</tt>.
<tt><i>procedure</i></tt> should accept one argument and return a single value.
It should not modify <tt><i>list</i></tt>.

<p>

<p><tt>(assp&nbsp;odd?&nbsp;'((1&nbsp;.&nbsp;a)&nbsp;(2&nbsp;.&nbsp;b)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;.&nbsp;a)<br>

(assp&nbsp;even?&nbsp;'((1&nbsp;.&nbsp;a)&nbsp;(2&nbsp;.&nbsp;b)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2&nbsp;.&nbsp;b)<br>

(let&nbsp;([ls&nbsp;(list&nbsp;(cons&nbsp;1&nbsp;'a)&nbsp;(cons&nbsp;2&nbsp;'b))])<br>

&nbsp;&nbsp;(eq?&nbsp;(assp&nbsp;odd?&nbsp;ls)&nbsp;(car&nbsp;ls)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([ls&nbsp;(list&nbsp;(cons&nbsp;1&nbsp;'a)&nbsp;(cons&nbsp;2&nbsp;'b))])<br>

&nbsp;&nbsp;(eq?&nbsp;(assp&nbsp;even?&nbsp;ls)&nbsp;(cadr&nbsp;ls)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(assp&nbsp;odd?&nbsp;'((2&nbsp;.&nbsp;b)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s62"></a><span class=formdef><b>procedure</b>: <tt>(list-sort&nbsp;<i>predicate</i>&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a list containing the elements of <tt><i>list</i></tt> sorted according to <tt><i>predicate</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;sorting)</tt>, <tt>(rnrs)</tt>

<p><tt><i>predicate</i></tt> should be a procedure that expects two arguments and
returns <tt>#t</tt> if its first argument must precede its second in
the sorted list.
That is, if <tt><i>predicate</i></tt> is applied to two elements <tt><i>x</i></tt> and
<tt><i>y</i></tt>, where <tt><i>x</i></tt> appears after <tt><i>y</i></tt> in the input list,
it should return true only if <tt><i>x</i></tt> should appear before <tt><i>y</i></tt>
in the output list.
If this constraint is met,
<tt>list-sort</tt> performs a stable sort, i.e., two elements are
reordered only when necessary according to <tt><i>predicate</i></tt>.
Duplicate elements are not removed.
This procedure may call predicate up to <i>n</i>log<i>n</i> times, where <i>n</i> is
the length of <tt><i>list</i></tt>.

<p>

<p><tt>(list-sort&nbsp;&lt;&nbsp;'(3&nbsp;4&nbsp;2&nbsp;1&nbsp;2&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;2&nbsp;3&nbsp;4&nbsp;5)<br>

(list-sort&nbsp;&gt;&nbsp;'(0.5&nbsp;1/2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(0.5&nbsp;1/2)<br>

(list-sort&nbsp;&gt;&nbsp;'(1/2&nbsp;0.5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1/2&nbsp;0.5)<br>

(list-&gt;string<br>

&nbsp;&nbsp;(list-sort&nbsp;char&gt;?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;list&nbsp;"hello")))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"ollhe"</tt>
<p>
<h3><a name="g110"></a><a name="./objects:h4"></a>Section 6.4. Numbers<a name="SECTNUMBERS"></a></h3>



<p>
<a name="./objects:s63"></a>Scheme numbers may be classified as
<a name="./objects:s64"></a>integers, <a name="./objects:s65"></a>rational numbers,
<a name="./objects:s66"></a>real numbers, or <a name="./objects:s67"></a>complex numbers.
This classification is hierarchical, in that all integers are
rational, all rational numbers are real, and all real numbers are
complex.
The predicates <a name="./objects:s68"></a><tt>integer?</tt>, <a name="./objects:s69"></a><tt>rational?</tt>, <a name="./objects:s70"></a><tt>real?</tt>, and
<a name="./objects:s71"></a><tt>complex?</tt> described in Section&nbsp;<a href="objects.html#g108">6.2</a> are used to
determine into which of these classes a number falls.

<p>
A Scheme number may also be classified as <a name="./objects:s72"></a><i>exact</i> or
<i>inexact</i>, depending upon the quality of operations used
to derive the number and the inputs to these operations.
The predicates <a name="./objects:s73"></a><tt>exact?</tt> and <a name="./objects:s74"></a><tt>inexact?</tt> may be used to
determine the exactness of a number.
Most operations on numbers in Scheme are <a name="./objects:s75"></a><i>exactness preserving</i>:  if given exact operands they return exact values,
and if given inexact operands or a combination of exact and inexact
operands they return inexact values.

<p>
Exact integer and rational arithmetic is typically supported to
<a name="./objects:s76"></a>arbitrary precision; the size of an integer or of the denominator
or numerator of a ratio is limited only by system storage constraints.
Although other representations are possible,
inexact numbers are typically represented by <a name="./objects:s77"></a><i>floating-point</i> numbers supported by the host computer's
hardware or by system software.
Complex numbers are typically represented as ordered pairs
(<tt><i>real-part</i></tt>, <tt><i>imag-part</i></tt>), where <tt><i>real-part</i></tt> and <tt><i>imag-part</i></tt>
are exact integers, exact rationals, or floating-point numbers.

<p>
Scheme numbers are written in a straightforward manner not much different from
ordinary conventions for writing numbers.
An exact integer is normally written as a sequence of numerals
preceded by an optional sign.
For example, <tt>3</tt>, <tt>+19</tt>, <tt>-100000</tt>, and
<tt>208423089237489374</tt> all represent exact integers.

<p>
An exact rational number is normally written as two sequences of numerals
separated by a slash (<tt>/</tt>) and preceded by an optional sign.
For example, <tt>3/4</tt>, <tt>-6/5</tt>, and <tt>1/1208203823</tt> are all exact
rational numbers.
A ratio is reduced immediately to lowest terms when it is read and may in fact
reduce to an exact integer.

<p>
Inexact real numbers are normally written in either
floating-point or scientific notation.
Floating-point notation consists of a sequence of
numerals followed by a decimal point and another sequence of
numerals, all preceded by an optional sign.
Scientific notation consists of an optional sign, a sequence of numerals,
an optional decimal point followed by a second string of numerals,
and an exponent; an exponent is written as the letter <tt>e</tt>
followed by an optional sign and a sequence of numerals.
For example, <tt>1.0</tt> and <tt>-200.0</tt> are valid inexact integers, and
<tt>1.5</tt>, <tt>0.034</tt>, <tt>-10e-10</tt> and <tt>1.5e-5</tt> are valid inexact rational
numbers.
The exponent is the power of ten by which the number preceding the
exponent should be scaled, so that <tt>2e3</tt> is equivalent to <tt>2000.0</tt>.

<p>
A mantissa width <tt>|<i>w</i></tt> may appear as the suffix of a real
number or the real components of a complex number written in floating-point
or scientific notation.
The mantissa width <tt><i>m</i></tt> represents the number of significant bits
in the representation of the number.
The mantissa width defaults to 53, the number of significant bits in
a normalized IEEE double floating-point number, or more.
For denormalized IEEE double floating-point numbers, the mantissa width is
less than 53.
If an implementation cannot represent a number with the mantissa width
specified, it uses a representation with at least as many significant
bits as requested if possible, otherwise it uses its representation with
the largest mantissa width.

<p>
Exact and inexact real numbers are written as exact or inexact
integers or rational numbers; no provision is made in the syntax
of Scheme numbers for nonrational real numbers, i.e., irrational
numbers.

<p>
Complex numbers may be written in either rectangular or polar form.
In rectangular form, a complex number is written as <tt><i>x</i>+<i>y</i>i</tt> or
<tt><i>x</i>-<i>y</i>i</tt>,
where <tt><i>x</i></tt> is an integer, rational, or real number
and <tt><i>y</i></tt> is an unsigned integer, rational, or real number.
The real part, <i>x</i>, may be omitted, in which case it is assumed to
be zero.
For example, <tt>3+4i</tt>, <tt>3.2-3/4i</tt>, <tt>+i</tt>, and
<tt>-3e-5i</tt> are complex numbers written in rectangular form.
In polar form, a complex number is written as <tt><i>x</i>@<i>y</i></tt>,
where <tt><i>x</i></tt>
and <tt><i>y</i></tt> are integer, rational, or real numbers.
For example, <tt>1.1@1.764</tt> and <tt>-1@-1/2</tt> are complex numbers written
in polar form.

<p>
The syntaxes <tt>+inf.0</tt> and <tt>-inf.0</tt> represent inexact real
numbers that represent positive and negative infinity.
The syntaxes <tt>+nan.0</tt> and <tt>-nan.0</tt> represent an inexact
"not-a-number" (NaN) value.
Infinities may be produced by dividing inexact positive and negative
values by inexact zero, and NaNs may also be produced by dividing inexact
zero by inexact zero, among other ways.

<p>
The exactness of a numeric representation may be overridden by
preceding the representation by either <tt>#e</tt> or <tt>#i</tt>.
<tt>#e</tt> forces the number to be exact, and <tt>#i</tt> forces it to be
inexact.
For example, <tt>1</tt>, <tt>#e1</tt>, 1/1, <tt>#e1/1</tt>,
<tt>#e1.0</tt>, and <tt>#e1e0</tt> all
represent the exact integer 1, and <tt>#i3/10</tt>,
<tt>0.3</tt>, <tt>#i0.3</tt>,
and <tt>3e-1</tt> all represent the inexact rational 0.3.

<p>
Numbers are written by default in base 10, although the special prefixes
<a name="./objects:s78"></a><tt>#b</tt> (binary), <a name="./objects:s79"></a><tt>#o</tt> (octal), <a name="./objects:s80"></a><tt>#d</tt> (decimal), and
<a name="./objects:s81"></a><tt>#x</tt> (hexadecimal) can be used to specify base 2, base 8, base 10,
or base 16.
For radix 16, the letters <tt>a</tt> through <tt>f</tt>
or <tt>A</tt> through <tt>F</tt> serve as the additional numerals required to
express digit values 10 through 15.
For example, <tt>#b10101</tt> is the binary equivalent of
21<sub>10</sub>, <tt>#o72</tt> is the octal equivalent of 58<sub>10</sub>, and <tt>#xC7</tt>
is the hexadecimal equivalent of 199<sub>10</sub>.
Numbers written in floating-point and scientific notations are
always written in base 10.

<p>
If both are present, radix and exactness prefixes may appear in
either order.

<p>
A Scheme implementation may support more than one size of internal
representation for inexact quantities.
The exponent markers
<a name="./objects:s82"></a><tt>s</tt> (<i>short</i>),
<a name="./objects:s83"></a><tt>f</tt> (<i>single</i>),
<a name="./objects:s84"></a><tt>d</tt> (<i>double</i>),
and
<a name="./objects:s85"></a><tt>l</tt> (<i>long</i>)
may appear in place of the default exponent marker
<tt>e</tt> to override the default size for numbers written in scientific
notation.
In implementations that support multiple representations, the
default size has at least as much precision as <i>double</i>.

<p>
A precise grammar for Scheme numbers is given 
on page&nbsp;<a href="grammar.html#grammar:numbers">459</a>.

<p>
Any number can be written in a variety of different ways, but the
system printer (invoked by <tt>put-datum</tt>, <tt>write</tt>, and <tt>display</tt>) and
<tt>number-&gt;string</tt> express numbers in a compact form,
using the fewest number of digits necessary to retain
the property that, when read, the printed number is identical
to the original number.


<p>
The remainder of this section describes "generic arithmetic" procedures
that operate on numbers.
The two sections that follow this section describe operations specific to
<i>fixnums</i> and <i>flonums</i>, which are representations of exact,
fixed-precision integer values and inexact real values.

<p>
The types of numeric arguments accepted by the procedures in this section
are implied by the names given to the arguments: <tt><i>num</i></tt> for complex
numbers (that is, all numbers), <tt><i>real</i></tt> for real numbers, <tt><i>rat</i></tt>
for rational numbers, and <tt><i>int</i></tt> for integers.
If a <tt><i>real</i></tt>, <tt><i>rat</i></tt>, or <tt><i>int</i></tt> is required, the argument must be
considered real, rational, or integral by <tt>real?</tt>,
<tt>rational?</tt>, or <tt>integer?</tt>, i.e., the imaginary part of the
number must be exactly zero.
Where exact integers are required, the name <tt><i>exint</i></tt> is used.
In each case, a suffix may appear on the name, e.g., <tt><i>int<sub>2</sub></i></tt>.



<p>
<a name="./objects:s86"></a><span class=formdef><b>procedure</b>: <tt>(exact?&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>num</i></tt> is exact, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(exact?&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(exact?&nbsp;-15/16)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(exact?&nbsp;2.01)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(exact?&nbsp;#i77)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(exact?&nbsp;#i2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(exact?&nbsp;1.0-2i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s87"></a><span class=formdef><b>procedure</b>: <tt>(inexact?&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>num</i></tt> is inexact, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(inexact?&nbsp;-123)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(inexact?&nbsp;#i123)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(inexact?&nbsp;1e23)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(inexact?&nbsp;+i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s88"></a><span class=formdef><b>procedure</b>: <tt>(=&nbsp;<i>num<sub>1</sub></i>&nbsp;<i>num<sub>2</sub></i>&nbsp;<i>num<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(&lt;&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>&nbsp;<i>real<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(&gt;&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>&nbsp;<i>real<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(&lt;=&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>&nbsp;<i>real<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(&gt;=&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>&nbsp;<i>real<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The predicate <tt>=</tt> returns <tt>#t</tt> if its arguments are equal.
The predicate <tt>&lt;</tt> returns <tt>#t</tt> if its arguments are monotonically
increasing, i.e., each argument is greater than the preceding ones,
while <tt>&gt;</tt> returns <tt>#t</tt> if its arguments are monotonically decreasing.
The predicate <tt>&lt;=</tt> returns <tt>#t</tt> if its arguments are monotonically
nondecreasing, i.e., each argument is not less than the preceding ones,
while <tt>&gt;=</tt> returns <tt>#t</tt> if its arguments are monotonically nonincreasing.

<p>
As implied by the names of the arguments, <tt>=</tt> is defined for complex
arguments while the other relational predicates are defined only for real
arguments.
Two complex numbers are considered equal if their real and imaginary parts
are equal.
Comparisons involving NaNs always return <tt>#f</tt>.

<p>

<p><tt>(=&nbsp;7&nbsp;7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(=&nbsp;7&nbsp;9)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(&lt;&nbsp;2e3&nbsp;3e2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(&lt;=&nbsp;1&nbsp;2&nbsp;3&nbsp;3&nbsp;4&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(&lt;=&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(&gt;&nbsp;1&nbsp;2&nbsp;2&nbsp;3&nbsp;3&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(&gt;=&nbsp;1&nbsp;2&nbsp;2&nbsp;3&nbsp;3&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(=&nbsp;-1/2&nbsp;-0.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(=&nbsp;2/3&nbsp;.667)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(=&nbsp;7.2+0i&nbsp;7.2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(=&nbsp;7.2-3i&nbsp;7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(&lt;&nbsp;1/2&nbsp;2/3&nbsp;3/4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(&gt;&nbsp;8&nbsp;4.102&nbsp;2/3&nbsp;-5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(let&nbsp;([x&nbsp;0.218723452])<br>

&nbsp;&nbsp;(&lt;&nbsp;0.210&nbsp;x&nbsp;0.220))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(let&nbsp;([i&nbsp;1]&nbsp;[v&nbsp;(vector&nbsp;'a&nbsp;'b&nbsp;'c)])<br>

&nbsp;&nbsp;(&lt;&nbsp;-1&nbsp;i&nbsp;(vector-length&nbsp;v)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(apply&nbsp;&lt;&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(apply&nbsp;&gt;&nbsp;'(4&nbsp;3&nbsp;3&nbsp;2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(=&nbsp;+nan.0&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(&lt;&nbsp;+nan.0&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(&gt;&nbsp;+nan.0&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(&gt;=&nbsp;+inf.0&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(&gt;=&nbsp;+nan.0&nbsp;-inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(&gt;&nbsp;+nan.0&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s89"></a><span class=formdef><b>procedure</b>: <tt>(+&nbsp;<i>num</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the sum of the arguments <tt><i>num</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>When called with no arguments, <tt>+</tt> returns 0.

<p>

<p><tt>(+)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(+&nbsp;1&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(+&nbsp;1/2&nbsp;2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;7/6<br>

(+&nbsp;3&nbsp;4&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;12<br>

(+&nbsp;3.0&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;7.0<br>

(+&nbsp;3+4i&nbsp;4+3i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;7+7i<br>

(apply&nbsp;+&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;15</tt>
<p><a name="./objects:s90"></a><span class=formdef><b>procedure</b>: <tt>(-&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>the additive inverse of <tt><i>num</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(-&nbsp;<i>num<sub>1</sub></i>&nbsp;<i>num<sub>2</sub></i>&nbsp;<i>num<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the difference between <tt><i>num<sub>1</sub></i></tt> and the sum of <tt><i>num<sub>2</sub></i>&nbsp;<i>num<sub>3</sub></i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>(-&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-3<br>

(-&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2/3<br>

(-&nbsp;4&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(-&nbsp;3.25+4.25i&nbsp;1/4+1/4i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.0+4.0i<br>

(-&nbsp;4&nbsp;3&nbsp;2&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-2</tt>
<p><a name="./objects:s91"></a><span class=formdef><b>procedure</b>: <tt>(*&nbsp;<i>num</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the product of the arguments <tt><i>num</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>When called with no arguments, <tt>*</tt> returns 1.

<p>

<p><tt>(*)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(*&nbsp;3.4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.4<br>

(*&nbsp;1&nbsp;1/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/2<br>

(*&nbsp;3&nbsp;4&nbsp;5.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;66.0<br>

(*&nbsp;1+2i&nbsp;3+4i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-5+10i<br>

(apply&nbsp;*&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;120</tt>
<p><a name="./objects:s92"></a><span class=formdef><b>procedure</b>: <tt>(/&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>the multiplicative inverse of <tt><i>num</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(/&nbsp;<i>num<sub>1</sub></i>&nbsp;<i>num<sub>2</sub></i>&nbsp;<i>num<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the result of dividing <tt><i>num<sub>1</sub></i></tt> by the product of <tt><i>num<sub>2</sub></i>&nbsp;<i>num<sub>3</sub></i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(/&nbsp;-17)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1/17<br>

(/&nbsp;1/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(/&nbsp;.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0<br>

(/&nbsp;3&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3/4<br>

(/&nbsp;3.0&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;.75<br>

(/&nbsp;-5+10i&nbsp;3+4i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1+2i<br>

(/&nbsp;60&nbsp;5&nbsp;4&nbsp;3&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/2</tt>
<p><a name="./objects:s93"></a><span class=formdef><b>procedure</b>: <tt>(zero?&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>num</i></tt> is zero, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>zero?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(=&nbsp;x&nbsp;0))</tt>.

<p>

<p><tt>(zero?&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(zero?&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(zero?&nbsp;(-&nbsp;3.0&nbsp;3.0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(zero?&nbsp;(+&nbsp;1/2&nbsp;1/2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(zero?&nbsp;0+0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(zero?&nbsp;0.0-0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s94"></a><span class=formdef><b>procedure</b>: <tt>(positive?&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>real</i></tt> is greater than zero, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>positive?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(&gt;&nbsp;x&nbsp;0))</tt>.

<p>

<p><tt>(positive?&nbsp;128)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(positive?&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(positive?&nbsp;1.8e-15)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(positive?&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(positive?&nbsp;.001-0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;not&nbsp;a&nbsp;real&nbsp;number</i></tt>
<p><a name="./objects:s95"></a><span class=formdef><b>procedure</b>: <tt>(negative?&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>real</i></tt> is less than zero, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>negative?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(&lt;&nbsp;x&nbsp;0))</tt>.

<p>

<p><tt>(negative?&nbsp;-65)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(negative?&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(negative?&nbsp;-0.0121)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(negative?&nbsp;15/16)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(negative?&nbsp;-7.0+0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;not&nbsp;a&nbsp;real&nbsp;number</i></tt>
<p><a name="./objects:s96"></a><span class=formdef><b>procedure</b>: <tt>(even?&nbsp;<i>int</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>int</i></tt> is even, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(odd?&nbsp;<i>int</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>int</i></tt> is odd, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(even?&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(even?&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(even?&nbsp;2.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(even?&nbsp;-120762398465)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(even?&nbsp;2.0+0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;not&nbsp;an&nbsp;integer</i>
<br>
<br>
(odd?&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(odd?&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(odd?&nbsp;2.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(odd?&nbsp;-120762398465)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(odd?&nbsp;2.0+0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;not&nbsp;an&nbsp;integer</i></tt>
<p><a name="./objects:s97"></a><span class=formdef><b>procedure</b>: <tt>(finite?&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>real</i></tt> is finite, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(infinite?&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>real</i></tt> is infinite, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(nan?&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>real</i></tt> is a NaN, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(finite?&nbsp;2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(infinite?&nbsp;2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(nan?&nbsp;2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(finite?&nbsp;3.1415)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(infinite?&nbsp;3.1415)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(nan?&nbsp;3.1415)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(finite?&nbsp;+inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(infinite?&nbsp;-inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(nan?&nbsp;-inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(finite?&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(infinite?&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(nan?&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s98"></a><span class=formdef><b>procedure</b>: <tt>(quotient&nbsp;<i>int<sub>1</sub></i>&nbsp;<i>int<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the integer quotient of <tt><i>int<sub>1</sub></i></tt> and <tt><i>int<sub>2</sub></i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(remainder&nbsp;<i>int<sub>1</sub></i>&nbsp;<i>int<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the integer remainder of <tt><i>int<sub>1</sub></i></tt> and <tt><i>int<sub>2</sub></i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(modulo&nbsp;<i>int<sub>1</sub></i>&nbsp;<i>int<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the integer modulus of <tt><i>int<sub>1</sub></i></tt> and <tt><i>int<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;r5rs)</tt>

<p>The result of <tt>remainder</tt> has the same sign as <tt><i>int<sub>1</sub></i></tt>,
while the result of <tt>modulo</tt> has the same sign as <tt><i>int<sub>2</sub></i></tt>.

<p>

<p><tt>(quotient&nbsp;45&nbsp;6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;7<br>

(quotient&nbsp;6.0&nbsp;2.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.0<br>

(quotient&nbsp;3.0&nbsp;-2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1.0
<br>
<br>
(remainder&nbsp;16&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(remainder&nbsp;5&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(remainder&nbsp;-45.0&nbsp;7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-3.0<br>

(remainder&nbsp;10.0&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(remainder&nbsp;-17&nbsp;-9)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-8
<br>
<br>
(modulo&nbsp;16&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(modulo&nbsp;5&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(modulo&nbsp;-45.0&nbsp;7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4.0<br>

(modulo&nbsp;10.0&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-2.0<br>

(modulo&nbsp;-17&nbsp;-9)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-8</tt>
<p><a name="./objects:s99"></a><span class=formdef><b>procedure</b>: <tt>(div&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(mod&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(div-and-mod&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>x<sub>1</sub></i></tt> and <tt><i>x<sub>2</sub></i></tt> are exact, <tt><i>x<sub>2</sub></i></tt> must not be zero.
These procedures implement number-theoretic integer division, with the
<tt>div</tt> operation being related to <tt>quotient</tt> and the
<tt>mod</tt> operation being related to <tt>remainder</tt> or
<tt>modulo</tt>, but in both cases extended to handle real numbers.

<p>
The value <tt><i>n<sub>d</sub></i></tt> of <tt>(div&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)</tt> is an integer,
and the value <tt><i>x<sub>m</sub></i></tt> of <tt>(mod&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)</tt> is a real
number such that <i>x</i><sub>1</sub> = <i>n</i><sub>d</sub> &middot; <i>x</i><sub>2</sub> + <i>x</i><sub>m</sub> and
0 &le; <i>x</i><sub>m</sub> &lt; |<i>x</i><sub>2</sub>|.
In situations where the implementation cannot represent the mathematical
results prescribed by these equations as a number object, <tt>div</tt> and
<tt>mod</tt> return an unspecified number or raise an exception with
condition type <tt>&amp;implementation-restriction</tt>.

<p>
The <tt>div-and-mod</tt> procedure behaves as if defined as follows.

<p>

<p><tt>(define&nbsp;(div-and-mod&nbsp;x1&nbsp;x2)&nbsp;(values&nbsp;(div&nbsp;x1&nbsp;x2)&nbsp;(mod&nbsp;x1&nbsp;x2)))</tt>
<p>That is, unless it raises an exception in the circumstance described
above, it returns two values: the result of calling <tt>div</tt> on the
two arguments and the result of calling <tt>mod</tt> on the two
arguments.

<p>

<p><tt>(div&nbsp;17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5<br>

(mod&nbsp;17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(div&nbsp;-17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-6<br>

(mod&nbsp;-17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(div&nbsp;17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-5<br>

(mod&nbsp;17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(div&nbsp;-17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6<br>

(mod&nbsp;-17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1
<br>
<br>
(div-and-mod&nbsp;17.5&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5.0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;2.5</tt>
<p><a name="./objects:s100"></a><span class=formdef><b>procedure</b>: <tt>(div0&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(mod0&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(div0-and-mod0&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>x<sub>1</sub></i></tt> and <tt><i>x<sub>2</sub></i></tt> are exact, <tt><i>x<sub>2</sub></i></tt> must not be zero.
These procedures are similar to <tt>div</tt>, <tt>mod</tt>, and
<tt>div-and-mod</tt>, but constrain the "mod" value differently,
which also affects the "div" value.
The value <tt><i>n<sub>d</sub></i></tt> of <tt>(div0&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)</tt> is an integer,
and the value <tt><i>x<sub>m</sub></i></tt> of <tt>(mod0&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)</tt> is a real
number such that <i>x</i><sub>1</sub> = <i>n</i><sub>d</sub> &middot; <i>x</i><sub>2</sub> + <i>x</i><sub>m</sub> and
-|<i>x</i><sub>2</sub>/2| &le; <i>x</i><sub>m</sub> &lt; |<i>x</i><sub>2</sub>/2|.
In situations where the implementation cannot represent the mathematical
results prescribed by these equations as a number object, <tt>div0</tt> and
<tt>mod0</tt> return an unspecified number or raise an exception with
condition type <tt>&amp;implementation-restriction</tt>.

<p>
The <tt>div0-and-mod0</tt> procedure behaves as if defined as follows.

<p>

<p><tt>(define&nbsp;(div0-and-mod0&nbsp;x1&nbsp;x2)&nbsp;(values&nbsp;(div0&nbsp;x1&nbsp;x2)&nbsp;(mod0&nbsp;x1&nbsp;x2)))</tt>
<p>That is, unless it raises an exception in the circumstance described
above, it returns two values: the result of calling <tt>div0</tt> on the
two arguments and the result of calling <tt>mod0</tt> on the two
arguments.

<p>

<p><tt>(div0&nbsp;17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6<br>

(mod0&nbsp;17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(div0&nbsp;-17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-6<br>

(mod0&nbsp;-17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(div0&nbsp;17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-6<br>

(mod0&nbsp;17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(div0&nbsp;-17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6<br>

(mod0&nbsp;-17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1
<br>
<br>
(div0-and-mod0&nbsp;17.5&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6.0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;-0.5</tt>
<p><a name="./objects:s101"></a><span class=formdef><b>procedure</b>: <tt>(truncate&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b>the integer closest to <tt><i>real</i></tt> toward zero
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>real</i></tt> is an infinity or NaN, <tt>truncate</tt> returns <tt><i>real</i></tt>.

<p>

<p><tt>(truncate&nbsp;19)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;19<br>

(truncate&nbsp;2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(truncate&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(truncate&nbsp;17.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;17.0<br>

(truncate&nbsp;-17/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-8</tt>
<p><a name="./objects:s102"></a><span class=formdef><b>procedure</b>: <tt>(floor&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b>the integer closest to <tt><i>real</i></tt> toward <img src="math/tspl/11.gif" alt="<graphic>">
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>real</i></tt> is an infinity or NaN, <tt>floor</tt> returns <tt><i>real</i></tt>.

<p>

<p><tt>(floor&nbsp;19)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;19<br>

(floor&nbsp;2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(floor&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(floor&nbsp;17.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;17.0<br>

(floor&nbsp;-17/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-9</tt>
<p><a name="./objects:s103"></a><span class=formdef><b>procedure</b>: <tt>(ceiling&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b>the integer closest to <tt><i>real</i></tt> toward <img src="math/tspl/12.gif" alt="<graphic>">
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>real</i></tt> is an infinity or NaN, <tt>ceiling</tt> returns <tt><i>real</i></tt>.

<p>

<p><tt>(ceiling&nbsp;19)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;19<br>

(ceiling&nbsp;2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(ceiling&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(ceiling&nbsp;17.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;18.0<br>

(ceiling&nbsp;-17/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-8</tt>
<p><a name="./objects:s104"></a><span class=formdef><b>procedure</b>: <tt>(round&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b>the integer closest to <tt><i>real</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>real</i></tt> is exactly between two integers, the closest even integer
is returned.
If <tt><i>real</i></tt> is an infinity or NaN, <tt>round</tt> returns <tt><i>real</i></tt>.

<p>

<p><tt>(round&nbsp;19)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;19<br>

(round&nbsp;2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(round&nbsp;-2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(round&nbsp;17.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;17.0<br>

(round&nbsp;-17/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-8<br>

(round&nbsp;2.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0<br>

(round&nbsp;3.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4.0</tt>
<p><a name="./objects:s105"></a><a name="page:abs"></a>
<span class=formdef><b>procedure</b>: <tt>(abs&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b>the absolute value of <tt><i>real</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>abs</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(if&nbsp;(&lt;&nbsp;x&nbsp;0)&nbsp;(-&nbsp;x)&nbsp;x))</tt>.
<tt>abs</tt> and <a name="./objects:s106"></a><tt>magnitude</tt>
(see page&nbsp;<a href="objects.html#page:magnitude">183</a>) are identical for real inputs.

<p>

<p><tt>(abs&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(abs&nbsp;-3/4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3/4<br>

(abs&nbsp;1.83)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.83<br>

(abs&nbsp;-0.093)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.093</tt>
<p><a name="./objects:s107"></a><span class=formdef><b>procedure</b>: <tt>(max&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the maximum of <tt><i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(max&nbsp;4&nbsp;-7&nbsp;2&nbsp;0&nbsp;-6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4<br>

(max&nbsp;1/2&nbsp;3/4&nbsp;4/5&nbsp;5/6&nbsp;6/7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6/7<br>

(max&nbsp;1.5&nbsp;1.3&nbsp;-0.3&nbsp;0.4&nbsp;2.0&nbsp;1.8)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0<br>

(max&nbsp;5&nbsp;2.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5.0<br>

(max&nbsp;-5&nbsp;-2.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-2.0<br>

(let&nbsp;([ls&nbsp;'(7&nbsp;3&nbsp;5&nbsp;2&nbsp;9&nbsp;8)])<br>

&nbsp;&nbsp;(apply&nbsp;max&nbsp;ls))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;9</tt>
<p><a name="./objects:s108"></a><span class=formdef><b>procedure</b>: <tt>(min&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the minimum of <tt><i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(min&nbsp;4&nbsp;-7&nbsp;2&nbsp;0&nbsp;-6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-7<br>

(min&nbsp;1/2&nbsp;3/4&nbsp;4/5&nbsp;5/6&nbsp;6/7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/2<br>

(min&nbsp;1.5&nbsp;1.3&nbsp;-0.3&nbsp;0.4&nbsp;2.0&nbsp;1.8)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-0.3<br>

(min&nbsp;5&nbsp;2.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0<br>

(min&nbsp;-5&nbsp;-2.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-5.0<br>

(let&nbsp;([ls&nbsp;'(7&nbsp;3&nbsp;5&nbsp;2&nbsp;9&nbsp;8)])<br>

&nbsp;&nbsp;(apply&nbsp;min&nbsp;ls))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2</tt>
<p><a name="./objects:s109"></a><a name="page:gcd"></a>
<span class=formdef><b>procedure</b>: <tt>(gcd&nbsp;<i>int</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the greatest common divisor of its arguments <tt><i>int</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The result is always nonnegative, i.e., factors of -1 are ignored.
When called with no arguments, <tt>gcd</tt> returns 0.

<p>

<p><tt>(gcd)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(gcd&nbsp;34)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;34<br>

(gcd&nbsp;33.0&nbsp;15.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.0<br>

(gcd&nbsp;70&nbsp;-42&nbsp;28)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;14</tt>
<p><a name="./objects:s110"></a><span class=formdef><b>procedure</b>: <tt>(lcm&nbsp;<i>int</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the least common multiple of its arguments <tt><i>int</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The result is always nonnegative, i.e., common multiples of -1 are
ignored.
Although <tt>lcm</tt> should probably return <img src="math/tspl/13.gif" alt="<graphic>"> when called with no
arguments, it is defined to return 1.
If one or more of the arguments is 0, <tt>lcm</tt> returns 0.

<p>

<p><tt>(lcm)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(lcm&nbsp;34)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;34<br>

(lcm&nbsp;33.0&nbsp;15.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;165.0<br>

(lcm&nbsp;70&nbsp;-42&nbsp;28)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;420<br>

(lcm&nbsp;17.0&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0</tt>
<p><a name="./objects:s111"></a><span class=formdef><b>procedure</b>: <tt>(expt&nbsp;<i>num<sub>1</sub></i>&nbsp;<i>num<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt><i>num<sub>1</sub></i></tt> raised to the <tt><i>num<sub>2</sub></i></tt> power
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If both arguments are 0, <tt>expt</tt> returns 1.

<p>

<p><tt>(expt&nbsp;2&nbsp;10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1024<br>

(expt&nbsp;2&nbsp;-10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/1024<br>

(expt&nbsp;2&nbsp;-10.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;9.765625e-4<br>

(expt&nbsp;-1/2&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1/32<br>

(expt&nbsp;3.0&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;27.0<br>

(expt&nbsp;+i&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1</tt>
<p><a name="./objects:s112"></a><span class=formdef><b>procedure</b>: <tt>(inexact&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>an inexact representation of <tt><i>num</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><a name="./objects:s113"></a>If <tt><i>num</i></tt> is already inexact, it is returned unchanged.
If no inexact representation for <tt><i>num</i></tt> is supported by the
implementation, an exception with condition type <tt>&amp;implementation-violation</tt>
may be raised.
<tt>inexact</tt> may also return <tt>+inf.0</tt> or <tt>-inf.0</tt> for inputs
whose magnitude exceeds the range of the implementation's inexact number
representations.

<p>

<p><tt>(inexact&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.0<br>

(inexact&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.0<br>

(inexact&nbsp;-1/4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-.25<br>

(inexact&nbsp;3+4i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.0+4.0i<br>

(inexact&nbsp;(expt&nbsp;10&nbsp;20))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1e20</tt>
<p><a name="./objects:s114"></a><span class=formdef><b>procedure</b>: <tt>(exact&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>an exact representation of <tt><i>num</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><a name="./objects:s115"></a>If <tt><i>num</i></tt> is already exact, it is returned unchanged.
If no exact representation for <tt><i>num</i></tt> is supported by the
implementation, an exception with condition type <tt>&amp;implementation-violation</tt>
may be raised.

<p>

<p><tt>(exact&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(exact&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(exact&nbsp;-.25)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1/4<br>

(exact&nbsp;3.0+4.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3+4i<br>

(exact&nbsp;1e20)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;100000000000000000000</tt>
<p><a name="./objects:s116"></a><span class=formdef><b>procedure</b>: <tt>(exact-&gt;inexact&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>an inexact representation of <tt><i>num</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(inexact-&gt;exact&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>an exact representation of <tt><i>num</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;r5rs)</tt>

<p>These are alternative names for <tt>inexact</tt> and <tt>exact</tt>,
supported for compatibility with the Revised<sup>5</sup> Report.


<p>
<a name="./objects:s117"></a><span class=formdef><b>procedure</b>: <tt>(rationalize&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>rationalize</tt>
returns the simplest rational number that differs from
<tt><i>real<sub>1</sub></i></tt> by no more than <tt><i>real<sub>2</sub></i></tt>.
A rational number <i>q</i><sub>1</sub> = <i>n</i><sub>1</sub>/<i>m</i><sub>1</sub> is simpler than another rational
number <i>q</i><sub>2</sub> = <i>n</i><sub>2</sub>/<i>m</i><sub>2</sub> if |<i>n</i><sub>1</sub>| &le; |<i>n</i><sub>2</sub>| and |<i>m</i><sub>1</sub>| &le; |<i>m</i><sub>2</sub>|
and either |<i>n</i><sub>1</sub>| &lt; |<i>n</i><sub>2</sub>| or |<i>m</i><sub>1</sub>| &lt; |<i>m</i><sub>2</sub>|.

<p>

<p><tt>(rationalize&nbsp;3/10&nbsp;1/10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/3<br>

(rationalize&nbsp;.3&nbsp;1/10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.3333333333333333<br>

(eqv?&nbsp;(rationalize&nbsp;.3&nbsp;1/10)&nbsp;#i1/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s118"></a><span class=formdef><b>procedure</b>: <tt>(numerator&nbsp;<i>rat</i>)</tt></span>
<br>
<b>returns: </b>the numerator of <tt><i>rat</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>rat</i></tt> is an integer, the numerator is <tt><i>rat</i></tt>.

<p>

<p><tt>(numerator&nbsp;9)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;9<br>

(numerator&nbsp;9.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;9.0<br>

(numerator&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0<br>

(numerator&nbsp;2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(numerator&nbsp;-9/4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-9<br>

(numerator&nbsp;-2.25)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-9.0</tt>
<p><a name="./objects:s119"></a><span class=formdef><b>procedure</b>: <tt>(denominator&nbsp;<i>rat</i>)</tt></span>
<br>
<b>returns: </b>the denominator of <tt><i>rat</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>rat</i></tt> is an integer, including zero, the denominator is one.

<p>

<p><tt>(denominator&nbsp;9)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(denominator&nbsp;9.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(denominator&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(denominator&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(denominator&nbsp;2/3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(denominator&nbsp;-9/4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4<br>

(denominator&nbsp;-2.25)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4.0</tt>
<p><a name="./objects:s120"></a><span class=formdef><b>procedure</b>: <tt>(real-part&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>the real component of <tt><i>num</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>num</i></tt> is real, <tt>real-part</tt> returns <tt><i>num</i></tt>.

<p>

<p><tt>(real-part&nbsp;3+4i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(real-part&nbsp;-2.3+0.7i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-2.3<br>

(real-part&nbsp;-i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(real-part&nbsp;17.2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;17.2<br>

(real-part&nbsp;-17/100)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-17/100</tt>
<p><a name="./objects:s121"></a><span class=formdef><b>procedure</b>: <tt>(imag-part&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>the imaginary component of <tt><i>num</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>num</i></tt> is real, <tt>imag-part</tt> returns exact zero.


<p>

<p><tt>(imag-part&nbsp;3+4i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4<br>

(imag-part&nbsp;-2.3+0.7i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.7<br>

(imag-part&nbsp;-i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(imag-part&nbsp;-2.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(imag-part&nbsp;-17/100)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0</tt>
<p><a name="./objects:s122"></a><span class=formdef><b>procedure</b>: <tt>(make-rectangular&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>a complex number with real component <tt><i>real<sub>1</sub></i></tt> and imaginary
  component <tt><i>real<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(make-rectangular&nbsp;-2&nbsp;7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-2+7i<br>

(make-rectangular&nbsp;2/3&nbsp;-1/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2/3-1/2i<br>

(make-rectangular&nbsp;3.2&nbsp;5.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.2+5.3i</tt>
<p><a name="./objects:s123"></a><span class=formdef><b>procedure</b>: <tt>(make-polar&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>a complex number with magnitude <tt><i>real<sub>1</sub></i></tt> and angle
    <tt><i>real<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(make-polar&nbsp;2&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(make-polar&nbsp;2.0&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0+0.0i<br>

(make-polar&nbsp;1.0&nbsp;(asin&nbsp;-1.0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0-1.0i<br>

(eqv?&nbsp;(make-polar&nbsp;7.2&nbsp;-0.588)&nbsp;7.2@-0.588)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s124"></a><span class=formdef><b>procedure</b>: <tt>(angle&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>the angle part of the polar representation of <tt><i>num</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The range of the result is <img src="math/tspl/14.gif" alt="<graphic>"> (exclusive) to <img src="math/tspl/15.gif" alt="<graphic>"> (inclusive).

<p>

<p><tt>(angle&nbsp;7.3@1.5708)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.5708<br>

(angle&nbsp;5.2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0</tt>
<p><a name="./objects:s125"></a><a name="page:magnitude"></a>
<span class=formdef><b>procedure</b>: <tt>(magnitude&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>the magnitude of <tt><i>num</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>magnitude</tt> and <a name="./objects:s126"></a><tt>abs</tt>
(see page&nbsp;<a href="objects.html#page:abs">178</a>) are identical for real arguments.
The magnitude of a complex number <i>x</i> + <i>yi</i> is
<img src="math/tspl/16.gif" alt="<graphic>">.

<p>

<p><tt>(magnitude&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(magnitude&nbsp;-3/4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3/4<br>

(magnitude&nbsp;1.83)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.83<br>

(magnitude&nbsp;-0.093)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.093<br>

(magnitude&nbsp;3+4i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5<br>

(magnitude&nbsp;7.25@1.5708)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;7.25</tt>
<p><a name="./objects:s127"></a><span class=formdef><b>procedure</b>: <tt>(sqrt&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>the principal square root of <tt><i>num</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>Implementations are encouraged, but not required, to return exact
results for exact inputs to <tt>sqrt</tt> whenever feasible.

<p>

<p><tt>(sqrt&nbsp;16)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4<br>

(sqrt&nbsp;1/4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1/2<br>

(sqrt&nbsp;4.84)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.2<br>

(sqrt&nbsp;-4.84)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0+2.2i<br>

(sqrt&nbsp;3+4i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2+1i<br>

(sqrt&nbsp;-3.0-4.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0-2.0i</tt>
<p><a name="./objects:s128"></a><span class=formdef><b>procedure</b>: <tt>(exact-integer-sqrt&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>This procedure returns two nonnegative exact integers <i>s</i> and <i>r</i> where
<i>n</i> = <i>s</i><sup>2</sup> + <i>r</i> and <i>n</i> &lt; (<i>s</i> + 1)<sup>2</sup>.

<p>

<p><tt>(exact-integer-sqrt&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;0<br>

(exact-integer-sqrt&nbsp;9)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(exact-integer-sqrt&nbsp;19)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3</tt>
<p><a name="./objects:s129"></a><span class=formdef><b>procedure</b>: <tt>(exp&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b><i>e</i> to the <tt><i>num</i></tt> power
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(exp&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(exp&nbsp;1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.7182818284590455<br>

(exp&nbsp;-.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.6065306597126334</tt>
<p><a name="./objects:s130"></a><span class=formdef><b>procedure</b>: <tt>(log&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>the natural logarithm of <tt><i>num</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(log&nbsp;<i>num<sub>1</sub></i>&nbsp;<i>num<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the base-<tt><i>num<sub>2</sub></i></tt> logarithm of <tt><i>num<sub>1</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(log&nbsp;1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0<br>

(log&nbsp;(exp&nbsp;1.0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(/&nbsp;(log&nbsp;100)&nbsp;(log&nbsp;10))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0<br>

(log&nbsp;(make-polar&nbsp;(exp&nbsp;2.0)&nbsp;1.0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0+1.0i
<br>
<br>
(log&nbsp;100.0&nbsp;10.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0<br>

(log&nbsp;.125&nbsp;2.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-3.0</tt>
<p><a name="./objects:s131"></a><span class=formdef><b>procedure</b>: <tt>(sin&nbsp;<i>num</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(cos&nbsp;<i>num</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(tan&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>the sine, cosine, or tangent of <tt><i>num</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The argument is specified in radians.

<p>

<p><tt>(sin&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0<br>

(cos&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(tan&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0</tt>
<p><a name="./objects:s132"></a><span class=formdef><b>procedure</b>: <tt>(asin&nbsp;<i>num</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(acos&nbsp;<i>num</i>)</tt></span>
<br>
<b>returns: </b>the arc sine or the arc cosine of <tt><i>num</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The result is in radians.
The arc sine and arc cosine of a complex number <i>z</i> are defined as follows.

<p>
<p>
<img src="math/tspl/17.gif" alt="<graphic>"><p>

<p>
<img src="math/tspl/18.gif" alt="<graphic>"><p>


<p>

<p><tt>(define&nbsp;pi&nbsp;(*&nbsp;(asin&nbsp;1)&nbsp;2))<br>

(=&nbsp;(*&nbsp;(acos&nbsp;0)&nbsp;2)&nbsp;pi)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s133"></a><span class=formdef><b>procedure</b>: <tt>(atan&nbsp;<i>num</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(atan&nbsp;<i>real<sub>1</sub></i>&nbsp;<i>real<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>When passed a single complex argument <tt><i>num</i></tt> (the first form), <tt>atan</tt>
returns the arc tangent of <tt><i>num</i></tt>.
The arc tangent of a complex number <i>z</i> is defined as follows.

<p>
<p>
<img src="math/tspl/19.gif" alt="<graphic>"><p>


<p>
When passed two real arguments (the second form), <tt>atan</tt> is equivalent
to <tt>(lambda&nbsp;(y&nbsp;x)&nbsp;(angle&nbsp;(make-rectangular&nbsp;x&nbsp;y)))</tt>.

<p>

<p><tt>(define&nbsp;pi&nbsp;(*&nbsp;(atan&nbsp;1)&nbsp;4))<br>

(=&nbsp;(*&nbsp;(atan&nbsp;1.0&nbsp;0.0)&nbsp;2)&nbsp;pi)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s134"></a><span class=formdef><b>procedure</b>: <tt>(bitwise-not&nbsp;<i>exint</i>)</tt></span>
<br>
<b>returns: </b>the bitwise not of <tt><i>exint</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(bitwise-and&nbsp;<i>exint</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the bitwise and of <tt><i>exint</i>&nbsp;...</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(bitwise-ior&nbsp;<i>exint</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the bitwise inclusive or of <tt><i>exint</i>&nbsp;...</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(bitwise-xor&nbsp;<i>exint</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the bitwise exclusive or of <tt><i>exint</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;bitwise)</tt>, <tt>(rnrs)</tt>

<p>The inputs are treated as if represented in two's complement, even
if they are not represented that way internally.

<p>

<p><tt>(bitwise-not&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(bitwise-not&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-4
<br>
<br>
(bitwise-and&nbsp;#b01101&nbsp;#b00111)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00101<br>

(bitwise-ior&nbsp;#b01101&nbsp;#b00111)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01111<br>

(bitwise-xor&nbsp;#b01101&nbsp;#b00111)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01010</tt>
<p><a name="./objects:s135"></a><span class=formdef><b>procedure</b>: <tt>(bitwise-if&nbsp;<i>exint<sub>1</sub></i>&nbsp;<i>exint<sub>2</sub></i>&nbsp;<i>exint<sub>3</sub></i>)</tt></span>
<br>
<b>returns: </b>the bitwise "if" of its arguments
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;bitwise)</tt>, <tt>(rnrs)</tt>

<p>The inputs are treated as if represented in two's complement, even
if they are not represented that way internally.

<p>
For each bit set in <tt><i>exint<sub>1</sub></i></tt>, the corresponding bit of the result
is taken from <tt><i>exint<sub>2</sub></i></tt>, and for each bit not set in <tt><i>exint<sub>1</sub></i></tt>,
the corresponding bit of the result is taken from <tt><i>x<sub>3</sub></i></tt>.

<p>

<p><tt>(bitwise-if&nbsp;#b101010&nbsp;#b111000&nbsp;#b001100)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b101100</tt>
<p><tt>bitwise-if</tt> might be defined as follows:

<p>

<p><tt>(define&nbsp;bitwise-if<br>

&nbsp;&nbsp;(lambda&nbsp;(exint1&nbsp;exint2&nbsp;exint3)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(bitwise-ior<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bitwise-and&nbsp;exint1&nbsp;exint2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bitwise-and&nbsp;(bitwise-not&nbsp;exint1)&nbsp;exint3))))</tt>
<p><a name="./objects:s136"></a><span class=formdef><b>procedure</b>: <tt>(bitwise-bit-count&nbsp;<i>exint</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;bitwise)</tt>, <tt>(rnrs)</tt>

<p>For nonnegative inputs, <tt>bitwise-bit-count</tt> returns the number of bits
set in the two's complement representation of <tt><i>exint</i></tt>.
For negative inputs, it returns a negative number whose magnitude is one
greater than the number of bits not set in the two's complement
representation of <tt><i>exint</i></tt>, which is equivalent to
<tt>(bitwise-not&nbsp;(bitwise-bit-count&nbsp;(bitwise-not&nbsp;<i>exint</i>)))</tt>.

<p>

<p><tt>(bitwise-bit-count&nbsp;#b00000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(bitwise-bit-count&nbsp;#b00001)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(bitwise-bit-count&nbsp;#b00100)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(bitwise-bit-count&nbsp;#b10101)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3
<br>
<br>
(bitwise-bit-count&nbsp;-1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(bitwise-bit-count&nbsp;-2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-2<br>

(bitwise-bit-count&nbsp;-4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-3</tt>
<p><a name="./objects:s137"></a><span class=formdef><b>procedure</b>: <tt>(bitwise-length&nbsp;<i>exint</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;bitwise)</tt>, <tt>(rnrs)</tt>

<p>This procedure returns the number of bits of the smallest two's
complement representation of <tt><i>exint</i></tt>, not including the sign
bit for negative numbers.
For 0 <tt>bitwise-length</tt> returns 0.

<p>

<p><tt>(bitwise-length&nbsp;#b00000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(bitwise-length&nbsp;#b00001)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(bitwise-length&nbsp;#b00100)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(bitwise-length&nbsp;#b00110)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3
<br>
<br>
(bitwise-length&nbsp;-1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(bitwise-length&nbsp;-6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(bitwise-length&nbsp;-9)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><a name="./objects:s138"></a><span class=formdef><b>procedure</b>: <tt>(bitwise-first-bit-set&nbsp;<i>exint</i>)</tt></span>
<br>
<b>returns: </b>the index of the least significant bit set in <tt><i>exint</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;bitwise)</tt>, <tt>(rnrs)</tt>

<p>The input is treated as if represented in two's complement, even
if it is not represented that way internally.

<p>
If <tt><i>exint</i></tt> is 0, <tt>bitwise-first-bit-set</tt> returns -1.

<p>

<p><tt>(bitwise-first-bit-set&nbsp;#b00000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(bitwise-first-bit-set&nbsp;#b00001)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(bitwise-first-bit-set&nbsp;#b01100)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2
<br>
<br>
(bitwise-first-bit-set&nbsp;-1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(bitwise-first-bit-set&nbsp;-2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(bitwise-first-bit-set&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0</tt>
<p><a name="./objects:s139"></a><span class=formdef><b>procedure</b>: <tt>(bitwise-bit-set?&nbsp;<i>exint<sub>1</sub></i>&nbsp;<i>exint<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if bit <tt><i>exint<sub>2</sub></i></tt> of <tt><i>exint<sub>1</sub></i></tt> is set, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;bitwise)</tt>, <tt>(rnrs)</tt>

<p><tt><i>exint<sub>2</sub></i></tt> is taken as a zero-based index for the bits
in the two's complement representation of <tt><i>exint<sub>1</sub></i></tt>.
The two's complement representation of a nonnegative number conceptually extends
to the left (toward more significant bits) with an infinite number of zero bits, and
the two's complement representation of a negative number conceptually extends
to the left with an infinite number of one bits.
Thus, exact integers can be used to represent arbitrarily large sets, where 0 is the
empty set, -1 is the universe, and <tt>bitwise-bit-set?</tt> is used to test for
membership.

<p>

<p><tt>(bitwise-bit-set?&nbsp;#b01011&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(bitwise-bit-set?&nbsp;#b01011&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(bitwise-bit-set?&nbsp;-1&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(bitwise-bit-set?&nbsp;-1&nbsp;20)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(bitwise-bit-set?&nbsp;-3&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(bitwise-bit-set?&nbsp;0&nbsp;5000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(bitwise-bit-set?&nbsp;-1&nbsp;5000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s140"></a><span class=formdef><b>procedure</b>: <tt>(bitwise-copy-bit&nbsp;<i>exint<sub>1</sub></i>&nbsp;<i>exint<sub>2</sub></i>&nbsp;<i>exint<sub>3</sub></i>)</tt></span>
<br>
<b>returns: </b><tt><i>exint<sub>1</sub></i></tt> with bit <tt><i>exint<sub>2</sub></i></tt> replaced by <tt><i>exint<sub>3</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;bitwise)</tt>, <tt>(rnrs)</tt>

<p><tt><i>exint<sub>2</sub></i></tt> is taken as a zero-based index for the bits
in the two's complement representation of <tt><i>exint<sub>1</sub></i></tt>.
<tt><i>exint<sub>3</sub></i></tt> must be 0 or 1.
This procedure effectively clears or sets the specified bit depending
on the value of <tt><i>exint<sub>3</sub></i></tt>.
<tt><i>exint<sub>1</sub></i></tt> is treated as if represented in two's complement, even
if it is not represented that way internally.

<p>

<p><tt>(bitwise-copy-bit&nbsp;#b01110&nbsp;0&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01111<br>

(bitwise-copy-bit&nbsp;#b01110&nbsp;2&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01010</tt>
<p><a name="./objects:s141"></a><span class=formdef><b>procedure</b>: <tt>(bitwise-bit-field&nbsp;<i>exint<sub>1</sub></i>&nbsp;<i>exint<sub>2</sub></i>&nbsp;<i>exint<sub>3</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;bitwise)</tt>, <tt>(rnrs)</tt>

<p><tt><i>exint<sub>2</sub></i></tt> and <tt><i>exint<sub>3</sub></i></tt> must be nonnegative,
and <tt><i>exint<sub>2</sub></i></tt> must not be greater than <tt><i>exint<sub>3</sub></i></tt>.
This procedure returns the number represented by extracting from <tt><i>exint<sub>1</sub></i></tt>
the sequence of bits from <tt><i>exint<sub>2</sub></i></tt> (inclusive) to <tt><i>exint<sub>3</sub></i></tt> (exclusive).
<tt><i>exint<sub>1</sub></i></tt> is treated as if represented in two's complement, even
if it is not represented that way internally.

<p>

<p><tt>(bitwise-bit-field&nbsp;#b10110&nbsp;0&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00110<br>

(bitwise-bit-field&nbsp;#b10110&nbsp;1&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00011<br>

(bitwise-bit-field&nbsp;#b10110&nbsp;2&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00001<br>

(bitwise-bit-field&nbsp;#b10110&nbsp;3&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00000</tt>
<p><a name="./objects:s142"></a><span class=formdef><b>procedure</b>: <tt>(bitwise-copy-bit-field&nbsp;<i>exint<sub>1</sub></i>&nbsp;<i>exint<sub>2</sub></i>&nbsp;<i>exint<sub>3</sub></i>&nbsp;<i>exint<sub>4</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;bitwise)</tt>, <tt>(rnrs)</tt>

<p><tt><i>exint<sub>2</sub></i></tt> and <tt><i>exint<sub>3</sub></i></tt> must be nonnegative, and <tt><i>exint<sub>2</sub></i></tt>
must not be greater than <tt><i>exint<sub>3</sub></i></tt>.
This procedure returns <tt><i>exint<sub>1</sub></i></tt> with the <tt><i>n</i></tt> bits from <tt><i>exint<sub>2</sub></i></tt> (inclusive) to
<tt><i>exint<sub>3</sub></i></tt> (exclusive) replaced by the low-order <tt><i>n</i></tt> bits of <tt><i>exint<sub>4</sub></i></tt>.
<tt><i>exint<sub>1</sub></i></tt> and <tt><i>exint<sub>4</sub></i></tt> are treated as if represented in two's complement, even
if they are not represented that way internally.

<p>

<p><tt>(bitwise-copy-bit-field&nbsp;#b10000&nbsp;0&nbsp;3&nbsp;#b10101)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b10101<br>

(bitwise-copy-bit-field&nbsp;#b10000&nbsp;1&nbsp;3&nbsp;#b10101)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b10010<br>

(bitwise-copy-bit-field&nbsp;#b10000&nbsp;2&nbsp;3&nbsp;#b10101)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b10100<br>

(bitwise-copy-bit-field&nbsp;#b10000&nbsp;3&nbsp;3&nbsp;#b10101)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b10000</tt>
<p><a name="./objects:s143"></a><span class=formdef><b>procedure</b>: <tt>(bitwise-arithmetic-shift-right&nbsp;<i>exint<sub>1</sub></i>&nbsp;<i>exint<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt><i>exint<sub>1</sub></i></tt> arithmetically shifted right by <tt><i>exint<sub>2</sub></i></tt> bits
<br>
<span class=formdef><b>procedure</b>: <tt>(bitwise-arithmetic-shift-left&nbsp;<i>exint<sub>1</sub></i>&nbsp;<i>exint<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt><i>exint<sub>1</sub></i></tt> shifted left by <tt><i>exint<sub>2</sub></i></tt> bits
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;bitwise)</tt>, <tt>(rnrs)</tt>

<p><tt><i>exint<sub>2</sub></i></tt> must be nonnegative.
<tt><i>exint<sub>1</sub></i></tt> is treated as if represented in two's complement, even
if it is not represented that way internally.

<p>

<p><tt>(bitwise-arithmetic-shift-right&nbsp;#b10000&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00010<br>

(bitwise-arithmetic-shift-right&nbsp;-1&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(bitwise-arithmetic-shift-right&nbsp;-64&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-8
<br>
<br>
(bitwise-arithmetic-shift-left&nbsp;#b00010&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01000<br>

(bitwise-arithmetic-shift-left&nbsp;-1&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-4</tt>
<p><a name="./objects:s144"></a><span class=formdef><b>procedure</b>: <tt>(bitwise-arithmetic-shift&nbsp;<i>exint<sub>1</sub></i>&nbsp;<i>exint<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;bitwise)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>exint<sub>2</sub></i></tt> is negative, <tt>bitwise-arithmetic-shift</tt> returns the
result of arithmetically shifting <tt><i>exint<sub>1</sub></i></tt> right by <tt><i>exint<sub>2</sub></i></tt> bits.
Otherwise, <tt>bitwise-arithmetic-shift</tt> returns the
result of shifting <tt><i>exint<sub>1</sub></i></tt> left by <tt><i>exint<sub>2</sub></i></tt> bits.
<tt><i>exint<sub>1</sub></i></tt> is treated as if represented in two's complement, even
if it is not represented that way internally.

<p>

<p><tt>(bitwise-arithmetic-shift&nbsp;#b10000&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00010<br>

(bitwise-arithmetic-shift&nbsp;-1&nbsp;-1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(bitwise-arithmetic-shift&nbsp;-64&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-8<br>

(bitwise-arithmetic-shift&nbsp;#b00010&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01000<br>

(bitwise-arithmetic-shift&nbsp;-1&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-4</tt>
<p>Thus, <tt>bitwise-arithmetic-shift</tt> behaves as if defined as follows.

<p>

<p><tt>(define&nbsp;bitwise-arithmetic-shift<br>

&nbsp;&nbsp;(lambda&nbsp;(exint1&nbsp;exint2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;exint2&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bitwise-arithmetic-shift-right&nbsp;exint1&nbsp;(-&nbsp;exint2))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bitwise-arithmetic-shift-left&nbsp;exint1&nbsp;exint2))))</tt>
<p><a name="./objects:s145"></a><span class=formdef><b>procedure</b>: <tt>(bitwise-rotate-bit-field&nbsp;<i>exint<sub>1</sub></i>&nbsp;<i>exint<sub>2</sub></i>&nbsp;<i>exint<sub>3</sub></i>&nbsp;<i>exint<sub>4</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;bitwise)</tt>, <tt>(rnrs)</tt>

<p><tt><i>exint<sub>2</sub></i></tt>, <tt><i>exint<sub>3</sub></i></tt>, and <tt><i>exint<sub>4</sub></i></tt> must be nonnegative,
and <tt><i>exint<sub>2</sub></i></tt> must not be greater than <tt><i>exint<sub>3</sub></i></tt>.
This procedure returns the result of shifting the bits of
<tt><i>exint<sub>1</sub></i></tt> from bit <tt><i>exint<sub>2</sub></i></tt> (inclusive) through bit <tt><i>exint<sub>3</sub></i></tt> (exclusive)
left by <tt>(mod&nbsp;<i>exint<sub>4</sub></i>&nbsp;(-&nbsp;<i>exint<sub>3</sub></i>&nbsp;<i>exint<sub>2</sub></i>))</tt> bits,
with the bits shifted out of the range inserted
at the bottom end of the range.
<tt><i>exint<sub>1</sub></i></tt> is treated as if represented in two's complement, even
if it is not represented that way internally.

<p>

<p><tt>(bitwise-rotate-bit-field&nbsp;#b00011010&nbsp;0&nbsp;5&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00010110<br>

(bitwise-rotate-bit-field&nbsp;#b01101011&nbsp;2&nbsp;7&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01011011</tt>
<p><a name="./objects:s146"></a><span class=formdef><b>procedure</b>: <tt>(bitwise-reverse-bit-field&nbsp;<i>exint<sub>1</sub></i>&nbsp;<i>exint<sub>2</sub></i>&nbsp;<i>exint<sub>3</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;bitwise)</tt>, <tt>(rnrs)</tt>

<p><tt><i>exint<sub>2</sub></i></tt> and <tt><i>exint<sub>3</sub></i></tt> must be nonnegative, and <tt><i>exint<sub>2</sub></i></tt>
must not be greater than <tt><i>exint<sub>3</sub></i></tt>.
This procedure returns the result of reversing the bits of
<tt><i>exint<sub>1</sub></i></tt> from bit <tt><i>exint<sub>2</sub></i></tt> (inclusive) through bit <tt><i>exint<sub>3</sub></i></tt> (exclusive).
<tt><i>exint<sub>1</sub></i></tt> is treated as if represented in two's complement, even
if it is not represented that way internally.

<p>

<p><tt>(bitwise-reverse-bit-field&nbsp;#b00011010&nbsp;0&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00001011<br>

(bitwise-reverse-bit-field&nbsp;#b01101011&nbsp;2&nbsp;7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00101111</tt>
<p><a name="./objects:s147"></a><span class=formdef><b>procedure</b>: <tt>(string-&gt;number&nbsp;<i>string</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-&gt;number&nbsp;<i>string</i>&nbsp;<i>radix</i>)</tt></span>
<br>
<b>returns: </b>the number represented by <tt><i>string</i></tt>, or <tt>#f</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>string</i></tt> is a valid representation of a number, that
number is returned, otherwise <tt>#f</tt> is returned.
The number is interpreted in radix <tt><i>radix</i></tt>, which must be an
exact integer in the set {2,8,10,16}.
If not specified, <tt><i>radix</i></tt> defaults to 10.
Any radix specifier within <tt><i>string</i></tt>, e.g., <tt>#x</tt>, overrides the
<tt><i>radix</i></tt> argument.

<p>

<p><tt>(string-&gt;number&nbsp;"0")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(string-&gt;number&nbsp;"3.4e3")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3400.0<br>

(string-&gt;number&nbsp;"#x#e-2e2")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-738<br>

(string-&gt;number&nbsp;"#e-2e2"&nbsp;16)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-738<br>

(string-&gt;number&nbsp;"#i15/16")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.9375<br>

(string-&gt;number&nbsp;"10"&nbsp;16)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;16</tt>
<p><a name="./objects:s148"></a><span class=formdef><b>procedure</b>: <tt>(number-&gt;string&nbsp;<i>num</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(number-&gt;string&nbsp;<i>num</i>&nbsp;<i>radix</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(number-&gt;string&nbsp;<i>num</i>&nbsp;<i>radix</i>&nbsp;<i>precision</i>)</tt></span>
<br>
<b>returns: </b>an external representation of <tt><i>num</i></tt> as a string
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The num is expressed in radix <tt><i>radix</i></tt>, which must be an
exact integer in the set {2,8,10,16}.
If not specified, <tt><i>radix</i></tt> defaults to 10.
In any case, no radix specifier appears in the resulting string.

<p>
The external representation is such that, when converted back into
a number using <tt>string-&gt;number</tt>, the resulting numeric value is equivalent
to <tt><i>num</i></tt>.
That is, for all inputs:

<p>

<p><tt>(eqv?&nbsp;(string-&gt;number<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(number-&gt;string&nbsp;<i>num</i>&nbsp;<i>radix</i>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>radix</i>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>num</i>)</tt>
<p>returns <tt>#t</tt>.
An exception with condition type
<tt>&amp;implementation-restriction</tt> is raised if this
is not possible.

<p>
If <tt><i>precision</i></tt> is provided, it must be an exact positive integer,
<tt><i>num</i></tt> must be inexact, and <tt><i>radix</i></tt> must be 10.
In this case, the real part and, if present, the imaginary part of
the number are each printed with an explicit mantissa width <tt><i>m</i></tt>, where
<tt><i>m</i></tt> is the least possible value greater than or equal to
<tt><i>precision</i></tt> that makes the expression above true.

<p>
If <tt><i>radix</i></tt> is 10, inexact values of <tt><i>num</i></tt> are expressed using the
fewest number of significant digits possible&nbsp;[<a class=citation href="bibliography.html#g223">5</a>]
without violating the above restriction.

<p>

<p><tt>(number-&gt;string&nbsp;3.4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"3.4"<br>

(number-&gt;string&nbsp;1e2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"100.0"<br>

(number-&gt;string&nbsp;1e-23)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"1e-23"<br>

(number-&gt;string&nbsp;-7/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"-7/2"<br>

(number-&gt;string&nbsp;220/9&nbsp;16)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"DC/9"</tt>
<p>
<h3><a name="g111"></a><a name="./objects:h5"></a>Section 6.5. Fixnums<a name="SECTFIXNUMS"></a></h3>



<p>
<a name="./objects:s149"></a><i>Fixnums</i> represent exact integers in the fixnum range, which is
required to be a closed range [-2<sup><i>w</i>-1</sup>,2<sup><i>w</i>-2</sup> - 1], where <i>w</i> (the
<i>fixnum width</i>) is at least 24.
The implementation-specific value of <i>w</i> may be determined via the
procedure <tt>fixnum-width</tt>, and the endpoints of the range may
be determined via the procedures <tt>least-fixnum</tt> and
<tt>greatest-fixnum</tt>.

<p>
The names of arithmetic procedures that operate only on fixnums
begin with the prefix "<tt>fx</tt>" to set them apart from their generic
counterparts.

<p>
Procedure arguments required to be fixnums are named <tt><i>fx</i></tt>, possibly
with a suffix, e.g., <tt><i>fx<sub>2</sub></i></tt>.

<p>
Unless otherwise specified, the numeric values of fixnum-specific
procedures are fixnums.
If the value of a fixnum operation should be a fixnum, but the
mathematical result would be outside the fixnum range, an exception
with condition type <tt>&amp;implementation-restriction</tt> is raised.

<p>
Bit and shift operations on fixnums assume that fixnums are represented in
two's complement, even if they are not represented that way internally.

<p>
<a name="./objects:s150"></a><span class=formdef><b>procedure</b>: <tt>(fixnum?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a fixnum, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(fixnum?&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fixnum?&nbsp;-1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fixnum?&nbsp;(-&nbsp;(expt&nbsp;2&nbsp;23)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fixnum?&nbsp;(-&nbsp;(expt&nbsp;2&nbsp;23)&nbsp;1))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s151"></a><span class=formdef><b>procedure</b>: <tt>(least-fixnum)</tt></span>
<br>
<b>returns: </b>the least (most negative) fixnum supported by the implementation
<br>
<span class=formdef><b>procedure</b>: <tt>(greatest-fixnum)</tt></span>
<br>
<b>returns: </b>the greatest (most positive) fixnum supported by the implementation
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(fixnum?&nbsp;(-&nbsp;(least-fixnum)&nbsp;1))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fixnum?&nbsp;(least-fixnum))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fixnum?&nbsp;(greatest-fixnum))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fixnum?&nbsp;(+&nbsp;(greatest-fixnum)&nbsp;1))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s152"></a><span class=formdef><b>procedure</b>: <tt>(fixnum-width)</tt></span>
<br>
<b>returns: </b>the implementation-dependent <i>fixnum width</i>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>As described in the lead-in to this section, the fixnum width determines
the size of the fixnum range and must be at least 24.

<p>

<p><tt>(define&nbsp;w&nbsp;(fixnum-width))<br>

(=&nbsp;(least-fixnum)&nbsp;(-&nbsp;(expt&nbsp;2&nbsp;(-&nbsp;w&nbsp;1))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(=&nbsp;(greatest-fixnum)&nbsp;(-&nbsp;(expt&nbsp;2&nbsp;(-&nbsp;w&nbsp;1))&nbsp;1))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(&gt;=&nbsp;w&nbsp;24)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s153"></a><span class=formdef><b>procedure</b>: <tt>(fx=?&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fx&lt;?&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fx&gt;?&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fx&lt;=?&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fx&gt;=?&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>The predicate <tt>fx=?</tt> returns <tt>#t</tt> if its arguments are equal.
The predicate <tt>fx&lt;?</tt> returns <tt>#t</tt> if its arguments are monotonically
increasing, i.e., each argument is greater than the preceding ones,
while <tt>fx&gt;?</tt> returns <tt>#t</tt> if its arguments are monotonically decreasing.
The predicate <tt>fx&lt;=?</tt> returns <tt>#t</tt> if its arguments are monotonically
nondecreasing, i.e., each argument is not less than the preceding ones,
while <tt>fx&gt;=?</tt> returns <tt>#t</tt> if its arguments are monotonically nonincreasing.

<p>

<p><tt>(fx=?&nbsp;0&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fx=?&nbsp;-1&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fx&lt;?&nbsp;(least-fixnum)&nbsp;0&nbsp;(greatest-fixnum))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([x&nbsp;3])&nbsp;(fx&lt;=?&nbsp;0&nbsp;x&nbsp;9))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fx&gt;?&nbsp;5&nbsp;4&nbsp;3&nbsp;2&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fx&lt;=?&nbsp;1&nbsp;3&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fx&gt;=?&nbsp;0&nbsp;0&nbsp;(least-fixnum))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s154"></a><span class=formdef><b>procedure</b>: <tt>(fxzero?&nbsp;<i>fx</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fx</i></tt> is zero, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(fxpositive?&nbsp;<i>fx</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fx</i></tt> is greater than zero, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(fxnegative?&nbsp;<i>fx</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fx</i></tt> is less than zero, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p><tt>fxzero?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(fx=?&nbsp;x&nbsp;0))</tt>,
<tt>fxpositive?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(fx&gt;?&nbsp;x&nbsp;0))</tt>, and
<tt>fxnegative?</tt> to <tt>(lambda&nbsp;(x)&nbsp;(fx&lt;?&nbsp;x&nbsp;0))</tt>.


<p>

<p><tt>(fxzero?&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxzero?&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(fxpositive?&nbsp;128)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxpositive?&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxpositive?&nbsp;-1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(fxnegative?&nbsp;-65)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxnegative?&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxnegative?&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s155"></a><span class=formdef><b>procedure</b>: <tt>(fxeven?&nbsp;<i>fx</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fx</i></tt> is even, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(fxodd?&nbsp;<i>fx</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fx</i></tt> is odd, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(fxeven?&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxeven?&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxeven?&nbsp;-1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxeven?&nbsp;-10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(fxodd?&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxodd?&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxodd?&nbsp;-1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxodd?&nbsp;-10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s156"></a><span class=formdef><b>procedure</b>: <tt>(fxmin&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the minimum of <tt><i>fx<sub>1</sub></i></tt> <tt><i>fx<sub>2</sub></i></tt> ... <br>
<span class=formdef><b>procedure</b>: <tt>(fxmax&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the maximum of <tt><i>fx<sub>1</sub></i></tt> <tt><i>fx<sub>2</sub></i></tt> ...<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(fxmin&nbsp;4&nbsp;-7&nbsp;2&nbsp;0&nbsp;-6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-7
<br>
<br>
(let&nbsp;([ls&nbsp;'(7&nbsp;3&nbsp;5&nbsp;2&nbsp;9&nbsp;8)])<br>

&nbsp;&nbsp;(apply&nbsp;fxmin&nbsp;ls))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2
<br>
<br>
(fxmax&nbsp;4&nbsp;-7&nbsp;2&nbsp;0&nbsp;-6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4
<br>
<br>
(let&nbsp;([ls&nbsp;'(7&nbsp;3&nbsp;5&nbsp;2&nbsp;9&nbsp;8)])<br>

&nbsp;&nbsp;(apply&nbsp;fxmax&nbsp;ls))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;9</tt>
<p><a name="./objects:s157"></a><span class=formdef><b>procedure</b>: <tt>(fx+&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the sum of <tt><i>fx<sub>1</sub></i></tt> and <tt><i>fx<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(fx+&nbsp;-3&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1</tt>
<p><a name="./objects:s158"></a><span class=formdef><b>procedure</b>: <tt>(fx-&nbsp;<i>fx</i>)</tt></span>
<br>
<b>returns: </b>the additive inverse of <tt><i>fx</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(fx-&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the difference between <tt><i>fx<sub>1</sub></i></tt> and <tt><i>fx<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(fx-&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-3<br>

(fx-&nbsp;-3&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-7</tt>
<p><a name="./objects:s159"></a><span class=formdef><b>procedure</b>: <tt>(fx*&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the product of <tt><i>fx<sub>1</sub></i></tt> and <tt><i>fx<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(fx*&nbsp;-3&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-12</tt>
<p><a name="./objects:s160"></a><span class=formdef><b>procedure</b>: <tt>(fxdiv&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fxmod&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fxdiv-and-mod&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p><tt><i>fx<sub>2</sub></i></tt> must not be zero.
These are fixnum-specific versions of the generic <tt>div</tt>,
<tt>mod</tt>, and <tt>div-and-mod</tt>.

<p>

<p><tt>(fxdiv&nbsp;17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5<br>

(fxmod&nbsp;17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(fxdiv&nbsp;-17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-6<br>

(fxmod&nbsp;-17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(fxdiv&nbsp;17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-5<br>

(fxmod&nbsp;17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(fxdiv&nbsp;-17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6<br>

(fxmod&nbsp;-17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1
<br>
<br>
(fxdiv-and-mod&nbsp;17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;2</tt>
<p><a name="./objects:s161"></a><span class=formdef><b>procedure</b>: <tt>(fxdiv0&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fxmod0&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fxdiv0-and-mod0&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p><tt><i>fx<sub>2</sub></i></tt> must not be zero.
These are fixnum-specific versions of the generic <tt>div0</tt>,
<tt>mod0</tt>, and <tt>div0-and-mod0</tt>.

<p>

<p><tt>(fxdiv0&nbsp;17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6<br>

(fxmod0&nbsp;17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxdiv0&nbsp;-17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-6<br>

(fxmod0&nbsp;-17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(fxdiv0&nbsp;17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-6<br>

(fxmod0&nbsp;17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxdiv0&nbsp;-17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6<br>

(fxmod0&nbsp;-17&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1
<br>
<br>
(fxdiv0-and-mod0&nbsp;17&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;-1</tt>
<p><a name="./objects:s162"></a><span class=formdef><b>procedure</b>: <tt>(fx+/carry&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fx-/carry&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fx*/carry&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>When an ordinary fixnum addition, subtraction, or multiplication operation
overflows, an exception is raised.
These alternative procedures instead return a carry and also allow the
carry to be propagated to the next operation.
They can be used to implement portable
code for multiple-precision arithmetic.

<p>
These procedures return the two
fixnum values of the following computations.
For <tt>fx+/carry</tt>:

<p>

<p><tt>(let*&nbsp;([s&nbsp;(+&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s0&nbsp;(mod0&nbsp;s&nbsp;(expt&nbsp;2&nbsp;(fixnum-width)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s1&nbsp;(div0&nbsp;s&nbsp;(expt&nbsp;2&nbsp;(fixnum-width)))])<br>

&nbsp;&nbsp;(values&nbsp;s0&nbsp;s1))</tt>
<p>for <tt>fx-/carry</tt>:

<p>

<p><tt>(let*&nbsp;([d&nbsp;(-&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[d0&nbsp;(mod0&nbsp;d&nbsp;(expt&nbsp;2&nbsp;(fixnum-width)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[d1&nbsp;(div0&nbsp;d&nbsp;(expt&nbsp;2&nbsp;(fixnum-width)))])<br>

&nbsp;&nbsp;(values&nbsp;d0&nbsp;d1))</tt>
<p>and for <tt>fx*/carry</tt>:

<p>

<p><tt>(let*&nbsp;([s&nbsp;(+&nbsp;(*&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)&nbsp;<i>fx<sub>3</sub></i>)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s0&nbsp;(mod0&nbsp;s&nbsp;(expt&nbsp;2&nbsp;(fixnum-width)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s1&nbsp;(div0&nbsp;s&nbsp;(expt&nbsp;2&nbsp;(fixnum-width)))])<br>

&nbsp;&nbsp;(values&nbsp;s0&nbsp;s1))</tt>
<p><a name="./objects:s163"></a><span class=formdef><b>procedure</b>: <tt>(fxnot&nbsp;<i>fx</i>)</tt></span>
<br>
<b>returns: </b>the bitwise not of <tt><i>fx</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(fxand&nbsp;<i>fx</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the bitwise and of <tt><i>fx</i>&nbsp;...</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(fxior&nbsp;<i>fx</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the bitwise inclusive or of <tt><i>fx</i>&nbsp;...</tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(fxxor&nbsp;<i>fx</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the bitwise exclusive or of <tt><i>fx</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(fxnot&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxnot&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-4
<br>
<br>
(fxand&nbsp;#b01101&nbsp;#b00111)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00101<br>

(fxior&nbsp;#b01101&nbsp;#b00111)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01111<br>

(fxxor&nbsp;#b01101&nbsp;#b00111)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01010</tt>
<p><a name="./objects:s164"></a><span class=formdef><b>procedure</b>: <tt>(fxif&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>)</tt></span>
<br>
<b>returns: </b>the bitwise "if" of its arguments
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>For each bit set in <tt><i>fx<sub>1</sub></i></tt>, the corresponding bit of the result
is taken from <tt><i>fx<sub>2</sub></i></tt>, and for each bit not set in <tt><i>fx<sub>1</sub></i></tt>,
the corresponding bit of the result is taken from <tt><i>x<sub>3</sub></i></tt>.

<p>

<p><tt>(fxif&nbsp;#b101010&nbsp;#b111000&nbsp;#b001100)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b101100</tt>
<p><tt>fxif</tt> might be defined as follows:

<p>

<p><tt>(define&nbsp;fxif<br>

&nbsp;&nbsp;(lambda&nbsp;(fx1&nbsp;fx2&nbsp;fx3)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(fxior&nbsp;(fxand&nbsp;fx1&nbsp;fx2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fxand&nbsp;(fxnot&nbsp;fx1)&nbsp;fx3))))</tt>
<p><a name="./objects:s165"></a><span class=formdef><b>procedure</b>: <tt>(fxbit-count&nbsp;<i>fx</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>For nonnegative inputs, <tt>fxbit-count</tt> returns the number of bits
set in the two's complement representation of <tt><i>fx</i></tt>.
For negative inputs, it returns a negative number whose magnitude is one
greater than the number of bits not set in <tt><i>fx</i></tt>, which is equivalent to
<tt>(fxnot&nbsp;(fxbit-count&nbsp;(fxnot&nbsp;<i>fx</i>)))</tt>.

<p>

<p><tt>(fxbit-count&nbsp;#b00000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(fxbit-count&nbsp;#b00001)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(fxbit-count&nbsp;#b00100)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(fxbit-count&nbsp;#b10101)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3
<br>
<br>
(fxbit-count&nbsp;-1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxbit-count&nbsp;-2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-2<br>

(fxbit-count&nbsp;-4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-3</tt>
<p><a name="./objects:s166"></a><span class=formdef><b>procedure</b>: <tt>(fxlength&nbsp;<i>fx</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>This procedure returns the number of bits of the smallest two's
complement representation of <tt><i>fx</i></tt>, not including the sign
bit for negative numbers.
For 0 <tt>fxlength</tt> returns 0.

<p>

<p><tt>(fxlength&nbsp;#b00000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(fxlength&nbsp;#b00001)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(fxlength&nbsp;#b00100)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(fxlength&nbsp;#b00110)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3
<br>
<br>
(fxlength&nbsp;-1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(fxlength&nbsp;-6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(fxlength&nbsp;-9)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4</tt>
<p><a name="./objects:s167"></a><span class=formdef><b>procedure</b>: <tt>(fxfirst-bit-set&nbsp;<i>fx</i>)</tt></span>
<br>
<b>returns: </b>the index of the least significant bit set in <tt><i>fx</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>fx</i></tt> is 0, <tt>fxfirst-bit-set</tt> returns -1.

<p>

<p><tt>(fxfirst-bit-set&nbsp;#b00000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxfirst-bit-set&nbsp;#b00001)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(fxfirst-bit-set&nbsp;#b01100)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2
<br>
<br>
(fxfirst-bit-set&nbsp;-1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(fxfirst-bit-set&nbsp;-2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(fxfirst-bit-set&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0</tt>
<p><a name="./objects:s168"></a><span class=formdef><b>procedure</b>: <tt>(fxbit-set?&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if bit <tt><i>fx<sub>2</sub></i></tt> of <tt><i>fx<sub>1</sub></i></tt> is set, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p><tt><i>fx<sub>2</sub></i></tt> must be nonnegative.
It is taken as a zero-based index for the bits
in the two's complement representation of <tt><i>fx<sub>1</sub></i></tt>, with the sign
bit virtually replicated an infinite number of positions to the left.

<p>

<p><tt>(fxbit-set?&nbsp;#b01011&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxbit-set?&nbsp;#b01011&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(fxbit-set?&nbsp;-1&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxbit-set?&nbsp;-1&nbsp;20)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fxbit-set?&nbsp;-3&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxbit-set?&nbsp;0&nbsp;(-&nbsp;(fixnum-width)&nbsp;1))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fxbit-set?&nbsp;-1&nbsp;(-&nbsp;(fixnum-width)&nbsp;1))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s169"></a><span class=formdef><b>procedure</b>: <tt>(fxcopy-bit&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>)</tt></span>
<br>
<b>returns: </b><tt><i>fx<sub>1</sub></i></tt> with bit <tt><i>fx<sub>2</sub></i></tt> replaced by <tt><i>fx<sub>3</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p><tt><i>fx<sub>2</sub></i></tt> must be nonnegative and less than the value of
<tt>(-&nbsp;(fixnum-width)&nbsp;1)</tt>.
<tt><i>fx<sub>3</sub></i></tt> must be 0 or 1.
This procedure effectively clears or sets the specified bit depending
on the value of <tt><i>fx<sub>3</sub></i></tt>.

<p>

<p><tt>(fxcopy-bit&nbsp;#b01110&nbsp;0&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01111<br>

(fxcopy-bit&nbsp;#b01110&nbsp;2&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01010</tt>
<p><a name="./objects:s170"></a><span class=formdef><b>procedure</b>: <tt>(fxbit-field&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p><tt><i>fx<sub>2</sub></i></tt> and <tt><i>fx<sub>3</sub></i></tt> must be nonnegative and less than the value of
<tt>(fixnum-width)</tt>, and <tt><i>fx<sub>2</sub></i></tt> must not be greater than <tt><i>fx<sub>3</sub></i></tt>.
This procedure returns the number represented by extracting from <tt><i>fx<sub>1</sub></i></tt>
the sequence of bits from <tt><i>fx<sub>2</sub></i></tt> (inclusive) to <tt><i>fx<sub>3</sub></i></tt> (exclusive).

<p>

<p><tt>(fxbit-field&nbsp;#b10110&nbsp;0&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00110<br>

(fxbit-field&nbsp;#b10110&nbsp;1&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00011<br>

(fxbit-field&nbsp;#b10110&nbsp;2&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00001<br>

(fxbit-field&nbsp;#b10110&nbsp;3&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00000</tt>
<p><a name="./objects:s171"></a><span class=formdef><b>procedure</b>: <tt>(fxcopy-bit-field&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>&nbsp;<i>fx<sub>4</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p><tt><i>fx<sub>2</sub></i></tt> and <tt><i>fx<sub>3</sub></i></tt> must be nonnegative and less than the value of
<tt>(fixnum-width)</tt>, and <tt><i>fx<sub>2</sub></i></tt> must not be greater than <tt><i>fx<sub>3</sub></i></tt>.
This procedure returns <tt><i>fx<sub>1</sub></i></tt> with <tt><i>n</i></tt> bits from <tt><i>fx<sub>2</sub></i></tt> (inclusive) to
<tt><i>fx<sub>3</sub></i></tt> (exclusive) replaced by the low-order <tt><i>n</i></tt> bits of <tt><i>x<sub>4</sub></i></tt>.

<p>

<p><tt>(fxcopy-bit-field&nbsp;#b10000&nbsp;0&nbsp;3&nbsp;#b10101)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b10101<br>

(fxcopy-bit-field&nbsp;#b10000&nbsp;1&nbsp;3&nbsp;#b10101)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b10010<br>

(fxcopy-bit-field&nbsp;#b10000&nbsp;2&nbsp;3&nbsp;#b10101)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b10100<br>

(fxcopy-bit-field&nbsp;#b10000&nbsp;3&nbsp;3&nbsp;#b10101)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b10000</tt>
<p><a name="./objects:s172"></a><span class=formdef><b>procedure</b>: <tt>(fxarithmetic-shift-right&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt><i>fx<sub>1</sub></i></tt> arithmetically shifted right by <tt><i>fx<sub>2</sub></i></tt> bits
<br>
<span class=formdef><b>procedure</b>: <tt>(fxarithmetic-shift-left&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt><i>fx<sub>1</sub></i></tt> shifted left by <tt><i>fx<sub>2</sub></i></tt> bits
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p><tt><i>fx<sub>2</sub></i></tt> must be nonnegative and less than the value of
<tt>(fixnum-width)</tt>.

<p>

<p><tt>(fxarithmetic-shift-right&nbsp;#b10000&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00010<br>

(fxarithmetic-shift-right&nbsp;-1&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxarithmetic-shift-right&nbsp;-64&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-8
<br>
<br>
(fxarithmetic-shift-left&nbsp;#b00010&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01000<br>

(fxarithmetic-shift-left&nbsp;-1&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-4</tt>
<p><a name="./objects:s173"></a><span class=formdef><b>procedure</b>: <tt>(fxarithmetic-shift&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p>The absolute value of <tt><i>fx<sub>2</sub></i></tt> must be less than the value of
<tt>(fixnum-width)</tt>.
If <tt><i>fx<sub>2</sub></i></tt> is negative, <tt>fxarithmetic-shift</tt> returns the
result of arithmetically shifting <tt><i>fx<sub>1</sub></i></tt> right by <tt><i>fx<sub>2</sub></i></tt> bits.
Otherwise, <tt>fxarithmetic-shift</tt> returns the
result of shifting <tt><i>fx<sub>1</sub></i></tt> left by <tt><i>fx<sub>2</sub></i></tt> bits.

<p>

<p><tt>(fxarithmetic-shift&nbsp;#b10000&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00010<br>

(fxarithmetic-shift&nbsp;-1&nbsp;-1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1<br>

(fxarithmetic-shift&nbsp;-64&nbsp;-3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-8<br>

(fxarithmetic-shift&nbsp;#b00010&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01000<br>

(fxarithmetic-shift&nbsp;-1&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-4</tt>
<p>Thus, <tt>fxarithmetic-shift</tt> behaves as if defined as follows.

<p>

<p><tt>(define&nbsp;fxarithmetic-shift<br>

&nbsp;&nbsp;(lambda&nbsp;(fx1&nbsp;fx2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(fx&lt;?&nbsp;fx2&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fxarithmetic-shift-right&nbsp;fx1&nbsp;(fx-&nbsp;fx2))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fxarithmetic-shift-left&nbsp;fx1&nbsp;fx2))))</tt>
<p><a name="./objects:s174"></a><span class=formdef><b>procedure</b>: <tt>(fxrotate-bit-field&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>&nbsp;<i>fx<sub>4</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p><tt><i>fx<sub>2</sub></i></tt>, <tt><i>fx<sub>3</sub></i></tt>, and <tt><i>fx<sub>4</sub></i></tt> must be nonnegative and less than
the value of <tt>(fixnum-width)</tt>, <tt><i>fx<sub>2</sub></i></tt> must not be greater
than <tt><i>fx<sub>3</sub></i></tt>, and <tt><i>fx<sub>4</sub></i></tt> must not be greater than the difference between
<tt><i>fx<sub>3</sub></i></tt> and <tt><i>fx<sub>2</sub></i></tt>.

<p>
This procedure returns the result of shifting the bits of
<tt><i>fx<sub>1</sub></i></tt> from bit <tt><i>fx<sub>2</sub></i></tt> (inclusive) through bit <tt><i>fx<sub>3</sub></i></tt> (exclusive)
left by <tt><i>fx<sub>4</sub></i></tt> bits, with the bits shifted out of the range inserted
at the bottom end of the range.

<p>

<p><tt>(fxrotate-bit-field&nbsp;#b00011010&nbsp;0&nbsp;5&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00010110<br>

(fxrotate-bit-field&nbsp;#b01101011&nbsp;2&nbsp;7&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b01011011</tt>
<p><a name="./objects:s175"></a><span class=formdef><b>procedure</b>: <tt>(fxreverse-bit-field&nbsp;<i>fx<sub>1</sub></i>&nbsp;<i>fx<sub>2</sub></i>&nbsp;<i>fx<sub>3</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;fixnums)</tt>, <tt>(rnrs)</tt>

<p><tt><i>fx<sub>2</sub></i></tt> and <tt><i>fx<sub>3</sub></i></tt> must be nonnegative and less than
the value of <tt>(fixnum-width)</tt>, and <tt><i>fx<sub>2</sub></i></tt> must not be greater
than <tt><i>fx<sub>3</sub></i></tt>.
This procedure returns the result of reversing the bits of
<tt><i>fx<sub>1</sub></i></tt> from bit <tt><i>fx<sub>2</sub></i></tt> (inclusive) through bit <tt><i>fx<sub>3</sub></i></tt> (exclusive).

<p>

<p><tt>(fxreverse-bit-field&nbsp;#b00011010&nbsp;0&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00001011<br>

(fxreverse-bit-field&nbsp;#b01101011&nbsp;2&nbsp;7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#b00101111</tt>
<p>
<h3><a name="g112"></a><a name="./objects:h6"></a>Section 6.6. Flonums<a name="SECTFLONUMS"></a></h3>



<p>
<a name="./objects:s176"></a><i>Flonums</i> represent inexact real numbers.
Implementations are required to represent as a flonum any inexact
real number whose lexical syntax contains no vertical bar and
no exponent marker other than <tt>e</tt>, but are not required
to represent any other inexact real number as a flonum.

<p>
Implementations typically use the IEEE double-precision
floating-point representation for flonums, but implementations are not
required to do so or even to use a floating-point representation
of any sort, despite the name "flonum."

<p>
This section describes operations on flonums.
Flonum-specific procedure names begin with the prefix "<tt>fl</tt>" to
set them apart from their generic counterparts.

<p>
Procedure arguments required to be flonums are named <tt><i>fl</i></tt>, possibly
with suffix, e.g., <tt><i>fl<sub>2</sub></i></tt>.
Unless otherwise specified, the numeric values of flonum-specific
procedures are flonums.

<p>
<a name="./objects:s177"></a><span class=formdef><b>procedure</b>: <tt>(flonum?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is a flonum, otherwise <tt>#f</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(flonum?&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flonum?&nbsp;3/4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flonum?&nbsp;3.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flonum?&nbsp;.02)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flonum?&nbsp;1e10)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flonum?&nbsp;3.0+0.0i)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s178"></a><span class=formdef><b>procedure</b>: <tt>(fl=?&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>&nbsp;<i>fl<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fl&lt;?&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>&nbsp;<i>fl<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fl&gt;?&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>&nbsp;<i>fl<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fl&lt;=?&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>&nbsp;<i>fl<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fl&gt;=?&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>&nbsp;<i>fl<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>The predicate <tt>fl=?</tt> returns <tt>#t</tt> if its arguments are equal.
The predicate <tt>fl&lt;?</tt> returns <tt>#t</tt> if its arguments are monotonically
increasing, i.e., each argument is greater than the preceding ones,
while <tt>fl&gt;?</tt> returns <tt>#t</tt> if its arguments are monotonically decreasing.
The predicate <tt>fl&lt;=?</tt> returns <tt>#t</tt> if its arguments are monotonically
nondecreasing, i.e., each argument is not less than the preceding ones,
while <tt>fl&gt;=?</tt> returns <tt>#t</tt> if its arguments are monotonically nonincreasing.
When passed only one argument, each of these predicates returns <tt>#t</tt>.

<p>
Comparisons involving NaNs always return <tt>#f</tt>.

<p>

<p><tt>(fl=?&nbsp;0.0&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fl&lt;?&nbsp;-1.0&nbsp;0.0&nbsp;1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fl&gt;?&nbsp;-1.0&nbsp;0.0&nbsp;1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fl&lt;=?&nbsp;0.0&nbsp;3.0&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fl&gt;=?&nbsp;4.0&nbsp;3.0&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fl&lt;?&nbsp;7.0&nbsp;+inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fl=?&nbsp;+nan.0&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fl=?&nbsp;+nan.0&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fl&lt;?&nbsp;+nan.0&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fl&lt;=?&nbsp;+nan.0&nbsp;+inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fl&gt;=?&nbsp;+nan.0&nbsp;+inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s179"></a><span class=formdef><b>procedure</b>: <tt>(flzero?&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fl</i></tt> is zero, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(flpositive?&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fl</i></tt> is greater than zero, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(flnegative?&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fl</i></tt> is less than zero, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p><tt>flzero?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(fl=?&nbsp;x&nbsp;0.0))</tt>,
<tt>flpositive?</tt> is equivalent to <tt>(lambda&nbsp;(x)&nbsp;(fl&gt;?&nbsp;x&nbsp;0.0))</tt>, and
<tt>flnegative?</tt> to <tt>(lambda&nbsp;(x)&nbsp;(fl&lt;?&nbsp;x&nbsp;0.0))</tt>.

<p>
Even if the flonum representation distinguishes -0.0 from +0.0, -0.0 is
considered both zero and nonnegative.

<p>

<p><tt>(flzero?&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flzero?&nbsp;1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(flpositive?&nbsp;128.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flpositive?&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flpositive?&nbsp;-1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(flnegative?&nbsp;-65.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flnegative?&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flnegative?&nbsp;1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(flzero?&nbsp;-0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flnegative?&nbsp;-0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(flnegative?&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flzero?&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flpositive?&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(flnegative?&nbsp;+inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flnegative?&nbsp;-inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s180"></a><span class=formdef><b>procedure</b>: <tt>(flinteger?&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fl</i></tt> is integer, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(flinteger?&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flinteger?&nbsp;-17.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flinteger?&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flinteger?&nbsp;+inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s181"></a><span class=formdef><b>procedure</b>: <tt>(flfinite?&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fl</i></tt> is finite, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(flinfinite?&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fl</i></tt> is infinite, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(flnan?&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fl</i></tt> is a NaN, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(flfinite?&nbsp;3.1415)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flinfinite?&nbsp;3.1415)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flnan?&nbsp;3.1415)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(flfinite?&nbsp;+inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flinfinite?&nbsp;-inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flnan?&nbsp;-inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(flfinite?&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flinfinite?&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flnan?&nbsp;+nan.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s182"></a><span class=formdef><b>procedure</b>: <tt>(fleven?&nbsp;<i>fl-int</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fl-int</i></tt> is even, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(flodd?&nbsp;<i>fl-int</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>fl-int</i></tt> is odd, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p><tt><i>fl-int</i></tt> must be an integer-valued flonum.

<p>

<p><tt>(fleven?&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(fleven?&nbsp;1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fleven?&nbsp;-1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(fleven?&nbsp;-10.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(flodd?&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flodd?&nbsp;1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flodd?&nbsp;-1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flodd?&nbsp;-10.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s183"></a><span class=formdef><b>procedure</b>: <tt>(flmin&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the minimum of <tt><i>fl<sub>1</sub></i></tt> <tt><i>fl<sub>2</sub></i></tt> ... <br>
<span class=formdef><b>procedure</b>: <tt>(flmax&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the maximum of <tt><i>fl<sub>1</sub></i></tt> <tt><i>fl<sub>2</sub></i></tt> ...<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(flmin&nbsp;4.2&nbsp;-7.5&nbsp;2.0&nbsp;0.0&nbsp;-6.4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-7.5
<br>
<br>
(let&nbsp;([ls&nbsp;'(7.1&nbsp;3.5&nbsp;5.0&nbsp;2.6&nbsp;2.6&nbsp;8.0)])<br>

&nbsp;&nbsp;(apply&nbsp;flmin&nbsp;ls))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.6
<br>
<br>
(flmax&nbsp;4.2&nbsp;-7.5&nbsp;2.0&nbsp;0.0&nbsp;-6.4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4.2
<br>
<br>
(let&nbsp;([ls&nbsp;'(7.1&nbsp;3.5&nbsp;5.0&nbsp;2.6&nbsp;2.6&nbsp;8.0)])<br>

&nbsp;&nbsp;(apply&nbsp;flmax&nbsp;ls))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;8.0</tt>
<p><a name="./objects:s184"></a><span class=formdef><b>procedure</b>: <tt>(fl+&nbsp;<i>fl</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the sum of the arguments <tt><i>fl</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>When called with no arguments, <tt>fl+</tt> returns <tt>0.0</tt>.

<p>

<p><tt>(fl+)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0<br>

(fl+&nbsp;1.0&nbsp;2.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.25<br>

(fl+&nbsp;3.0&nbsp;4.25&nbsp;5.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;12.25<br>

(apply&nbsp;fl+&nbsp;'(1.0&nbsp;2.0&nbsp;3.0&nbsp;4.0&nbsp;5.0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;15.0</tt>
<p><a name="./objects:s185"></a><span class=formdef><b>procedure</b>: <tt>(fl-&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the additive inverse of <tt><i>fl</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(fl-&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>&nbsp;<i>fl<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the difference between <tt><i>fl<sub>1</sub></i></tt> and the sum of <tt><i>fl<sub>2</sub></i>&nbsp;<i>fl<sub>3</sub></i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>With an IEEE floating-point representation of flonums,
the single-argument <tt>fl-</tt> is equivalent to

<p>

<p><tt>(lambda&nbsp;(x)&nbsp;(fl*&nbsp;-1.0&nbsp;x))</tt>
<p>or

<p>

<p><tt>(lambda&nbsp;(x)&nbsp;(fl-&nbsp;-0.0&nbsp;x))</tt>
<p>but not

<p>

<p><tt>(lambda&nbsp;(x)&nbsp;(fl-&nbsp;0.0&nbsp;x))</tt>
<p>since the latter returns <tt>0.0</tt> rather than <tt>-0.0</tt> for <tt>0.0</tt>.

<p>

<p><tt>(fl-&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-0.0<br>

(fl-&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-3.0<br>

(fl-&nbsp;4.0&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(fl-&nbsp;4.0&nbsp;3.0&nbsp;2.0&nbsp;1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-2.0</tt>
<p><a name="./objects:s186"></a><span class=formdef><b>procedure</b>: <tt>(fl*&nbsp;<i>fl</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the product of the arguments <tt><i>fl</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>When called with no arguments, <tt>fl*</tt> returns <tt>1.0</tt>.

<p>

<p><tt>(fl*)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(fl*&nbsp;1.5&nbsp;2.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.75<br>

(fl*&nbsp;3.0&nbsp;-4.0&nbsp;5.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-60.0<br>

(apply&nbsp;fl*&nbsp;'(1.0&nbsp;-2.0&nbsp;3.0&nbsp;-4.0&nbsp;5.0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;120.0</tt>
<p><a name="./objects:s187"></a><span class=formdef><b>procedure</b>: <tt>(fl/&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the multiplicative inverse of <tt><i>fl</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(fl/&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>&nbsp;<i>fl<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the result of dividing <tt><i>fl<sub>1</sub></i></tt> by the product of <tt><i>fl<sub>2</sub></i>&nbsp;<i>fl<sub>3</sub></i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(fl/&nbsp;-4.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-0.25<br>

(fl/&nbsp;8.0&nbsp;-2.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-4.0<br>

(fl/&nbsp;-9.0&nbsp;2.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-4.5<br>

(fl/&nbsp;60.0&nbsp;5.0&nbsp;3.0&nbsp;2.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0</tt>
<p><a name="./objects:s188"></a><span class=formdef><b>procedure</b>: <tt>(fldiv&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(flmod&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fldiv-and-mod&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>These are flonum-specific versions of the generic <tt>div</tt>,
<tt>mod</tt>, and <tt>div-and-mod</tt>.

<p>

<p><tt>(fldiv&nbsp;17.0&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5.0<br>

(flmod&nbsp;17.0&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0<br>

(fldiv&nbsp;-17.0&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-6.0<br>

(flmod&nbsp;-17.0&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(fldiv&nbsp;17.0&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-5.0<br>

(flmod&nbsp;17.0&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0<br>

(fldiv&nbsp;-17.0&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6.0<br>

(flmod&nbsp;-17.0&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0
<br>
<br>
(fldiv-and-mod&nbsp;17.5&nbsp;3.75)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4.0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;2.5</tt>
<p><a name="./objects:s189"></a><span class=formdef><b>procedure</b>: <tt>(fldiv0&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(flmod0&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(fldiv0-and-mod0&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>These are flonum-specific versions of the generic <tt>div0</tt>,
<tt>mod0</tt>, and <tt>div0-and-mod0</tt>.

<p>

<p><tt>(fldiv0&nbsp;17.0&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6.0<br>

(flmod0&nbsp;17.0&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1.0<br>

(fldiv0&nbsp;-17.0&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-6.0<br>

(flmod0&nbsp;-17.0&nbsp;3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(fldiv0&nbsp;17.0&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-6.0<br>

(flmod0&nbsp;17.0&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1.0<br>

(fldiv0&nbsp;-17.0&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6.0<br>

(flmod0&nbsp;-17.0&nbsp;-3.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0
<br>
<br>
(fldiv0-and-mod0&nbsp;17.5&nbsp;3.75)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5.0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;-1.25</tt>
<p><a name="./objects:s190"></a><span class=formdef><b>procedure</b>: <tt>(flround&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the integer closest to <tt><i>fl</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(fltruncate&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the integer closest to <tt><i>fl</i></tt> toward zero
<br>
<span class=formdef><b>procedure</b>: <tt>(flfloor&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the integer closest to <tt><i>fl</i></tt> toward <img src="math/tspl/11.gif" alt="<graphic>">
<br>
<span class=formdef><b>procedure</b>: <tt>(flceiling&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the integer closest to <tt><i>fl</i></tt> toward <img src="math/tspl/12.gif" alt="<graphic>">
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>fl</i></tt> is an integer, NaN, or infinity, each of these procedures returns <tt><i>fl</i></tt>.
If <tt><i>fl</i></tt> is exactly between two integers, <tt>flround</tt> returns the closest
even integer.

<p>

<p><tt>(flround&nbsp;17.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;17.0<br>

(flround&nbsp;-17.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-17.0<br>

(flround&nbsp;2.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0<br>

(flround&nbsp;3.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4.0
<br>
<br>
(fltruncate&nbsp;17.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;17.0<br>

(fltruncate&nbsp;-17.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-17.0
<br>
<br>
(flfloor&nbsp;17.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;17.0<br>

(flfloor&nbsp;-17.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-18.0
<br>
<br>
(flceiling&nbsp;17.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;18.0<br>

(flceiling&nbsp;-17.3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-17.0</tt>
<p><a name="./objects:s191"></a><span class=formdef><b>procedure</b>: <tt>(flnumerator&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the numerator of <tt><i>fl</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(fldenominator&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the denominator of <tt><i>fl</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>fl</i></tt> is an integer, including 0.0, or infinity, the numerator is <tt><i>fl</i></tt>
and the denominator is 1.0.

<p>

<p><tt>(flnumerator&nbsp;-9.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-9.0<br>

(fldenominator&nbsp;-9.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(flnumerator&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0<br>

(fldenominator&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(flnumerator&nbsp;-inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-inf.0<br>

(fldenominator&nbsp;-inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0</tt>
<p>The following hold for IEEE floats, but not necessarily other
flonum representations.

<p>

<p><tt>(flnumerator&nbsp;3.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;7.0<br>

(fldenominator&nbsp;3.5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0</tt>
<p><a name="./objects:s192"></a><span class=formdef><b>procedure</b>: <tt>(flabs&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>absolute value of <tt><i>fl</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(flabs&nbsp;3.2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.2<br>

(flabs&nbsp;-2e-20)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2e-20</tt>
<p><a name="./objects:s193"></a><span class=formdef><b>procedure</b>: <tt>(flexp&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b><i>e</i> to the <tt><i>fl</i></tt> power
<br>
<span class=formdef><b>procedure</b>: <tt>(fllog&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the natural logarithm of <tt><i>fl</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(fllog&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the base-<tt><i>fl<sub>2</sub></i></tt> logarithm of <tt><i>fl<sub>1</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(flexp&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(flexp&nbsp;1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.7182818284590455
<br>
<br>
(fllog&nbsp;1.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0<br>

(fllog&nbsp;(exp&nbsp;1.0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1.0<br>

(fl/&nbsp;(fllog&nbsp;100.0)&nbsp;(fllog&nbsp;10.0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0
<br>
<br>
(fllog&nbsp;100.0&nbsp;10.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0<br>

(fllog&nbsp;.125&nbsp;2.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-3.0</tt>
<p><a name="./objects:s194"></a><span class=formdef><b>procedure</b>: <tt>(flsin&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the sine of <tt><i>fl</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(flcos&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the cosine of <tt><i>fl</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(fltan&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the tangent of <tt><i>fl</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p><a name="./objects:s195"></a><span class=formdef><b>procedure</b>: <tt>(flasin&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the arc sine of <tt><i>fl</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(flacos&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the arc cosine of <tt><i>fl</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(flatan&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the arc tangent of <tt><i>fl</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(flatan&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the arc tangent of <tt><i>fl<sub>1</sub></i></tt>/<tt><i>fl<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p><a name="./objects:s196"></a><span class=formdef><b>procedure</b>: <tt>(flsqrt&nbsp;<i>fl</i>)</tt></span>
<br>
<b>returns: </b>the principal square root of <tt><i>fl</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>Returns the principal square root of <tt><i>fl</i></tt>.
The square root of -0.0 should be -0.0.
The result for other negative numbers may be a NaN or some
other unspecified flonum.

<p>

<p><tt>(flsqrt&nbsp;4.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2.0<br>

(flsqrt&nbsp;0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0<br>

(flsqrt&nbsp;-0.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-0.0</tt>
<p><a name="./objects:s197"></a><span class=formdef><b>procedure</b>: <tt>(flexpt&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt><i>fl<sub>1</sub></i></tt> raised to the <tt><i>fl<sub>2</sub></i></tt> power
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>fl<sub>1</sub></i></tt> is negative and <tt><i>fl<sub>2</sub></i></tt> is not an integer,
the result may be a NaN or some other unspecified flonum.
If <tt><i>fl<sub>1</sub></i></tt> and <tt><i>fl<sub>2</sub></i></tt> are both zero, the result
is 1.0.  If <tt><i>fl<sub>1</sub></i></tt> is zero and <tt><i>fl<sub>2</sub></i></tt> is positive,
the result is zero.  In other cases where <tt><i>fl<sub>1</sub></i></tt> is
zero, the result may be a NaN or some other unspecified
flonum.

<p>

<p><tt>(flexpt&nbsp;3.0&nbsp;2.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;9.0<br>

(flexpt&nbsp;0.0&nbsp;+inf.0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0</tt>
<p><a name="./objects:s198"></a><span class=formdef><b>procedure</b>: <tt>(fixnum-&gt;flonum&nbsp;<i>fx</i>)</tt></span>
<br>
<b>returns: </b>the flonum representation closest to <tt><i>fx</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(real-&gt;flonum&nbsp;<i>real</i>)</tt></span>
<br>
<b>returns: </b>the flonum representation closest to <tt><i>real</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;arithmetic&nbsp;flonums)</tt>, <tt>(rnrs)</tt>

<p><tt>fixnum-&gt;flonum</tt> is a restricted variant of <tt>inexact</tt>.
<tt>real-&gt;flonum</tt> is a restricted variant of <tt>inexact</tt> when
the input is an exact real; when it is an inexact non-flonum real,
it coverts the inexact non-flonum real into the closest flonum.


<p>

<p><tt>(fixnum-&gt;flonum&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0.0<br>

(fixnum-&gt;flonum&nbsp;13)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;13.0
<br>
<br>
(real-&gt;flonum&nbsp;-1/2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-0.5<br>

(real-&gt;flonum&nbsp;1s3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1000.0</tt>
<p>
<h3><a name="g113"></a><a name="./objects:h7"></a>Section 6.7. Characters<a name="SECTCHARACTERS"></a></h3>



<p>
<a name="./objects:s199"></a>Characters are atomic objects representing letters, digits,
special symbols such as <tt>$</tt> or <tt>-</tt>, and certain nongraphic
control characters such as space and newline.
Characters are written with a <a name="./objects:s200"></a><tt>#\</tt> prefix.
For most characters, the prefix is followed by the character itself.
The written character representation of the letter <tt>A</tt>, for example, is
<tt>#\A</tt>.
The characters newline, space, and tab
may be written in this manner as well, but they can be written
more clearly as <tt>#\newline</tt>, <tt>#\space</tt>, and <tt>#\tab</tt>.
Other character names are supported as well, as defined by the
grammar for character objects on page&nbsp;<a href="grammar.html#grammar:characters">457</a>.
Any Unicode character may be written with the syntax <tt>#\x<i>n</i></tt>,
where <tt><i>n</i></tt> consists of one or more hexadecimal digits and represents
a valid Unicode scalar value.

<p>
This section describes the operations that deal primarily with characters.
See also the following section on strings and Chapter&nbsp;<a href="io.html#g121">7</a> on input and
output for other operations relating to characters.

<p>
<a name="./objects:s201"></a><span class=formdef><b>procedure</b>: <tt>(char=?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;<i>char<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(char&lt;?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;<i>char<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(char&gt;?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;<i>char<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(char&lt;=?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;<i>char<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(char&gt;=?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;<i>char<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>These predicates behave in a similar manner to the numeric predicates
<tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, and <tt>&gt;=</tt>.
For example, <tt>char=?</tt> returns <tt>#t</tt> when its arguments are
equivalent characters, and <tt>char&lt;?</tt> returns <tt>#t</tt> when its
arguments are monotonically increasing character (Unicode scalar) values.

<p>

<p><tt>(char&gt;?&nbsp;#\a&nbsp;#\b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(char&lt;?&nbsp;#\a&nbsp;#\b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(char&lt;?&nbsp;#\a&nbsp;#\b&nbsp;#\c)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(let&nbsp;([c&nbsp;#\r])<br>

&nbsp;&nbsp;(char&lt;=?&nbsp;#\a&nbsp;c&nbsp;#\z))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(char&lt;=?&nbsp;#\Z&nbsp;#\W)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(char=?&nbsp;#\+&nbsp;#\+)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s202"></a><span class=formdef><b>procedure</b>: <tt>(char-ci=?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;<i>char<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(char-ci&lt;?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;<i>char<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(char-ci&gt;?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;<i>char<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(char-ci&lt;=?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;<i>char<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(char-ci&gt;=?&nbsp;<i>char<sub>1</sub></i>&nbsp;<i>char<sub>2</sub></i>&nbsp;<i>char<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;unicode)</tt>, <tt>(rnrs)</tt>

<p>These predicates are identical to the predicates <tt>char=?</tt>, <tt>char&lt;?</tt>,
<tt>char&gt;?</tt>, <tt>char&lt;=?</tt>, and <tt>char&gt;=?</tt> except that they are
case-insensitive, i.e., compare the case-folded versions of their arguments.
For example, <tt>char=?</tt> considers <tt>#\a</tt> and <tt>#\A</tt> to be
distinct values; <tt>char-ci=?</tt> does not.

<p>

<p><tt>(char-ci&lt;?&nbsp;#\a&nbsp;#\B)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(char-ci=?&nbsp;#\W&nbsp;#\w)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(char-ci=?&nbsp;#\=&nbsp;#\+)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(let&nbsp;([c&nbsp;#\R])<br>

&nbsp;&nbsp;(list&nbsp;(char&lt;=?&nbsp;#\a&nbsp;c&nbsp;#\z)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(char-ci&lt;=?&nbsp;#\a&nbsp;c&nbsp;#\z)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#f&nbsp;#t)</tt>
<p><a name="./objects:s203"></a><span class=formdef><b>procedure</b>: <tt>(char-alphabetic?&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>char</i></tt> is a letter, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(char-numeric?&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>char</i></tt> is a digit, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(char-whitespace?&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>char</i></tt> is whitespace, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;unicode)</tt>, <tt>(rnrs)</tt>

<p>A character is alphabetic if it has the Unicode "Alphabetic" property,
numeric if it has the Unicode "Numeric" property, and whitespace if has
the Unicode "White_Space" property.

<p>

<p><tt>(char-alphabetic?&nbsp;#\a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(char-alphabetic?&nbsp;#\T)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(char-alphabetic?&nbsp;#\8)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(char-alphabetic?&nbsp;#\$)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(char-numeric?&nbsp;#\7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(char-numeric?&nbsp;#\2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(char-numeric?&nbsp;#\X)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(char-numeric?&nbsp;#\space)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(char-whitespace?&nbsp;#\space)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(char-whitespace?&nbsp;#\newline)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(char-whitespace?&nbsp;#\Z)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s204"></a><span class=formdef><b>procedure</b>: <tt>(char-lower-case?&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>char</i></tt> is lower case, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(char-upper-case?&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>char</i></tt> is upper case, <tt>#f</tt> otherwise
<br>
<span class=formdef><b>procedure</b>: <tt>(char-title-case?&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>char</i></tt> is title case, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;unicode)</tt>, <tt>(rnrs)</tt>

<p>A character is upper-case if it has the Unicode "Uppercase" property,
lower-case if it has the "Lowercase" property, and title-case if it is
in the Lt general category.

<p>

<p><tt>(char-lower-case?&nbsp;#\r)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(char-lower-case?&nbsp;#\R)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(char-upper-case?&nbsp;#\r)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(char-upper-case?&nbsp;#\R)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(char-title-case?&nbsp;#\I)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(char-title-case?&nbsp;#\x01C5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s205"></a><span class=formdef><b>procedure</b>: <tt>(char-general-category&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>a symbol representing the Unicode general category of <tt><i>char</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;unicode)</tt>, <tt>(rnrs)</tt>

<p>The return value is one of the symbols <tt>Lu</tt>, <tt>Ll</tt>,
<tt>Lt</tt>, <tt>Lm</tt>, <tt>Lo</tt>, <tt>Mn</tt>, <tt>Mc</tt>,
<tt>Me</tt>, <tt>Nd</tt>, <tt>Nl</tt>, <tt>No</tt>, <tt>Ps</tt>,
<tt>Pe</tt>, <tt>Pi</tt>, <tt>Pf</tt>, <tt>Pd</tt>, <tt>Pc</tt>,
<tt>Po</tt>, <tt>Sc</tt>, <tt>Sm</tt>, <tt>Sk</tt>, <tt>So</tt>,
<tt>Zs</tt>, <tt>Zp</tt>, <tt>Zl</tt>, <tt>Cc</tt>, <tt>Cf</tt>,
<tt>Cs</tt>, <tt>Co</tt>, or <tt>Cn</tt>.

<p>

<p><tt>(char-general-category&nbsp;#\a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;Ll<br>

(char-general-category&nbsp;#\space)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;Zs<br>

(char-general-category&nbsp;#\x10FFFF)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;Cn&nbsp;&nbsp;</tt>
<p><a name="./objects:s206"></a><span class=formdef><b>procedure</b>: <tt>(char-upcase&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>the upper-case character counterpart of <tt><i>char</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;unicode)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>char</i></tt> is a lower- or title-case character and has a single
upper-case counterpart, <tt>char-upcase</tt> returns the upper-case
counterpart.
Otherwise <tt>char-upcase</tt> returns <tt><i>char</i></tt>.

<p>

<p><tt>(char-upcase&nbsp;#\g)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\G<br>

(char-upcase&nbsp;#\G)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\G<br>

(char-upcase&nbsp;#\7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\7<br>

(char-upcase&nbsp;#\<img src="math/tspl/20.gif" alt="<graphic>">)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\<img src="math/tspl/21.gif" alt="<graphic>"></tt>
<p><a name="./objects:s207"></a><span class=formdef><b>procedure</b>: <tt>(char-downcase&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>the lower-case character equivalent of <tt><i>char</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;unicode)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>char</i></tt> is an upper- or title-case character and has a single
lower-case counterpart, <tt>char-downcase</tt> returns the lower-case
counterpart.
Otherwise <tt>char-downcase</tt> returns <tt><i>char</i></tt>.

<p>

<p><tt>(char-downcase&nbsp;#\g)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\g<br>

(char-downcase&nbsp;#\G)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\g<br>

(char-downcase&nbsp;#\7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\7<br>

(char-downcase&nbsp;#\<img src="math/tspl/20.gif" alt="<graphic>">)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\<img src="math/tspl/20.gif" alt="<graphic>"></tt>
<p><a name="./objects:s208"></a><span class=formdef><b>procedure</b>: <tt>(char-titlecase&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>the title-case character equivalent of <tt><i>char</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;unicode)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>char</i></tt> is an upper- or lower-case character and has a single
title-case counterpart, <tt>char-titlecase</tt> returns the title-case
counterpart.
Otherwise, if it is not a title-case character, has no single title-case
counterpart, but does have a single upper-case counterpart,
<tt>char-titlecase</tt> returns the upper-case counterpart.
Otherwise <tt>char-titlecase</tt> returns <tt><i>char</i></tt>.

<p>

<p><tt>(char-titlecase&nbsp;#\g)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\G<br>

(char-titlecase&nbsp;#\G)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\G<br>

(char-titlecase&nbsp;#\7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\7<br>

(char-titlecase&nbsp;#\<img src="math/tspl/20.gif" alt="<graphic>">)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\<img src="math/tspl/21.gif" alt="<graphic>"></tt>
<p><a name="./objects:s209"></a><span class=formdef><b>procedure</b>: <tt>(char-foldcase&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>the case-folded character equivalent of <tt><i>char</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;unicode)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>char</i></tt> has a case-folded counterpart, <tt>char-foldcase</tt>
returns the case-folded counterpart.
Otherwise, <tt>char-foldcase</tt> returns <tt><i>char</i></tt>.
For most characters, <tt>(char-foldcase&nbsp;<i>char</i>)</tt> is
equivalent to <tt>(char-downcase&nbsp;(char-upcase&nbsp;<i>char</i>))</tt>,
but for Turkic &#x130; and &#x131;,
<tt>char-foldcase</tt> acts as the identity.

<p>

<p><tt>(char-foldcase&nbsp;#\g)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\g<br>

(char-foldcase&nbsp;#\G)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\g<br>

(char-foldcase&nbsp;#\7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\7<br>

(char-foldcase&nbsp;#\<img src="math/tspl/20.gif" alt="<graphic>">)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\<img src="math/tspl/22.gif" alt="<graphic>"></tt>
<p><a name="./objects:s210"></a><span class=formdef><b>procedure</b>: <tt>(char-&gt;integer&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>the Unicode scalar value of <tt><i>char</i></tt> as an exact integer
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>(char-&gt;integer&nbsp;#\newline)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;10<br>

(char-&gt;integer&nbsp;#\space)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;32<br>

(-&nbsp;(char-&gt;integer&nbsp;#\Z)&nbsp;(char-&gt;integer&nbsp;#\A))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;25</tt>
<p><a name="./objects:s211"></a><span class=formdef><b>procedure</b>: <tt>(integer-&gt;char&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the character corresponding to the Unicode scalar value <tt><i>n</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact integer and a valid Unicode
scalar value, i.e., <img src="math/tspl/23.gif" alt="<graphic>"> or
<img src="math/tspl/24.gif" alt="<graphic>">.

<p>

<p><tt>(integer-&gt;char&nbsp;48)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\0<br>

(integer-&gt;char&nbsp;#x3BB)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\<img src="math/tspl/25.gif" alt="<graphic>"></tt>
<p>
<h3><a name="g114"></a><a name="./objects:h8"></a>Section 6.8. Strings<a name="SECTSTRINGS"></a></h3>



<p>
<a name="./objects:s212"></a>Strings are sequences of characters and are often used as messages,
character buffers, or containers for blocks of text.
Scheme provides operations for creating strings, extracting characters from
strings, obtaining substrings, concatenating strings, and altering the contents
of strings.

<p>
A string is written as a sequence of characters enclosed in
<a name="./objects:s213"></a><a name="./objects:s214"></a>double quotes, e.g., <tt>"hi&nbsp;there"</tt>.
A double quote may be introduced into a string by preceding it by a backward
slash, e.g., <tt>"two&nbsp;\"quotes\"&nbsp;within"</tt>.
A backward slash may also be included by preceding it with a backward slash,
e.g., <tt>"a&nbsp;\\slash"</tt>.
Various special characters can be inserted
with other two-character sequences, e.g., <tt>\n</tt> for newline, <tt>\r</tt>
for carriage return, and <tt>\t</tt> for tab.
Any Unicode character may be inserted with the syntax <tt>#\x<i>n</i>;</tt>,
where <tt><i>n</i></tt> consists of one or more hexadecimal digits and represents
a valid Unicode scalar value.
A grammar defining the precise syntax of strings is given on
page&nbsp;<a href="grammar.html#grammar:strings">458</a>.

<p>
Strings are indexed by exact nonnegative integers, and the index of
the first element of any string is 0.
The highest valid index for a given string is one less than its length.


<p>
<a name="./objects:s215"></a><span class=formdef><b>procedure</b>: <tt>(string=?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string&lt;?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string&gt;?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string&lt;=?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string&gt;=?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>As with <tt>=</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, and <tt>&gt;=</tt>, these predicates
express relationships among all of the arguments.
For example, <tt>string&gt;?</tt> determines if the lexicographic ordering
of its arguments is monotonically decreasing.

<p>
The comparisons are based on the character predicates <tt>char=?</tt>
and <tt>char&lt;?</tt>.
Two strings are lexicographically equivalent if they are the same length
and consist of the same sequence of characters according to <tt>char=?</tt>.
If two strings differ only in length, the shorter string is considered to
be lexicographically less than the longer string.
Otherwise, the first character position at which the strings differ (by <tt>char=?</tt>)
determines which string is lexicographically less than the other, according
to <tt>char&lt;?</tt>.

<p>
Two-argument <tt>string=?</tt> may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;string=?<br>

&nbsp;&nbsp;(lambda&nbsp;(s1&nbsp;s2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([n&nbsp;(string-length&nbsp;s1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(=&nbsp;(string-length&nbsp;s2)&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([i&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(=&nbsp;i&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(char=?&nbsp;(string-ref&nbsp;s1&nbsp;i)&nbsp;(string-ref&nbsp;s2&nbsp;i))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(+&nbsp;i&nbsp;1)))))))))</tt>
<p>Two-argument <tt>string&lt;?</tt> may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;string&lt;?<br>

&nbsp;&nbsp;(lambda&nbsp;(s1&nbsp;s2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([n1&nbsp;(string-length&nbsp;s1)]&nbsp;[n2&nbsp;(string-length&nbsp;s2)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;loop&nbsp;([i&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(=&nbsp;i&nbsp;n2))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(=&nbsp;i&nbsp;n1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([c1&nbsp;(string-ref&nbsp;s1&nbsp;i)]&nbsp;[c2&nbsp;(string-ref&nbsp;s2&nbsp;i)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(char&lt;?&nbsp;c1&nbsp;c2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(char=?&nbsp;c1&nbsp;c2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(+&nbsp;i&nbsp;1)))))))))))</tt>
<p>These definitions may be extended straightforwardly to support
three or more arguments.
<tt>string&lt;=?</tt>, <tt>string&gt;?</tt>, and <tt>string&gt;=?</tt>
may be defined similarly.

<p>

<p><tt>(string=?&nbsp;"mom"&nbsp;"mom")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(string&lt;?&nbsp;"mom"&nbsp;"mommy")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(string&gt;?&nbsp;"Dad"&nbsp;"Dad")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(string=?&nbsp;"Mom&nbsp;and&nbsp;Dad"&nbsp;"mom&nbsp;and&nbsp;dad")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(string&lt;?&nbsp;"a"&nbsp;"b"&nbsp;"c")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s216"></a><span class=formdef><b>procedure</b>: <tt>(string-ci=?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-ci&lt;?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-ci&gt;?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-ci&lt;=?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-ci&gt;=?&nbsp;<i>string<sub>1</sub></i>&nbsp;<i>string<sub>2</sub></i>&nbsp;<i>string<sub>3</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;unicode)</tt>, <tt>(rnrs)</tt>

<p>These predicates are identical to
<tt>string=?</tt>, <tt>string&lt;?</tt>, <tt>string&gt;?</tt>, <tt>string&lt;=?</tt>, and
<tt>string&gt;=?</tt> except that they are case-sensitive,
i.e., compare the case-folded versions of their arguments.

<p>

<p><tt>(string-ci=?&nbsp;"Mom&nbsp;and&nbsp;Dad"&nbsp;"mom&nbsp;and&nbsp;dad")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(string-ci&lt;=?&nbsp;"say&nbsp;what"&nbsp;"Say&nbsp;What!?")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(string-ci&gt;?&nbsp;"N"&nbsp;"m"&nbsp;"L"&nbsp;"k")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(string-ci=?&nbsp;"Stra\sse"&nbsp;"Strasse")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s217"></a><span class=formdef><b>procedure</b>: <tt>(string&nbsp;<i>char</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a string containing the characters <tt><i>char</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(string)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;""<br>

(string&nbsp;#\a&nbsp;#\b&nbsp;#\c)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"abc"<br>

(string&nbsp;#\H&nbsp;#\E&nbsp;#\Y&nbsp;#\!)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"HEY!"</tt>
<p><a name="./objects:s218"></a><span class=formdef><b>procedure</b>: <tt>(make-string&nbsp;<i>n</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-string&nbsp;<i>n</i>&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>a string of length <tt><i>n</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer.
If <tt><i>char</i></tt> is supplied, the string is filled with <tt><i>n</i></tt>
occurrences of <tt><i>char</i></tt>,
otherwise the characters contained in the string are unspecified.

<p>

<p><tt>(make-string&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;""<br>

(make-string&nbsp;0&nbsp;#\x)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;""<br>

(make-string&nbsp;5&nbsp;#\x)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"xxxxx"</tt>
<p><a name="./objects:s219"></a><span class=formdef><b>procedure</b>: <tt>(string-length&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>the number of characters in <tt><i>string</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The length of a string is always an exact nonnegative integer.

<p>

<p><tt>(string-length&nbsp;"abc")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(string-length&nbsp;"")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(string-length&nbsp;"hi&nbsp;there")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;8<br>

(string-length&nbsp;(make-string&nbsp;1000000))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1000000</tt>
<p><a name="./objects:s220"></a><span class=formdef><b>procedure</b>: <tt>(string-ref&nbsp;<i>string</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the <tt><i>n</i></tt>th character (zero-based) of <tt><i>string</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer less than
the length of <tt><i>string</i></tt>.

<p>

<p><tt>(string-ref&nbsp;"hi&nbsp;there"&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\h<br>

(string-ref&nbsp;"hi&nbsp;there"&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#\e</tt>
<p><a name="./objects:s221"></a><span class=formdef><b>procedure</b>: <tt>(string-set!&nbsp;<i>string</i>&nbsp;<i>n</i>&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;mutable-strings)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer less than
the length of <tt><i>string</i></tt>.
<tt>string-set!</tt> changes the <tt><i>n</i></tt>th element of <tt><i>string</i></tt> to <tt><i>char</i></tt>.

<p>

<p><tt>(let&nbsp;([str&nbsp;(string-copy&nbsp;"hi&nbsp;three")])<br>

&nbsp;&nbsp;(string-set!&nbsp;str&nbsp;5&nbsp;#\e)<br>

&nbsp;&nbsp;(string-set!&nbsp;str&nbsp;6&nbsp;#\r)<br>

&nbsp;&nbsp;str)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"hi&nbsp;there"</tt>
<p><a name="./objects:s222"></a><span class=formdef><b>procedure</b>: <tt>(string-copy&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>a new copy of <tt><i>string</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>This procedure creates a new string with the same length and
contents as <tt><i>string</i></tt>.

<p>

<p><tt>(string-copy&nbsp;"abc")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"abc"
<br>
<br>
(let&nbsp;([str&nbsp;"abc"])<br>

&nbsp;&nbsp;(eq?&nbsp;str&nbsp;(string-copy&nbsp;str)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s223"></a><span class=formdef><b>procedure</b>: <tt>(string-append&nbsp;<i>string</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a new string formed by concatenating the strings <tt><i>string</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(string-append)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;""<br>

(string-append&nbsp;"abc"&nbsp;"def")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"abcdef"<br>

(string-append&nbsp;"Hey&nbsp;"&nbsp;"you&nbsp;"&nbsp;"there!")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"Hey&nbsp;you&nbsp;there!"</tt>
<p>The following implementation of <tt>string-append</tt> recurs down the
list of strings to compute the total length, then allocates the new
string, then fills it up as it unwinds the recursion.

<p>

<p><tt>(define&nbsp;string-append<br>

&nbsp;&nbsp;(lambda&nbsp;args<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([ls&nbsp;args]&nbsp;[n&nbsp;0])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-string&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([s1&nbsp;(car&nbsp;ls)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[m&nbsp;(string-length&nbsp;s1)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[s2&nbsp;(f&nbsp;(cdr&nbsp;ls)&nbsp;(+&nbsp;n&nbsp;m))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)]&nbsp;[j&nbsp;n&nbsp;(+&nbsp;j&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;m)&nbsp;s2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-set!&nbsp;s2&nbsp;j&nbsp;(string-ref&nbsp;s1&nbsp;i))))))))</tt>
<p><a name="./objects:s224"></a><span class=formdef><b>procedure</b>: <tt>(substring&nbsp;<i>string</i>&nbsp;<i>start</i>&nbsp;<i>end</i>)</tt></span>
<br>
<b>returns: </b>a copy of <tt><i>string</i></tt> from <tt><i>start</i></tt> (inclusive) to <tt><i>end</i></tt>
  (exclusive)
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt><i>start</i></tt> and <tt><i>end</i></tt> must be exact nonnegative integers;
<tt><i>start</i></tt> must be less than the length of <tt><i>string</i></tt>,
while <tt><i>end</i></tt> may be less than or equal to the length of
<tt><i>string</i></tt>.
If <tt><i>end</i></tt>&nbsp;&le;&nbsp;<tt><i>start</i></tt>, a string of length zero is returned.
<tt>substring</tt> may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;substring<br>

&nbsp;&nbsp;(lambda&nbsp;(s1&nbsp;m&nbsp;n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([s2&nbsp;(make-string&nbsp;(-&nbsp;n&nbsp;m))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([j&nbsp;0&nbsp;(+&nbsp;j&nbsp;1)]&nbsp;[i&nbsp;m&nbsp;(+&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;n)&nbsp;s2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-set!&nbsp;s2&nbsp;j&nbsp;(string-ref&nbsp;s1&nbsp;i))))))
<br>
<br>
(substring&nbsp;"hi&nbsp;there"&nbsp;0&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"h"<br>

(substring&nbsp;"hi&nbsp;there"&nbsp;3&nbsp;6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"the"<br>

(substring&nbsp;"hi&nbsp;there"&nbsp;5&nbsp;5)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;""
<br>
<br>
(let&nbsp;([str&nbsp;"hi&nbsp;there"])<br>

&nbsp;&nbsp;(let&nbsp;([end&nbsp;(string-length&nbsp;str)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(substring&nbsp;str&nbsp;0&nbsp;end)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"hi&nbsp;there"</tt>
<p><a name="./objects:s225"></a><span class=formdef><b>procedure</b>: <tt>(string-fill!&nbsp;<i>string</i>&nbsp;<i>char</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;mutable-strings)</tt>

<p><tt>string-fill!</tt> sets every character in <tt><i>string</i></tt> to <tt><i>char</i></tt>.

<p>

<p><tt>(let&nbsp;([str&nbsp;(string-copy&nbsp;"sleepy")])<br>

&nbsp;&nbsp;(string-fill!&nbsp;str&nbsp;#\Z)<br>

&nbsp;&nbsp;str)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"ZZZZZZ"</tt>
<p><tt>string-fill!</tt> might be defined as follows:

<p>

<p><tt>(define&nbsp;string-fill!<br>

&nbsp;&nbsp;(lambda&nbsp;(s&nbsp;c)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([n&nbsp;(string-length&nbsp;s)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;n))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-set!&nbsp;s&nbsp;i&nbsp;c)))))</tt>
<p>An alternative definition is given on page&nbsp;<a href="io.html#backdoor-string-fill">276</a>.


<p>
<a name="./objects:s226"></a><span class=formdef><b>procedure</b>: <tt>(string-upcase&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>the upper-case equivalent of <tt><i>string</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-downcase&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>the lower-case equivalent of <tt><i>string</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-foldcase&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>the case-folded equivalent of <tt><i>string</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-titlecase&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>the title-case equivalent of <tt><i>string</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;unicode)</tt>, <tt>(rnrs)</tt>

<p>These procedures implement Unicode's locale-independent case mappings from
scalar-value sequences to scalar-value sequences.
These mappings do not always map single characters to single characters, so
the length of the result string may differ from the length of <tt><i>string</i></tt>.
If the result string is the same as <tt><i>string</i></tt> (by <tt>string=?</tt>),
<tt><i>string</i></tt> or a copy of <tt><i>string</i></tt> may be returned.
Otherwise, the result string is newly allocated.
<tt>string-foldcase</tt> does not use the special mappings for Turkic
languages.

<p>
<tt>string-titlecase</tt> converts the first cased character of each word
in <tt><i>string</i></tt> to its title-case counterpart and converts each other
character to its lower-case counterpart.
Word breaks are recognized as specified in Unicode Standard
Annex&nbsp;#29&nbsp;[<a class=citation href="bibliography.html#g226">8</a>].

<p>

<p><tt>(string-upcase&nbsp;"Hi")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"HI"<br>

(string-downcase&nbsp;"Hi")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"hi"<br>

(string-foldcase&nbsp;"Hi")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"hi"
<br>
<br>
(string-upcase&nbsp;"Stra&szlig;e")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"STRASSE"<br>

(string-downcase&nbsp;"Stra&szlig;e")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"stra&szlig;e"<br>

(string-foldcase&nbsp;"Stra&szlig;e")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"strasse"<br>

(string-downcase&nbsp;"STRASSE")&nbsp;&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"strasse"
<br>
<br>
(string-downcase&nbsp;"<img src="math/tspl/21.gif" alt="<graphic>">")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"<img src="math/tspl/22.gif" alt="<graphic>">"
<br>
<br>
(string-titlecase&nbsp;"kNock&nbsp;KNoCK")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"Knock&nbsp;Knock"<br>

(string-titlecase&nbsp;"who's&nbsp;there?")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"Who's&nbsp;There?"<br>

(string-titlecase&nbsp;"r6rs")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"R6rs"<br>

(string-titlecase&nbsp;"R6RS")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"R6rs"</tt>
<p><a name="./objects:s227"></a><span class=formdef><b>procedure</b>: <tt>(string-normalize-nfd&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>the Unicode normalized form D of <tt><i>string</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-normalize-nfkd&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>the Unicode normalized form KD of <tt><i>string</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-normalize-nfc&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>the Unicode normalized form C of <tt><i>string</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-normalize-nfkc&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>the Unicode normalized form KC of <tt><i>string</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;unicode)</tt>, <tt>(rnrs)</tt>

<p>If the result string is the same as <tt><i>string</i></tt> (by <tt>string=?</tt>),
<tt><i>string</i></tt> or a copy of <tt><i>string</i></tt> may be returned.
Otherwise, the result string is newly allocated.

<p>

<p><tt>(string-normalize-nfd&nbsp;"\xE9;")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"e\x301;"<br>

(string-normalize-nfc&nbsp;"\xE9;")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"\xE9;"<br>

(string-normalize-nfd&nbsp;"\x65;\x301;")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"e\x301;"<br>

(string-normalize-nfc&nbsp;"\x65;\x301;")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"\xE9;"</tt>
<p><a name="./objects:s228"></a><span class=formdef><b>procedure</b>: <tt>(string-&gt;list&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>a list of the characters in <tt><i>string</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>string-&gt;list</tt> allows a string to be converted into a list, so that
Scheme's list-processing operations may be applied to the processing of
strings.
<tt>string-&gt;list</tt> may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;string-&gt;list<br>

&nbsp;&nbsp;(lambda&nbsp;(s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;(-&nbsp;(string-length&nbsp;s)&nbsp;1)&nbsp;(-&nbsp;i&nbsp;1)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ls&nbsp;'()&nbsp;(cons&nbsp;(string-ref&nbsp;s&nbsp;i)&nbsp;ls)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;i&nbsp;0)&nbsp;ls))))
<br>
<br>
(string-&gt;list&nbsp;"")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(string-&gt;list&nbsp;"abc")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#\a&nbsp;#\b&nbsp;#\c)<br>

(apply&nbsp;char&lt;?&nbsp;(string-&gt;list&nbsp;"abc"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(map&nbsp;char-upcase&nbsp;(string-&gt;list&nbsp;"abc"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#\A&nbsp;#\B&nbsp;#\C)</tt>
<p><a name="./objects:s229"></a><span class=formdef><b>procedure</b>: <tt>(list-&gt;string&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a string of the characters in <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt><i>list</i></tt> must consist entirely of characters.

<p>
<tt>list-&gt;string</tt> is the functional inverse of <tt>string-&gt;list</tt>.
A program might use both procedures together, first converting a string
into a list, then operating on this list to produce a new list, and
finally converting the new list back into a string.

<p>
<tt>list-&gt;string</tt> may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;list-&gt;string<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([s&nbsp;(make-string&nbsp;(length&nbsp;ls))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([ls&nbsp;ls&nbsp;(cdr&nbsp;ls)]&nbsp;[i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((null?&nbsp;ls)&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-set!&nbsp;s&nbsp;i&nbsp;(car&nbsp;ls))))))
<br>
<br>
(list-&gt;string&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;""<br>

(list-&gt;string&nbsp;'(#\a&nbsp;#\b&nbsp;#\c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"abc"<br>

(list-&gt;string<br>

&nbsp;&nbsp;(map&nbsp;char-upcase<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;list&nbsp;"abc")))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"ABC"</tt>
<p>
<h3><a name="g115"></a><a name="./objects:h9"></a>Section 6.9. Vectors<a name="SECTVECTORS"></a></h3>



<p>
<a name="./objects:s230"></a>Vectors are more convenient and efficient than lists for
some applications.
Whereas accessing an arbitrary element in a list requires a linear
traversal of the list up to the selected element, arbitrary vector
elements are accessed in constant time.
The <i>length</i> of a vector is the number of elements it
contains.
Vectors are indexed by exact nonnegative integers, and the index of the first
element of any vector is 0.
The highest valid index for a given vector is one less than its length.

<p>
As with lists, the elements of a vector can be of any type, and
a single vector can hold more than one type of object.

<p>
A vector is written as a sequence of objects separated by whitespace,
preceded by the prefix <tt>#(</tt> and followed by <tt>)</tt>.
For example, a vector consisting of the elements <tt>a</tt>, <tt>b</tt>, and
<tt>c</tt> would be written <tt>#(a&nbsp;b&nbsp;c)</tt>.

<p>
<a name="./objects:s231"></a><span class=formdef><b>procedure</b>: <tt>(vector&nbsp;<i>obj</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a vector of the objects <tt><i>obj</i>&nbsp;...</tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(vector)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#()<br>

(vector&nbsp;'a&nbsp;'b&nbsp;'c)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(a&nbsp;b&nbsp;c)</tt>
<p><a name="./objects:s232"></a><span class=formdef><b>procedure</b>: <tt>(make-vector&nbsp;<i>n</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-vector&nbsp;<i>n</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>a vector of length <tt><i>n</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer.
If <tt><i>obj</i></tt> is supplied, each element of the vector is filled with
<tt><i>obj</i></tt>; otherwise, the elements are unspecified.

<p>

<p><tt>(make-vector&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#()<br>

(make-vector&nbsp;0&nbsp;'#(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#()<br>

(make-vector&nbsp;5&nbsp;'#(a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(#(a)&nbsp;#(a)&nbsp;#(a)&nbsp;#(a)&nbsp;#(a))</tt>
<p><a name="./objects:s233"></a><span class=formdef><b>procedure</b>: <tt>(vector-length&nbsp;<i>vector</i>)</tt></span>
<br>
<b>returns: </b>the number of elements in <tt><i>vector</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The length of a vector is always an exact nonnegative integer.

<p>

<p><tt>(vector-length&nbsp;'#())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(vector-length&nbsp;'#(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(vector-length&nbsp;(vector&nbsp;1&nbsp;'(2)&nbsp;3&nbsp;'#(4&nbsp;5)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4<br>

(vector-length&nbsp;(make-vector&nbsp;300))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;300</tt>
<p><a name="./objects:s234"></a><span class=formdef><b>procedure</b>: <tt>(vector-ref&nbsp;<i>vector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the <tt><i>n</i></tt>th element (zero-based) of <tt><i>vector</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer less than
the length of <tt><i>vector</i></tt>.

<p>

<p><tt>(vector-ref&nbsp;'#(a&nbsp;b&nbsp;c)&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;a<br>

(vector-ref&nbsp;'#(a&nbsp;b&nbsp;c)&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;b<br>

(vector-ref&nbsp;'#(x&nbsp;y&nbsp;z&nbsp;w)&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;w</tt>
<p><a name="./objects:s235"></a><span class=formdef><b>procedure</b>: <tt>(vector-set!&nbsp;<i>vector</i>&nbsp;<i>n</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer less than
the length of <tt><i>vector</i></tt>.
<tt>vector-set!</tt> changes the <tt><i>n</i></tt>th element of <tt><i>vector</i></tt> to <tt><i>obj</i></tt>.

<p>

<p><tt>(let&nbsp;([v&nbsp;(vector&nbsp;'a&nbsp;'b&nbsp;'c&nbsp;'d&nbsp;'e)])<br>

&nbsp;&nbsp;(vector-set!&nbsp;v&nbsp;2&nbsp;'x)<br>

&nbsp;&nbsp;v)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(a&nbsp;b&nbsp;x&nbsp;d&nbsp;e)</tt>
<p><a name="./objects:s236"></a><span class=formdef><b>procedure</b>: <tt>(vector-fill!&nbsp;<i>vector</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>vector-fill!</tt> replaces each element of <tt><i>vector</i></tt> with <tt><i>obj</i></tt>.
It may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;vector-fill!<br>

&nbsp;&nbsp;(lambda&nbsp;(v&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([n&nbsp;(vector-length&nbsp;v)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;i&nbsp;n))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-set!&nbsp;v&nbsp;i&nbsp;x)))))
<br>
<br>
(let&nbsp;([v&nbsp;(vector&nbsp;1&nbsp;2&nbsp;3)])<br>

&nbsp;&nbsp;(vector-fill!&nbsp;v&nbsp;0)<br>

&nbsp;&nbsp;v)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(0&nbsp;0&nbsp;0)</tt>
<p><a name="./objects:s237"></a><span class=formdef><b>procedure</b>: <tt>(vector-&gt;list&nbsp;<i>vector</i>)</tt></span>
<br>
<b>returns: </b>a list of the elements of <tt><i>vector</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>vector-&gt;list</tt> provides a convenient method for applying list-processing
operations to vectors.
It may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;vector-&gt;list<br>

&nbsp;&nbsp;(lambda&nbsp;(s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([i&nbsp;(-&nbsp;(vector-length&nbsp;s)&nbsp;1)&nbsp;(-&nbsp;i&nbsp;1)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ls&nbsp;'()&nbsp;(cons&nbsp;(vector-ref&nbsp;s&nbsp;i)&nbsp;ls)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;i&nbsp;0)&nbsp;ls))))
<br>
<br>
(vector-&gt;list&nbsp;(vector))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(vector-&gt;list&nbsp;'#(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)
<br>
<br>
(let&nbsp;((v&nbsp;'#(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)))<br>

&nbsp;&nbsp;(apply&nbsp;*&nbsp;(vector-&gt;list&nbsp;v)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;120</tt>
<p><a name="./objects:s238"></a><span class=formdef><b>procedure</b>: <tt>(list-&gt;vector&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a vector of the elements of <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>list-&gt;vector</tt> is the functional inverse of <tt>vector-&gt;list</tt>.
The two procedures are often used in combination
to take advantage of a list-processing operation.
A vector may be converted to a list with <tt>vector-&gt;list</tt>, this list
processed in some manner to produce a new list, and the new list
converted back into a vector with <tt>list-&gt;vector</tt>.

<p>
<tt>list-&gt;vector</tt> may be defined without error checks as follows.

<p>

<p><tt>(define&nbsp;list-&gt;vector<br>

&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([s&nbsp;(make-vector&nbsp;(length&nbsp;ls))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([ls&nbsp;ls&nbsp;(cdr&nbsp;ls)]&nbsp;[i&nbsp;0&nbsp;(+&nbsp;i&nbsp;1)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((null?&nbsp;ls)&nbsp;s)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-set!&nbsp;s&nbsp;i&nbsp;(car&nbsp;ls))))))
<br>
<br>
(list-&gt;vector&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#()<br>

(list-&gt;vector&nbsp;'(a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(a&nbsp;b&nbsp;c)
<br>
<br>
(let&nbsp;([v&nbsp;'#(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)])<br>

&nbsp;&nbsp;(let&nbsp;([ls&nbsp;(vector-&gt;list&nbsp;v)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list-&gt;vector&nbsp;(map&nbsp;*&nbsp;ls&nbsp;ls))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(1&nbsp;4&nbsp;9&nbsp;16&nbsp;25)</tt>
<p><a name="./objects:s239"></a><span class=formdef><b>procedure</b>: <tt>(vector-sort&nbsp;<i>predicate</i>&nbsp;<i>vector</i>)</tt></span>
<br>
<b>returns: </b>a vector containing the elements of <tt><i>vector</i></tt>, sorted according to <tt><i>predicate</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(vector-sort!&nbsp;<i>predicate</i>&nbsp;<i>vector</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;sorting)</tt>, <tt>(rnrs)</tt>

<p><tt><i>predicate</i></tt> should be a procedure that expects two arguments and
returns <tt>#t</tt> if its first argument must precede its second in
the sorted vector.
That is, if <tt><i>predicate</i></tt> is applied to two elements <tt><i>x</i></tt> and
<tt><i>y</i></tt>, where <tt><i>x</i></tt> appears after <tt><i>y</i></tt> in the input vector,
the predicate should return true only if
<tt><i>x</i></tt> should appear before <tt><i>y</i></tt>
in the output vector.
If this constraint is met,
<tt>vector-sort</tt> performs a stable sort, i.e., two elements are
reordered only when necessary according to <tt><i>predicate</i></tt>.
<tt>vector-sort!</tt> performs the sort destructively and
does not necessarily perform a stable sort.
Duplicate elements are not removed.
<tt><i>predicate</i></tt> should not have any side effects.


<p>
<tt>vector-sort</tt> may call <tt><i>predicate</i></tt> up to <i>n</i>log<i>n</i> times,
where <i>n</i> is the length of <tt><i>vector</i></tt>, while
<tt>vector-sort!</tt> may call the predicate up to <i>n</i><sup>2</sup> times.
The looser bound for <tt>vector-sort!</tt> allows an implementation to
use a quicksort algorithm, which may be faster in some cases than
algorithms that have the tighter <i>n</i>log<i>n</i> bound.

<p>

<p><tt>(vector-sort&nbsp;&lt;&nbsp;'#(3&nbsp;4&nbsp;2&nbsp;1&nbsp;2&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(1&nbsp;2&nbsp;2&nbsp;3&nbsp;4&nbsp;5)<br>

(vector-sort&nbsp;&gt;&nbsp;'#(0.5&nbsp;1/2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(0.5&nbsp;1/2)<br>

(vector-sort&nbsp;&gt;&nbsp;'#(1/2&nbsp;0.5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(1/2&nbsp;0.5)
<br>
<br>
(let&nbsp;([v&nbsp;(vector&nbsp;3&nbsp;4&nbsp;2&nbsp;1&nbsp;2&nbsp;5)])<br>

&nbsp;&nbsp;(vector-sort!&nbsp;&lt;&nbsp;v)<br>

&nbsp;&nbsp;v)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(1&nbsp;2&nbsp;2&nbsp;3&nbsp;4&nbsp;5)</tt>
<p>
<h3><a name="g116"></a><a name="./objects:h10"></a>Section 6.10. Bytevectors<a name="SECTBYTEVECTORS"></a></h3>



<p>
Bytevectors are vectors of raw binary data.
Although nominally organized as a sequence of exact unsigned 8-bit integers, a
bytevector can be interpreted as a sequence of exact signed 8-bit integers,
exact signed or unsigned 16-bit, 32-bit, 64-bit, or arbitrary-precision
integers, IEEE single or double floating-point numbers, or arbitrary
combinations of the above.

<p>
The length of a bytevector is the number of 8-bit bytes it stores,
and indices into a bytevector are always given as byte offsets.
Any data element may be aligned at any byte offset, regardless of the
underlying hardware's alignment requirements, and may be represented using
a specified endianness (see below) that differs from that prescribed
by the hardware.
Special, typically more efficient operators are provided for
16-, 32-, and 64-bit integers and single and double floats that are
in their <i>native</i> format, i.e,. with the endianness of
the underlying hardware and stored at an index that is a multiple of
the size in bytes of the integer or float.

<p>
The endianness of a multi-byte data value determines how it is laid
out in memory.
In <i>big-endian</i> format, the value is laid out with the more
significant bytes at lower indices, while in <i>little-endian</i> format,
the value is laid out with the more significant bytes at higher
indices.
When a bytevector procedure accepts an endianness argument, the argument
may be the symbol <tt>big</tt>, representing the big-endian format, or the
symbol <tt>little</tt>, representing the little-endian format.
Implementations may extend these procedures to accept other endianness
symbols.
The native endianness of the implementation may be obtained via
the procedure <tt>native-endianness</tt>.

<p>
Bytevectors are written with the <tt>#vu8(</tt> prefix in place of the
<tt>#(</tt> prefix for vectors, e.g., <tt>#vu8(1&nbsp;2&nbsp;3)</tt>.
The elements of a bytevector specified in this manner are always given as
8-bit unsigned exact integers, i.e., integers from 0 to 255 inclusive,
written using any valid syntax for such numbers.
Like strings, bytevectors are self-evaluating, so they need not be
quoted.

<p>

<p><tt>'#vu8(1&nbsp;2&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(1&nbsp;2&nbsp;3)<br>

#vu8(1&nbsp;2&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(1&nbsp;2&nbsp;3)<br>

#vu8(#x3f&nbsp;#x7f&nbsp;#xbf&nbsp;#xff)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(63&nbsp;127&nbsp;191&nbsp;255)</tt>
<p><a name="./objects:s240"></a><span class=formdef><b>syntax</b>: <tt>(endianness&nbsp;<i>symbol</i>)</tt></span>
<br>
<b>returns: </b><tt><i>symbol</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>symbol</i></tt> must be the symbol <tt>little</tt>, the symbol <tt>big</tt>,
or some other symbol recognized by the implementation as an endianness
symbol.
It is a syntax violation if <tt><i>symbol</i></tt> is not a symbol or if it is not
recognized by the implementation as an endianness symbol.

<p>

<p><tt>(endianness&nbsp;little)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;little<br>

(endianness&nbsp;big)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;big<br>

(endianness&nbsp;"spam")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception</i></tt>
<p><a name="./objects:s241"></a><span class=formdef><b>procedure</b>: <tt>(native-endianness)</tt></span>
<br>
<b>returns: </b>a symbol naming the implementation's native endianness
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p>The return value is the symbol <tt>little</tt>, the symbol <tt>big</tt>,
or some other endianness symbol recognized by the implementation.
It typically reflects the endianness of the underlying hardware.

<p>

<p><tt>(symbol?&nbsp;(native-endianness))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s242"></a><span class=formdef><b>procedure</b>: <tt>(make-bytevector&nbsp;<i>n</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-bytevector&nbsp;<i>n</i>&nbsp;<i>fill</i>)</tt></span>
<br>
<b>returns: </b>a new bytevector of length <tt><i>n</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>fill</i></tt> is supplied, each element of the bytevector is initialized
to <tt><i>fill</i></tt>; otherwise, the elements are unspecified.
The <tt><i>fill</i></tt> value must be a signed or unsigned 8-bit value, i.e.,
a value in the range -128 to 255 inclusive.
A negative fill value is treated as its two's complement equivalent.

<p>

<p><tt>(make-bytevector&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8()<br>

(make-bytevector&nbsp;0&nbsp;7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8()<br>

(make-bytevector&nbsp;5&nbsp;7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(7&nbsp;7&nbsp;7&nbsp;7&nbsp;7)<br>

(make-bytevector&nbsp;5&nbsp;-7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(249&nbsp;249&nbsp;249&nbsp;249&nbsp;249)</tt>
<p><a name="./objects:s243"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-length&nbsp;<i>bytevector</i>)</tt></span>
<br>
<b>returns: </b>the length of <tt><i>bytevector</i></tt> in 8-bit bytes
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(bytevector-length&nbsp;#vu8())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(bytevector-length&nbsp;#vu8(1&nbsp;2&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3<br>

(bytevector-length&nbsp;(make-bytevector&nbsp;300))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;300</tt>
<p><a name="./objects:s244"></a><span class=formdef><b>procedure</b>: <tt>(bytevector=?&nbsp;<i>bytevector<sub>1</sub></i>&nbsp;<i>bytevector<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the relation holds, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p>Two bytevectors are equal by <tt>bytevector=?</tt> if and only if they
have the same length and same contents.

<p>

<p><tt>(bytevector=?&nbsp;#vu8()&nbsp;#vu8())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(bytevector=?&nbsp;(make-bytevector&nbsp;3&nbsp;0)&nbsp;#vu8(0&nbsp;0&nbsp;0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(bytevector=?&nbsp;(make-bytevector&nbsp;5&nbsp;0)&nbsp;#vu8(0&nbsp;0&nbsp;0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(bytevector=?&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255)&nbsp;#vu8(255&nbsp;128&nbsp;127&nbsp;1))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s245"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-fill!&nbsp;<i>bytevector</i>&nbsp;<i>fill</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p>The <tt><i>fill</i></tt> value must be a signed or unsigned 8-bit value, i.e.,
a value in the range -128 to 255 inclusive.
A negative fill value is treated as its two's complement equivalent.

<p>
<tt>bytevector-fill!</tt> replaces each element of <tt><i>bytevector</i></tt> with
<tt><i>fill</i></tt>.

<p>

<p><tt>(let&nbsp;([v&nbsp;(make-bytevector&nbsp;6)])<br>

&nbsp;&nbsp;(bytevector-fill!&nbsp;v&nbsp;255)<br>

&nbsp;&nbsp;v)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(255&nbsp;255&nbsp;255&nbsp;255&nbsp;255&nbsp;255)
<br>
<br>
(let&nbsp;([v&nbsp;(make-bytevector&nbsp;6)])<br>

&nbsp;&nbsp;(bytevector-fill!&nbsp;v&nbsp;-128)<br>

&nbsp;&nbsp;v)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(128&nbsp;128&nbsp;128&nbsp;128&nbsp;128&nbsp;128)</tt>
<p><a name="./objects:s246"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-copy&nbsp;<i>bytevector</i>)</tt></span>
<br>
<b>returns: </b>a new bytevector that is a copy of <tt><i>bytevector</i></tt> 
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt>bytevector-copy</tt> creates a new bytevector with the same length and
contents as <tt><i>bytevector</i></tt>.

<p>

<p><tt>(bytevector-copy&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255)
<br>
<br>
(let&nbsp;([v&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255)])<br>

&nbsp;&nbsp;(eq?&nbsp;v&nbsp;(bytevector-copy&nbsp;v)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s247"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-copy!&nbsp;<i>src</i>&nbsp;<i>src-start</i>&nbsp;<i>dst</i>&nbsp;<i>dst-start</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>src</i></tt> and <tt><i>dst</i></tt> must be bytevectors.
<tt><i>src-start</i></tt>, <tt><i>dst-start</i></tt>, and <tt><i>n</i></tt> must be exact nonnegative
integers.
The sum of <tt><i>src-start</i></tt> and <tt><i>n</i></tt> must not exceed the length of <tt><i>src</i></tt>,
and the sum of <tt><i>dst-start</i></tt> and <tt><i>n</i></tt> must not exceed the length of <tt><i>dst</i></tt>.

<p>
<tt>bytevector-copy!</tt> overwrites the <tt><i>n</i></tt> bytes of <tt><i>dst</i></tt>
starting at <tt><i>dst-start</i></tt> with the <tt><i>n</i></tt> bytes of <tt><i>dst</i></tt>
starting at <tt><i>src-start</i></tt>.
This works even if <tt><i>dst</i></tt> is the same bytevector as <tt><i>src</i></tt> and the
source and destination locations overlap.
That is, the destination is filled with the bytes that appeared at the
source before the operation began.

<p>

<p><tt>(define&nbsp;v1&nbsp;#vu8(31&nbsp;63&nbsp;95&nbsp;127&nbsp;159&nbsp;191&nbsp;223&nbsp;255))<br>

(define&nbsp;v2&nbsp;(make-bytevector&nbsp;10&nbsp;0))
<br>
<br>
(bytevector-copy!&nbsp;v1&nbsp;2&nbsp;v2&nbsp;1&nbsp;4)<br>

v2&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(0&nbsp;95&nbsp;127&nbsp;159&nbsp;191&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0)<br>

&nbsp;<br>

(bytevector-copy!&nbsp;v1&nbsp;5&nbsp;v2&nbsp;7&nbsp;3)<br>

v2&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(0&nbsp;95&nbsp;127&nbsp;159&nbsp;191&nbsp;0&nbsp;0&nbsp;191&nbsp;223&nbsp;255)<br>

&nbsp;<br>

(bytevector-copy!&nbsp;v2&nbsp;3&nbsp;v2&nbsp;0&nbsp;6)<br>

v2&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(159&nbsp;191&nbsp;0&nbsp;0&nbsp;191&nbsp;223&nbsp;0&nbsp;191&nbsp;223&nbsp;255)<br>

&nbsp;<br>

(bytevector-copy!&nbsp;v2&nbsp;0&nbsp;v2&nbsp;1&nbsp;9)<br>

v2&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(159&nbsp;159&nbsp;191&nbsp;0&nbsp;0&nbsp;191&nbsp;223&nbsp;0&nbsp;191&nbsp;223)</tt>
<p><a name="./objects:s248"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-u8-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the 8-bit unsigned byte at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer less than
the length of <tt><i>bytevector</i></tt>.

<p>
The value is returned as an exact 8-bit unsigned integer, i.e., a value in
the range 0 to 255 inclusive.

<p>

<p><tt>(bytevector-u8-ref&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255)&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(bytevector-u8-ref&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255)&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;128<br>

(bytevector-u8-ref&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255)&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;255</tt>
<p><a name="./objects:s249"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-s8-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the 8-bit signed byte at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer less than
the length of <tt><i>bytevector</i></tt>.

<p>
The value returned is an exact 8-bit signed integer, i.e., a value in
the range -128 to 127 inclusive, and is the equivalent of the
stored value treated as a two's complement value.

<p>

<p><tt>(bytevector-s8-ref&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255)&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(bytevector-s8-ref&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255)&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;127<br>

(bytevector-s8-ref&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255)&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-128<br>

(bytevector-s8-ref&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255)&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1</tt>
<p><a name="./objects:s250"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-u8-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>u8</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer less than
the length of <tt><i>bytevector</i></tt>.
<tt><i>u8</i></tt> must be an 8-bit unsigned value, i.e., a value in the range
0 to 255 inclusive.

<p>
<tt>bytevector-u8-set!</tt> changes the 8-bit value at index <tt><i>n</i></tt> (zero-based)
of <tt><i>bytevector</i></tt> to <tt><i>u8</i></tt>.

<p>

<p><tt>(let&nbsp;([v&nbsp;(make-bytevector&nbsp;5&nbsp;-1)])<br>

&nbsp;&nbsp;(bytevector-u8-set!&nbsp;v&nbsp;2&nbsp;128)<br>

&nbsp;&nbsp;v)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(255&nbsp;255&nbsp;128&nbsp;255&nbsp;255)</tt>
<p><a name="./objects:s251"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-s8-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>s8</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer less than
the length of <tt><i>bytevector</i></tt>.
<tt><i>s8</i></tt> must be an 8-bit signed value, i.e., a value in the range
-128 to 127 inclusive.

<p>
<tt>bytevector-s8-set!</tt> changes the 8-bit value at index <tt><i>n</i></tt>
(zero-based) of <tt><i>bytevector</i></tt> to the two's complement equivalent
of <tt><i>s8</i></tt>.

<p>

<p><tt>(let&nbsp;([v&nbsp;(make-bytevector&nbsp;4&nbsp;0)])<br>

&nbsp;&nbsp;(bytevector-s8-set!&nbsp;v&nbsp;1&nbsp;100)<br>

&nbsp;&nbsp;(bytevector-s8-set!&nbsp;v&nbsp;2&nbsp;-100)<br>

&nbsp;&nbsp;v)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(0&nbsp;100&nbsp;156&nbsp;0)</tt>
<p><a name="./objects:s252"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-&gt;u8-list&nbsp;<i>bytevector</i>)</tt></span>
<br>
<b>returns: </b>a list of the 8-bit unsigned elements of <tt><i>bytevector</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>(bytevector-&gt;u8-list&nbsp;(make-bytevector&nbsp;0))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(bytevector-&gt;u8-list&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;127&nbsp;128&nbsp;255)
<br>
<br>
(let&nbsp;([v&nbsp;#vu8(1&nbsp;2&nbsp;3&nbsp;255)])<br>

&nbsp;&nbsp;(apply&nbsp;*&nbsp;(bytevector-&gt;u8-list&nbsp;v)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1530</tt>
<p><a name="./objects:s253"></a><span class=formdef><b>procedure</b>: <tt>(u8-list-&gt;bytevector&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a new bytevector of the elements of <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>list</i></tt> must consist entirely of
exact 8-bit unsigned integers, i.e., values in the range 0 to 255 inclusive.

<p>

<p><tt>(u8-list-&gt;bytevector&nbsp;'())&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8()<br>

(u8-list-&gt;bytevector&nbsp;'(1&nbsp;127&nbsp;128&nbsp;255))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(1&nbsp;127&nbsp;128&nbsp;255)
<br>
<br>
(let&nbsp;([v&nbsp;#vu8(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)])<br>

&nbsp;&nbsp;(let&nbsp;([ls&nbsp;(bytevector-&gt;u8-list&nbsp;v)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(u8-list-&gt;bytevector&nbsp;(map&nbsp;*&nbsp;ls&nbsp;ls))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(1&nbsp;4&nbsp;9&nbsp;16&nbsp;25)</tt>
<p><a name="./objects:s254"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-u16-native-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the 16-bit unsigned integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-s16-native-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the 16-bit signed integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-u32-native-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the 32-bit unsigned integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-s32-native-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the 32-bit signed integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-u64-native-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the 64-bit unsigned integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-s64-native-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the 64-bit signed integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer.
It indexes the starting byte of the value and must be a multiple of the
number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit
values, and 8 for 64-bit values.
The sum of <tt><i>n</i></tt> and the number of bytes occupied by the value must
not exceed the length of <tt><i>bytevector</i></tt>.
The native endianness is assumed.

<p>
The return value is an exact integer in the appropriate range for
the number of bytes occupied by the value.
Signed values are the equivalent of the stored value treated as a two's
complement value.

<p>

<p><tt>(define&nbsp;v&nbsp;#vu8(#x12&nbsp;#x34&nbsp;#xfe&nbsp;#x56&nbsp;#xdc&nbsp;#xba&nbsp;#x78&nbsp;#x98))</tt>
<p>If native endianness is big:

<p>

<p><tt>(bytevector-u16-native-ref&nbsp;v&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#xfe56<br>

(bytevector-s16-native-ref&nbsp;v&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x-1aa<br>

(bytevector-s16-native-ref&nbsp;v&nbsp;6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x7898
<br>
<br>
(bytevector-u32-native-ref&nbsp;v&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x1234fe56<br>

(bytevector-s32-native-ref&nbsp;v&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x1234fe56<br>

(bytevector-s32-native-ref&nbsp;v&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x-23458768
<br>
<br>
(bytevector-u64-native-ref&nbsp;v&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x1234fe56dcba7898<br>

(bytevector-s64-native-ref&nbsp;v&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x1234fe56dcba7898</tt>
<p>If native endianness is little:

<p>

<p><tt>(bytevector-u16-native-ref&nbsp;v&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x56fe<br>

(bytevector-s16-native-ref&nbsp;v&nbsp;2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x56fe<br>

(bytevector-s16-native-ref&nbsp;v&nbsp;6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x-6788
<br>
<br>
(bytevector-u32-native-ref&nbsp;v&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x56fe3412<br>

(bytevector-s32-native-ref&nbsp;v&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x56fe3412<br>

(bytevector-s32-native-ref&nbsp;v&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x-67874524
<br>
<br>
(bytevector-u64-native-ref&nbsp;v&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x9878badc56fe3412<br>

(bytevector-s64-native-ref&nbsp;v&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x-67874523a901cbee</tt>
<p><a name="./objects:s255"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-u16-native-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>u16</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-s16-native-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>s16</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-u32-native-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>u32</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-s32-native-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>s32</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-u64-native-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>u64</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-s64-native-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>s64</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer.
It indexes the starting byte of the value and must be a multiple of the
number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit
values, and 8 for 64-bit values.
The sum of <tt><i>n</i></tt> and the number of bytes occupied by the value must
not exceed the length <tt><i>bytevector</i></tt>.
<tt><i>u16</i></tt> must be a 16-bit unsigned value, i.e., a value in the range
0 to 2<sup>16</sup> - 1 inclusive;
<tt><i>s16</i></tt> must be a 16-bit signed value, i.e., a value in the range
-2<sup>15</sup> to 2<sup>15</sup> - 1 inclusive;
<tt><i>u32</i></tt> must be a 32-bit unsigned value, i.e., a value in the range
0 to 2<sup>32</sup> - 1 inclusive;
<tt><i>s32</i></tt> must be a 32-bit signed value, i.e., a value in the range
-2<sup>31</sup> to 2<sup>31</sup> - 1 inclusive;
<tt><i>u64</i></tt> must be a 64-bit unsigned value, i.e., a value in the range
0 to 2<sup>64</sup> - 1 inclusive; and
<tt><i>s64</i></tt> must be a 64-bit signed value, i.e., a value in the range
-2<sup>63</sup> to 2<sup>63</sup> - 1 inclusive.
The native endianness is assumed.

<p>
These procedures store the given value in the 2, 4, or 8 bytes starting
at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt>.
Negative values are stored as their two's complement equivalent.

<p>

<p><tt>(define&nbsp;v&nbsp;(make-bytevector&nbsp;8&nbsp;0))<br>

(bytevector-u16-native-set!&nbsp;v&nbsp;0&nbsp;#xfe56)<br>

(bytevector-s16-native-set!&nbsp;v&nbsp;2&nbsp;#x-1aa)<br>

(bytevector-s16-native-set!&nbsp;v&nbsp;4&nbsp;#x7898)</tt>
<p>If native endianness is big:

<p>

<p><tt>v&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(#xfe&nbsp;#x56&nbsp;#xfe&nbsp;#x56&nbsp;#x78&nbsp;#x98&nbsp;#x00&nbsp;#x00)</tt>
<p>If native endianness is little:

<p>

<p><tt>v&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(#x56&nbsp;#xfe&nbsp;#x56&nbsp;#xfe&nbsp;#x98&nbsp;#x78&nbsp;#x00&nbsp;#x00)</tt>
<p>
<p><tt>(define&nbsp;v&nbsp;(make-bytevector&nbsp;16&nbsp;0))<br>

(bytevector-u32-native-set!&nbsp;v&nbsp;0&nbsp;#x1234fe56)<br>

(bytevector-s32-native-set!&nbsp;v&nbsp;4&nbsp;#x1234fe56)<br>

(bytevector-s32-native-set!&nbsp;v&nbsp;8&nbsp;#x-23458768)</tt>
<p>If native endianness is big:

<p>

<p><tt>v&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(#x12&nbsp;#x34&nbsp;#xfe&nbsp;#x56&nbsp;#x12&nbsp;#x34&nbsp;#xfe&nbsp;#x56<br>

&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#xdc&nbsp;#xba&nbsp;#x78&nbsp;#x98&nbsp;#x00&nbsp;#x00&nbsp;#x00&nbsp;#x00)</tt>
<p>If native endianness is little:

<p>

<p><tt>v&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(#x56&nbsp;#xfe&nbsp;#x34&nbsp;#x12&nbsp;#x56&nbsp;#xfe&nbsp;#x34&nbsp;#x12<br>

&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#x98&nbsp;#x78&nbsp;#xba&nbsp;#xdc&nbsp;#x00&nbsp;#x00&nbsp;#x00&nbsp;#x00)</tt>
<p>
<p><tt>(define&nbsp;v&nbsp;(make-bytevector&nbsp;24&nbsp;0))<br>

(bytevector-u64-native-set!&nbsp;v&nbsp;0&nbsp;#x1234fe56dcba7898)<br>

(bytevector-s64-native-set!&nbsp;v&nbsp;8&nbsp;#x1234fe56dcba7898)<br>

(bytevector-s64-native-set!&nbsp;v&nbsp;16&nbsp;#x-67874523a901cbee)</tt>
<p>If native endianness is big:

<p>

<p><tt>v&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(#x12&nbsp;#x34&nbsp;#xfe&nbsp;#x56&nbsp;#xdc&nbsp;#xba&nbsp;#x78&nbsp;#x98<br>

&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#x12&nbsp;#x34&nbsp;#xfe&nbsp;#x56&nbsp;#xdc&nbsp;#xba&nbsp;#x78&nbsp;#x98<br>

&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#x98&nbsp;#x78&nbsp;#xba&nbsp;#xdc&nbsp;#x56&nbsp;#xfe&nbsp;#x34&nbsp;#x12)</tt>
<p>If native endianness is little:

<p>

<p><tt>v&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(#x98&nbsp;#x78&nbsp;#xba&nbsp;#xdc&nbsp;#x56&nbsp;#xfe&nbsp;#x34&nbsp;#x12<br>

&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#x98&nbsp;#x78&nbsp;#xba&nbsp;#xdc&nbsp;#x56&nbsp;#xfe&nbsp;#x34&nbsp;#x12<br>

&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#x12&nbsp;#x34&nbsp;#xfe&nbsp;#x56&nbsp;#xdc&nbsp;#xba&nbsp;#x78&nbsp;#x98)</tt>
<p><a name="./objects:s256"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-u16-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 16-bit unsigned integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-s16-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 16-bit signed integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-u32-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 32-bit unsigned integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-s32-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 32-bit signed integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-u64-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 64-bit unsigned integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-s64-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the 64-bit signed integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer and
indexes the starting byte of the value.
The sum of <tt><i>n</i></tt> and the number of bytes occupied by the value
(2 for 16-bit values, 4 for 32-bit values, and 8 for 32-bit values)
must not exceed the length of <tt><i>bytevector</i></tt>.
<tt><i>n</i></tt> need <i>not</i> be a multiple of the
number of bytes occupied by the value.
<tt><i>eness</i></tt> must be a valid endianness symbol naming the endianness.

<p>
The return value is an exact integer in the appropriate range for
the number of bytes occupied by the value.
Signed values are the equivalent of the stored value treated as a two's
complement value.

<p>

<p><tt>(define&nbsp;v&nbsp;#vu8(#x12&nbsp;#x34&nbsp;#xfe&nbsp;#x56&nbsp;#xdc&nbsp;#xba&nbsp;#x78&nbsp;#x98&nbsp;#x9a&nbsp;#x76))<br>

(bytevector-u16-ref&nbsp;v&nbsp;0&nbsp;(endianness&nbsp;big))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x1234<br>

(bytevector-s16-ref&nbsp;v&nbsp;1&nbsp;(endianness&nbsp;big))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x34fe<br>

(bytevector-s16-ref&nbsp;v&nbsp;5&nbsp;(endianness&nbsp;big))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x-4588
<br>
<br>
(bytevector-u32-ref&nbsp;v&nbsp;2&nbsp;'big)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#xfe56dcba<br>

(bytevector-s32-ref&nbsp;v&nbsp;3&nbsp;'big)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x56dcba78<br>

(bytevector-s32-ref&nbsp;v&nbsp;4&nbsp;'big)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x-23458768
<br>
<br>
(bytevector-u64-ref&nbsp;v&nbsp;0&nbsp;'big)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x1234fe56dcba7898<br>

(bytevector-s64-ref&nbsp;v&nbsp;1&nbsp;'big)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x34fe56dcba78989a
<br>
<br>
(bytevector-u16-ref&nbsp;v&nbsp;0&nbsp;(endianness&nbsp;little))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x3412<br>

(bytevector-s16-ref&nbsp;v&nbsp;1&nbsp;(endianness&nbsp;little))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x-1cc<br>

(bytevector-s16-ref&nbsp;v&nbsp;5&nbsp;(endianness&nbsp;little))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x78ba
<br>
<br>
(bytevector-u32-ref&nbsp;v&nbsp;2&nbsp;'little)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#xbadc56fe<br>

(bytevector-s32-ref&nbsp;v&nbsp;3&nbsp;'little)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x78badc56<br>

(bytevector-s32-ref&nbsp;v&nbsp;4&nbsp;'little)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x-67874524
<br>
<br>
(bytevector-u64-ref&nbsp;v&nbsp;0&nbsp;'little)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x9878badc56fe3412<br>

(bytevector-s64-ref&nbsp;v&nbsp;1&nbsp;'little)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x-6567874523a901cc</tt>
<p><a name="./objects:s257"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-u16-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>u16</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-s16-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>s16</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-u32-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>u32</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-s32-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>s32</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-u64-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>u64</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-s64-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>s64</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer and
indexes the starting byte of the value.
The sum of <tt><i>n</i></tt> and the number of bytes occupied by the value must
not exceed the length of <tt><i>bytevector</i></tt>.
<tt><i>n</i></tt> need <i>not</i> be a multiple of the
number of bytes occupied by the value.
<tt><i>u16</i></tt> must be a 16-bit unsigned value, i.e., a value in the range
0 to 2<sup>16</sup> - 1 inclusive;
<tt><i>s16</i></tt> must be a 16-bit signed value, i.e., a value in the range
-2<sup>15</sup> to 2<sup>15</sup> - 1 inclusive;
<tt><i>u32</i></tt> must be a 32-bit unsigned value, i.e., a value in the range
0 to 2<sup>32</sup> - 1 inclusive;
<tt><i>s32</i></tt> must be a 32-bit signed value, i.e., a value in the range
-2<sup>31</sup> to 2<sup>31</sup> - 1 inclusive;
<tt><i>u64</i></tt> must be a 64-bit unsigned value, i.e., a value in the range
0 to 2<sup>64</sup> - 1 inclusive; and
<tt><i>s64</i></tt> must be a 64-bit signed value, i.e., a value in the range
-2<sup>63</sup> to 2<sup>63</sup> - 1 inclusive.
<tt><i>eness</i></tt> must be a valid endianness symbol naming the endianness.

<p>
These procedures store the given value in the 2, 4, or 8 bytes starting
at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt>.
Negative values are stored as their two's complement equivalent.

<p>

<p><tt>(define&nbsp;v&nbsp;(make-bytevector&nbsp;8&nbsp;0))<br>

(bytevector-u16-set!&nbsp;v&nbsp;0&nbsp;#xfe56&nbsp;(endianness&nbsp;big))<br>

(bytevector-s16-set!&nbsp;v&nbsp;3&nbsp;#x-1aa&nbsp;(endianness&nbsp;little))<br>

(bytevector-s16-set!&nbsp;v&nbsp;5&nbsp;#x7898&nbsp;(endianness&nbsp;big))<br>

v&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(#xfe&nbsp;#x56&nbsp;#x0&nbsp;#x56&nbsp;#xfe&nbsp;#x78&nbsp;#x98&nbsp;#x0)
<br>
<br>
(define&nbsp;v&nbsp;(make-bytevector&nbsp;16&nbsp;0))<br>

(bytevector-u32-set!&nbsp;v&nbsp;0&nbsp;#x1234fe56&nbsp;'little)<br>

(bytevector-s32-set!&nbsp;v&nbsp;6&nbsp;#x1234fe56&nbsp;'big)<br>

(bytevector-s32-set!&nbsp;v&nbsp;11&nbsp;#x-23458768&nbsp;'little)<br>

v&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(#x56&nbsp;#xfe&nbsp;#x34&nbsp;#x12&nbsp;#x0&nbsp;#x0<br>

&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#x12&nbsp;#x34&nbsp;#xfe&nbsp;#x56&nbsp;#x0<br>

&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#x98&nbsp;#x78&nbsp;#xba&nbsp;#xdc&nbsp;#x0)
<br>
<br>
(define&nbsp;v&nbsp;(make-bytevector&nbsp;28&nbsp;0))<br>

(bytevector-u64-set!&nbsp;v&nbsp;0&nbsp;#x1234fe56dcba7898&nbsp;'little)<br>

(bytevector-s64-set!&nbsp;v&nbsp;10&nbsp;#x1234fe56dcba7898&nbsp;'big)<br>

(bytevector-s64-set!&nbsp;v&nbsp;19&nbsp;#x-67874523a901cbee&nbsp;'big)<br>

v&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(#x98&nbsp;#x78&nbsp;#xba&nbsp;#xdc&nbsp;#x56&nbsp;#xfe&nbsp;#x34&nbsp;#x12&nbsp;#x0&nbsp;#x0<br>

&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#x12&nbsp;#x34&nbsp;#xfe&nbsp;#x56&nbsp;#xdc&nbsp;#xba&nbsp;#x78&nbsp;#x98&nbsp;#x0<br>

&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#x98&nbsp;#x78&nbsp;#xba&nbsp;#xdc&nbsp;#x56&nbsp;#xfe&nbsp;#x34&nbsp;#x12&nbsp;#x0)</tt>
<p><a name="./objects:s258"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-uint-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>the <tt><i>size</i></tt>-byte unsigned integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-sint-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>the <tt><i>size</i></tt>-byte signed integer at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer and
indexes the starting byte of the value.
<tt><i>size</i></tt> must be an exact positive integer and specifies the number
of bytes occupied by the value.
The sum of <tt><i>n</i></tt> and <tt><i>size</i></tt> must not exceed the length
of <tt><i>bytevector</i></tt>.
<tt><i>n</i></tt> need <i>not</i> be a multiple of the
number of bytes occupied by the value.
<tt><i>eness</i></tt> must be a valid endianness symbol naming the endianness.

<p>
The return value is an exact integer in the appropriate range for
the number of bytes occupied by the value.
Signed values are the equivalent of the stored value treated as a two's
complement value.

<p>

<p><tt>(define&nbsp;v&nbsp;#vu8(#x12&nbsp;#x34&nbsp;#xfe&nbsp;#x56&nbsp;#xdc&nbsp;#xba&nbsp;#x78&nbsp;#x98&nbsp;#x9a&nbsp;#x76))
<br>
<br>
(bytevector-uint-ref&nbsp;v&nbsp;0&nbsp;'big&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x12<br>

(bytevector-uint-ref&nbsp;v&nbsp;0&nbsp;'little&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x12<br>

(bytevector-uint-ref&nbsp;v&nbsp;1&nbsp;'big&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x34fe56<br>

(bytevector-uint-ref&nbsp;v&nbsp;2&nbsp;'little&nbsp;7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x9a9878badc56fe
<br>
<br>
(bytevector-sint-ref&nbsp;v&nbsp;2&nbsp;'big&nbsp;1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x-02<br>

(bytevector-sint-ref&nbsp;v&nbsp;1&nbsp;'little&nbsp;6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x78badc56fe34<br>

(bytevector-sint-ref&nbsp;v&nbsp;2&nbsp;'little&nbsp;7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#x-6567874523a902
<br>
<br>
(bytevector-sint-ref&nbsp;(make-bytevector&nbsp;1000&nbsp;-1)&nbsp;0&nbsp;'big&nbsp;1000)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;-1</tt>
<p><a name="./objects:s259"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-uint-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>uint</i>&nbsp;<i>eness</i>&nbsp;<i>size</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-sint-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>sint</i>&nbsp;<i>eness</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer and
indexes the starting byte of the value.
<tt><i>size</i></tt> must be an exact positive integer and specifies the number
of bytes occupied by the value.
The sum of <tt><i>n</i></tt> and <tt><i>size</i></tt> must not exceed the length
of <tt><i>bytevector</i></tt>.
<tt><i>n</i></tt> need <i>not</i> be a multiple of the
number of bytes occupied by the value.
<tt><i>uint</i></tt> must be an exact integer in the range
0 to 2<sup><i>size</i>&middot;8</sup> - 1 inclusive.
<tt><i>sint</i></tt> must be an exact integer in the range
-2<sup><i>size</i>&middot;8-1</sup> to 2<sup><i>size</i>&middot;8-1</sup> - 1 inclusive.
<tt><i>eness</i></tt> must be a valid endianness symbol naming the endianness.

<p>
These procedures store the given value in the <tt><i>size</i></tt> bytes starting
at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt>.
Negative values are stored as their two's complement equivalent.

<p>

<p><tt>(define&nbsp;v&nbsp;(make-bytevector&nbsp;5&nbsp;0))<br>

(bytevector-uint-set!&nbsp;v&nbsp;1&nbsp;#x123456&nbsp;(endianness&nbsp;big)&nbsp;3)<br>

v&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(0&nbsp;#x12&nbsp;#x34&nbsp;#x56&nbsp;0)
<br>
<br>
(define&nbsp;v&nbsp;(make-bytevector&nbsp;7&nbsp;-1))<br>

(bytevector-sint-set!&nbsp;v&nbsp;1&nbsp;#x-8000000000&nbsp;(endianness&nbsp;little)&nbsp;5)<br>

v&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(#xff&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;#x80&nbsp;#xff)</tt>
<p><a name="./objects:s260"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-&gt;uint-list&nbsp;<i>bytevector</i>&nbsp;<i>eness</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>a new list of the <tt><i>size</i></tt>-bit unsigned elements of <tt><i>bytevector</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-&gt;sint-list&nbsp;<i>bytevector</i>&nbsp;<i>eness</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>a new list of the <tt><i>size</i></tt>-bit signed elements of <tt><i>bytevector</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>eness</i></tt> must be a valid endianness symbol naming the endianness.
<tt><i>size</i></tt> must be an exact positive integer and specifies the number
of bytes occupied by the value.
It must be a value that evenly divides the length of <tt><i>bytevector</i></tt>.

<p>

<p><tt>(bytevector-&gt;uint-list&nbsp;(make-bytevector&nbsp;0)&nbsp;'little&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()
<br>
<br>
(let&nbsp;([v&nbsp;#vu8(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6)])<br>

&nbsp;&nbsp;(bytevector-&gt;uint-list&nbsp;v&nbsp;'big&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(#x010203&nbsp;#x040506)
<br>
<br>
(let&nbsp;([v&nbsp;(make-bytevector&nbsp;80&nbsp;-1)])<br>

&nbsp;&nbsp;(bytevector-&gt;sint-list&nbsp;v&nbsp;'big&nbsp;20))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(-1&nbsp;-1&nbsp;-1&nbsp;-1)</tt>
<p><a name="./objects:s261"></a><span class=formdef><b>procedure</b>: <tt>(uint-list-&gt;bytevector&nbsp;<i>list</i>&nbsp;<i>eness</i>&nbsp;<i>size</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(sint-list-&gt;bytevector&nbsp;<i>list</i>&nbsp;<i>eness</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>a new bytevector of the elements of <tt><i>list</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>eness</i></tt> must be a valid endianness symbol naming the endianness.
<tt><i>size</i></tt> must be an exact positive integer and specifies the number
of bytes occupied by the value.
For <tt>uint-list-&gt;bytevector</tt>, <tt><i>list</i></tt> must consist entirely of
<tt><i>size</i></tt>-byte exact unsigned integers, i.e., values in the range
0 to 2<sup><i>size</i>&middot;8</sup> - 1 inclusive.
For <tt>sint-list-&gt;bytevector</tt>, <tt><i>list</i></tt> must consist entirely of
<tt><i>size</i></tt>-byte exact signed integers, i.e., values in the range
-2<sup><i>size</i>&middot;8-1</sup> to 2<sup><i>size</i>&middot;8-1</sup> - 1 inclusive.
Each value occupies <tt><i>size</i></tt> bytes in the resulting bytevector, whose
length is thus <tt><i>size</i></tt> times the length of <tt><i>list</i></tt>.

<p>

<p><tt>(uint-list-&gt;bytevector&nbsp;'()&nbsp;'big&nbsp;25)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8()<br>

(sint-list-&gt;bytevector&nbsp;'(0&nbsp;-1)&nbsp;'big&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(0&nbsp;0&nbsp;0&nbsp;#xff&nbsp;#xff&nbsp;#xff)
<br>
<br>
(define&nbsp;(f&nbsp;size)<br>

&nbsp;&nbsp;(let&nbsp;([ls&nbsp;(list&nbsp;(-&nbsp;(expt&nbsp;2&nbsp;(-&nbsp;(*&nbsp;8&nbsp;size)&nbsp;1)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;(expt&nbsp;2&nbsp;(-&nbsp;(*&nbsp;8&nbsp;size)&nbsp;1))&nbsp;1))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(sint-list-&gt;bytevector&nbsp;ls&nbsp;'little&nbsp;size)))<br>

(f&nbsp;6)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(#x00&nbsp;#x00&nbsp;#x00&nbsp;#x00&nbsp;#x00&nbsp;#x80<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#xff&nbsp;#xff&nbsp;#xff&nbsp;#xff&nbsp;#xff&nbsp;#x7f)</tt>
<p><a name="./objects:s262"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-ieee-single-native-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the single floating-point value at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-ieee-double-native-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>)</tt></span>
<br>
<b>returns: </b>the double floating-point value at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer.
It indexes the starting byte of the value and must be a multiple of the
number of bytes occupied by the value: 4 for single floats, 8 for double.
The sum of <tt><i>n</i></tt> and the number of bytes occupied by the value must
not exceed the length of <tt><i>bytevector</i></tt>.
The native endianness is assumed.

<p>
The return value is an inexact real number.
Examples appear after the mutation operators below.

<p>
<a name="./objects:s263"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-ieee-single-native-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>x</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-ieee-double-native-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>x</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer.
It indexes the starting byte of the value and must be a multiple of the
number of bytes occupied by the value: 4 for single floats, 8 for double.
The sum of <tt><i>n</i></tt> and the number of bytes occupied by the value must
not exceed the length of <tt><i>bytevector</i></tt>.
The native endianness is assumed.

<p>
These procedures store the given value as an IEEE-754 single or
double floating-point value at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt>.

<p>

<p><tt>(define&nbsp;v&nbsp;(make-bytevector&nbsp;8&nbsp;0))<br>

(bytevector-ieee-single-native-set!&nbsp;v&nbsp;0&nbsp;.125)<br>

(bytevector-ieee-single-native-set!&nbsp;v&nbsp;4&nbsp;-3/2)<br>

(list<br>

&nbsp;&nbsp;(bytevector-ieee-single-native-ref&nbsp;v&nbsp;0)<br>

&nbsp;&nbsp;(bytevector-ieee-single-native-ref&nbsp;v&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(0.125&nbsp;-1.5)
<br>
<br>
(bytevector-ieee-double-native-set!&nbsp;v&nbsp;0&nbsp;1e23)<br>

(bytevector-ieee-double-native-ref&nbsp;v&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1e23</tt>
<p><a name="./objects:s264"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-ieee-single-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the single floating-point value at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-ieee-double-ref&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>the double floating-point value at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt> 
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer and
indexes the starting byte of the value.
The sum of <tt><i>n</i></tt> and the number of bytes occupied by the value
(4 for a single float, 8 for a double)
must not exceed the length of <tt><i>bytevector</i></tt>.
<tt><i>n</i></tt> need <i>not</i> be a multiple of the
number of bytes occupied by the value.
<tt><i>eness</i></tt> must be a valid endianness symbol naming the endianness.

<p>
The return value is an inexact real number.
Examples appear after the mutation operators below.


<p>
<a name="./objects:s265"></a><span class=formdef><b>procedure</b>: <tt>(bytevector-ieee-single-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>x</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bytevector-ieee-double-set!&nbsp;<i>bytevector</i>&nbsp;<i>n</i>&nbsp;<i>x</i>&nbsp;<i>eness</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;bytevectors)</tt>, <tt>(rnrs)</tt>

<p><tt><i>n</i></tt> must be an exact nonnegative integer and
indexes the starting byte of the value.
The sum of <tt><i>n</i></tt> and the number of bytes occupied by the value
(4 for a single float, 8 for a double)
must not exceed the length of <tt><i>bytevector</i></tt>.
<tt><i>n</i></tt> need <i>not</i> be a multiple of the
number of bytes occupied by the value.
<tt><i>eness</i></tt> must be a valid endianness symbol naming the endianness.

<p>
These procedures store the given value as an IEEE-754 single or double
floating-point value at index <tt><i>n</i></tt> (zero-based) of <tt><i>bytevector</i></tt>.

<p>

<p><tt>(define&nbsp;v&nbsp;(make-bytevector&nbsp;10&nbsp;#xc7))<br>

(bytevector-ieee-single-set!&nbsp;v&nbsp;1&nbsp;.125&nbsp;'little)<br>

(bytevector-ieee-single-set!&nbsp;v&nbsp;6&nbsp;-3/2&nbsp;'big)<br>

(list<br>

&nbsp;&nbsp;(bytevector-ieee-single-ref&nbsp;v&nbsp;1&nbsp;'little)<br>

&nbsp;&nbsp;(bytevector-ieee-single-ref&nbsp;v&nbsp;6&nbsp;'big))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(0.125&nbsp;-1.5)<br>

v&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#vu8(#xc7&nbsp;#x0&nbsp;#x0&nbsp;#x0&nbsp;#x3e&nbsp;#xc7&nbsp;#xbf&nbsp;#xc0&nbsp;#x0&nbsp;#x0)
<br>
<br>
(bytevector-ieee-double-set!&nbsp;v&nbsp;1&nbsp;1e23&nbsp;'big)<br>

(bytevector-ieee-double-ref&nbsp;v&nbsp;1&nbsp;'big)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1e23</tt>
<p>
<h3><a name="g117"></a><a name="./objects:h11"></a>Section 6.11. Symbols<a name="SECTSYMBOLS"></a></h3>



<p>
<a name="./objects:s266"></a>Symbols are used for a variety of purposes as symbolic names in
Scheme programs.
Strings could be used for most of the same purposes, but an
important characteristic of symbols makes comparisons between
symbols much more efficient.
This characteristic is that two symbols with the same name are
identical in the sense of <tt>eq?</tt>.
The reason is that the Scheme reader (invoked by <tt>get-datum</tt> and <tt>read</tt>)
and the procedure <tt>string-&gt;symbol</tt> catalog symbols in an internal
<a name="./objects:s267"></a>symbol table and always return the same symbol whenever the same name is
encountered.
Thus, no character-by-character comparison is needed, as would be
needed to compare two strings.

<p>
The property that two symbols may be compared quickly for equivalence
makes them ideally suited for use as identifiers in the representation
of programs, allowing fast comparison of identifiers.
This property also makes symbols useful for a variety of other
purposes.
For example, symbols might be used as messages passed between
procedures, labels for list-structured records, or names for objects
stored in an association list (see <tt>assq</tt> in Section&nbsp;<a href="objects.html#g109">6.3</a>).

<p>
Symbols are written without double quotes or other bracketing
characters.
Parentheses, double quotes, spaces, and most other characters with a
special meaning to the Scheme reader are not allowed within the printed
representation of a symbol.
These and any other Unicode character may appear anywhere within the
printed representation of a symbol with the syntax <tt>#\x<i>n</i>;</tt>,
where <tt><i>n</i></tt> consists of one or more hexadecimal digits and represents
a valid Unicode scalar value.

<p>
The grammar for symbols on page&nbsp;<a href="grammar.html#grammar:symbols">458</a> gives a
precise definition of the syntax of symbols.


<p>
<a name="./objects:s268"></a><span class=formdef><b>procedure</b>: <tt>(symbol=?&nbsp;<i>symbol<sub>1</sub></i>&nbsp;<i>symbol<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the two symbols are the same, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>Symbols can also be compared with <tt>eq?</tt>, which is typically more
efficient than <tt>symbol=?</tt>.

<p>

<p><tt>(symbol=?&nbsp;'a&nbsp;'a)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(symbol=?&nbsp;'a&nbsp;(string-&gt;symbol&nbsp;"a"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(symbol=?&nbsp;'a&nbsp;'b)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s269"></a><span class=formdef><b>procedure</b>: <tt>(string-&gt;symbol&nbsp;<i>string</i>)</tt></span>
<br>
<b>returns: </b>a symbol whose name is <tt><i>string</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>string-&gt;symbol</tt> records all symbols it creates in an internal table
that it shares with the system reader.
If a symbol whose name is equivalent to string (according to the predicate
<tt>string=?</tt>) already exists in the table, this symbol is returned.
Otherwise, a new symbol is created with <tt><i>string</i></tt> as its name; this
symbol is entered into the table and returned.

<p>
The effect of modifying a string after it is used as an argument to
<tt>string-&gt;symbol</tt> is unspecified.

<p>

<p><tt>(string-&gt;symbol&nbsp;"x")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;x
<br>
<br>
(eq?&nbsp;(string-&gt;symbol&nbsp;"x")&nbsp;'x)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq?&nbsp;(string-&gt;symbol&nbsp;"X")&nbsp;'x)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f
<br>
<br>
(eq?&nbsp;(string-&gt;symbol&nbsp;"x")<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol&nbsp;"x"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(string-&gt;symbol&nbsp;"()")&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;\x28;\x29;</tt>
<p><a name="./objects:s270"></a><span class=formdef><b>procedure</b>: <tt>(symbol-&gt;string&nbsp;<i>symbol</i>)</tt></span>
<br>
<b>returns: </b>a string, the name of <tt><i>symbol</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The string returned by <tt>symbol-&gt;string</tt> should be treated as
immutable.
Unpredictable behavior can result if a string passed to
<tt>string-&gt;symbol</tt> is altered with
<tt>string-set!</tt> or by any other means.

<p>

<p><tt>(symbol-&gt;string&nbsp;'xyz)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"xyz"<br>

(symbol-&gt;string&nbsp;'Hi)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"Hi"<br>

(symbol-&gt;string&nbsp;(string-&gt;symbol&nbsp;"()"))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"()"</tt>
<p>
<h3><a name="g118"></a><a name="./objects:h12"></a>Section 6.12. Booleans<a name="SECTMISCBOOLEANS"></a></h3>



<p>
While every Scheme object has a truth value when used in a conditional
context, with every object but <tt>#f</tt> counting as true,
Scheme provides the dedicated true value <tt>#t</tt> for use when
a value of an expression should convey nothing more than that it is true.

<p>
<a name="./objects:s271"></a><span class=formdef><b>procedure</b>: <tt>(boolean=?&nbsp;<i>boolean<sub>1</sub></i>&nbsp;<i>boolean<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if the two booleans are the same, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The boolean values <tt>#t</tt> and <tt>#f</tt> may also be compared with
<tt>eq?</tt>, which is typically more efficient than <tt>boolean=?</tt>.

<p>

<p><tt>(boolean=?&nbsp;#t&nbsp;#t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(boolean=?&nbsp;#t&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(boolean=?&nbsp;#t&nbsp;(&lt;&nbsp;3&nbsp;4))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>
<h3><a name="g119"></a><a name="./objects:h13"></a>Section 6.13. Hashtables<a name="SECTHASHTABLES"></a></h3>



<p>
<a name="./objects:s272"></a><a name="./objects:s273"></a>Hashtables represent sets of associations between
arbitrary Scheme values.
They serve essentially the same purpose as association lists (see page
&nbsp;<a href="objects.html#page:assq">165</a>) but are typically much faster when large numbers
of associations are involved.

<p>
<a name="./objects:s274"></a><span class=formdef><b>procedure</b>: <tt>(make-eq-hashtable)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-eq-hashtable&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>a new mutable eq hashtable
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>size</i></tt> is provided, it must be a nonnegative exact integer
indicating approximately how many elements the hashtable should
initially hold.
Hashtables grow as needed, but when the hashtable grows it generally must
rehash all of the existing elements.
Providing a nonzero <tt><i>size</i></tt> can help limit the amount of rehashing
that must be done as the table is initially populated.

<p>
An eq hashtable compares keys using the <tt>eq?</tt> (pointer equality)
procedure and typically employs a hash function based on object addresses.
Its hash and equivalence functions are suitable for any Scheme object.

<p>

<p><tt>(define&nbsp;ht1&nbsp;(make-eq-hashtable))<br>

(define&nbsp;ht2&nbsp;(make-eq-hashtable&nbsp;32))</tt>
<p><a name="./objects:s275"></a><span class=formdef><b>procedure</b>: <tt>(make-eqv-hashtable)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-eqv-hashtable&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>a new mutable eqv hashtable
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>size</i></tt> is provided, it must be a nonnegative exact integer
indicating approximately how many elements the hashtable should
initially hold.
Hashtables grow as needed, but when the hashtable grows it generally must
rehash all of the existing elements.
Providing a nonzero <tt><i>size</i></tt> can help limit the amount of rehashing
that must be done as the table is initially populated.

<p>
An eqv hashtable compares keys using the <tt>eqv?</tt>
procedure and typically employs a hash function based on object addresses
for objects that are identifiable with <tt>eq?</tt>.
Its hash and equivalence functions are suitable for any Scheme object.


<p>
<a name="./objects:s276"></a><span class=formdef><b>procedure</b>: <tt>(make-hashtable&nbsp;<i>hash</i>&nbsp;<i>equiv?</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(make-hashtable&nbsp;<i>hash</i>&nbsp;<i>equiv?</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>a new mutable hashtable
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p><tt><i>hash</i></tt> and <tt><i>equiv?</i></tt> must be procedures.
If <tt><i>size</i></tt> is provided, it must be a nonnegative exact integer
indicating approximately how many elements the hashtable should
initially hold.
Hashtables grow as needed, but when the hashtable grows it generally must
rehash all of the existing elements.
Providing a nonzero <tt><i>size</i></tt> can help limit the amount of rehashing
that must be done as the table is initially populated.

<p>
The new hashtable computes hash values using <tt><i>hash</i></tt> and
compares keys using <tt><i>equiv?</i></tt>, neither of which should modify the
hashtable.
<tt><i>equiv?</i></tt> should compare two keys and return false only if the two keys
should be distinguished.
<tt><i>hash</i></tt> should accept a key as an argument and return a nonnegative
exact integer value that is the same each time it is called with arguments
that <tt><i>equiv?</i></tt> does not distinguish.
The <tt><i>hash</i></tt> and <tt><i>equiv?</i></tt> procedures need not accept arbitrary inputs
as long as the hashtable is used only for keys that they do accept,
and both procedures may assume that the keys are immutable as long
as the keys are not modified while they have associations stored in the table.
The hashtable operation may call <tt><i>hash</i></tt> and <tt><i>equiv?</i></tt> once,
not at all, or multiple times for each hashtable operation.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-hashtable&nbsp;string-hash&nbsp;string=?))</tt>
<p><a name="./objects:s277"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-mutable?&nbsp;<i>hashtable</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>hashtable</i></tt> is mutable, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p>Hashtables returned by one of the hashtable creation procedures above are
mutable, but those created by <tt>hashtable-copy</tt> may be immutable.
Immutable hashtables cannot be altered by any of the procedures
<tt>hashtable-set!</tt>, <tt>hashtable-update!</tt>,
<tt>hashtable-delete!</tt>, or <tt>hashtable-clear!</tt>.

<p>

<p><tt>(hashtable-mutable?&nbsp;(make-eq-hashtable))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(hashtable-mutable?&nbsp;(hashtable-copy&nbsp;(make-eq-hashtable)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s278"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-hash-function&nbsp;<i>hashtable</i>)</tt></span>
<br>
<b>returns: </b>the hash function associated with <tt><i>hashtable</i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(hashtable-equivalence-function&nbsp;<i>hashtable</i>)</tt></span>
<br>
<b>returns: </b>the equivalence function associated with <tt><i>hashtable</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p><tt>hashtable-hash-function</tt> returns <tt>#f</tt> for eq and eqv hashtables.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(hashtable-hash-function&nbsp;ht)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(eq?&nbsp;(hashtable-equivalence-function&nbsp;ht)&nbsp;eq?)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(define&nbsp;ht&nbsp;(make-hashtable&nbsp;string-hash&nbsp;string=?))<br>

(eq?&nbsp;(hashtable-hash-function&nbsp;ht)&nbsp;string-hash)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(eq?&nbsp;(hashtable-equivalence-function&nbsp;ht)&nbsp;string=?)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s279"></a><span class=formdef><b>procedure</b>: <tt>(equal-hash&nbsp;<i>obj</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-hash&nbsp;<i>string</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(string-ci-hash&nbsp;<i>string</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(symbol-hash&nbsp;<i>symbol</i>)</tt></span>
<br>
<b>returns: </b>an exact nonnegative integer hash value
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p>These procedures are hash functions suitable for use with the appropriate
Scheme predicate: <tt>equal?</tt> for <tt>equal-hash</tt>, <tt>string=?</tt>
for <tt>string-hash</tt>, <tt>string-ci=?</tt> for <tt>string-ci-hash</tt>,
and <tt>symbol=?</tt> (or eq?) for <tt>symbol-hash</tt>.
The hash values returned by <tt>equal-hash</tt>, <tt>string-hash</tt>,
and <tt>string-ci-hash</tt> are typically dependent on the current structure
and contents of the input values and are thus unsuitable if keys
are modified while they have associations in a hashtable.


<p>
<a name="./objects:s280"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-set!&nbsp;<i>hashtable</i>&nbsp;<i>key</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable hashtable.
<tt><i>key</i></tt> should be an appropriate key for the hashtable's
hash and equivalence functions.
<tt><i>obj</i></tt> may be any Scheme object.

<p>
<tt>hashtable-set!</tt> associates <tt><i>key</i></tt>
with <tt><i>obj</i></tt> in <tt><i>hashtable</i></tt>, replacing the
existing association, if any.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(hashtable-set!&nbsp;ht&nbsp;'a&nbsp;73)</tt>
<p><a name="./objects:s281"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-ref&nbsp;<i>hashtable</i>&nbsp;<i>key</i>&nbsp;<i>default</i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p><tt><i>key</i></tt> should be an appropriate key for the hashtable's
hash and equivalence functions.
<tt><i>default</i></tt> may be any Scheme object.

<p>
<tt>hashtable-ref</tt> returns the value
associated with <tt><i>key</i></tt> in <tt><i>hashtable</i></tt>.
If no value is associated with <tt><i>key</i></tt> in <tt><i>hashtable</i></tt>,
<tt>hashtable-ref</tt> returns <tt><i>default</i></tt>.

<p>

<p><tt>(define&nbsp;p1&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(define&nbsp;p2&nbsp;(cons&nbsp;'a&nbsp;'b))
<br>
<br>
(define&nbsp;eqht&nbsp;(make-eq-hashtable))<br>

(hashtable-set!&nbsp;eqht&nbsp;p1&nbsp;73)<br>

(hashtable-ref&nbsp;eqht&nbsp;p1&nbsp;55)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;73<br>

(hashtable-ref&nbsp;eqht&nbsp;p2&nbsp;55)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;55
<br>
<br>
(define&nbsp;equalht&nbsp;(make-hashtable&nbsp;equal-hash&nbsp;equal?))<br>

(hashtable-set!&nbsp;equalht&nbsp;p1&nbsp;73)<br>

(hashtable-ref&nbsp;equalht&nbsp;p1&nbsp;55)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;73<br>

(hashtable-ref&nbsp;equalht&nbsp;p2&nbsp;55)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;73</tt>
<p><a name="./objects:s282"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-contains?&nbsp;<i>hashtable</i>&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if an association for <tt><i>key</i></tt> exists in <tt><i>hashtable</i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p><tt><i>key</i></tt> should be an appropriate key for the hashtable's
hash and equivalence functions.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;p1&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(define&nbsp;p2&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(hashtable-set!&nbsp;ht&nbsp;p1&nbsp;73)<br>

(hashtable-contains?&nbsp;ht&nbsp;p1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(hashtable-contains?&nbsp;ht&nbsp;p2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s283"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-update!&nbsp;<i>hashtable</i>&nbsp;<i>key</i>&nbsp;<i>procedure</i>&nbsp;<i>default</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable hashtable.
<tt><i>key</i></tt> should be an appropriate key for the hashtable's
hash and equivalence functions.
<tt><i>default</i></tt> may be any Scheme object.
<tt><i>procedure</i></tt> should accept one argument, should return one value, and should
not modify <tt><i>hashtable</i></tt>.

<p>
<tt>hashtable-update!</tt> applies <tt><i>procedure</i></tt> to the value associated with
<tt><i>key</i></tt> in <tt><i>hashtable</i></tt>, or to <tt><i>default</i></tt> if no value is associated with
<tt><i>key</i></tt> in <tt><i>hashtable</i></tt>.
If <tt><i>procedure</i></tt> returns, <tt>hashtable-update!</tt> associates <tt><i>key</i></tt>
with the value returned by <tt><i>procedure</i></tt>, replacing the old association,
if any.

<p>
A version of <tt>hashtable-update!</tt> that does not verify that it receives
arguments of the proper type might be defined as follows.

<p>

<p><tt>(define&nbsp;hashtable-update!<br>

&nbsp;&nbsp;(lambda&nbsp;(ht&nbsp;key&nbsp;proc&nbsp;value)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(hashtable-set!&nbsp;ht&nbsp;key<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(proc&nbsp;(hashtable-ref&nbsp;ht&nbsp;key&nbsp;value)))))</tt>
<p>An implementation may, however, be able to implement
<tt>hashtable-update!</tt> more efficiently by avoiding multiple
hash computations and hashtable lookups.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(hashtable-update!&nbsp;ht&nbsp;'a<br>

&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;2))<br>

&nbsp;&nbsp;55)<br>

(hashtable-ref&nbsp;ht&nbsp;'a&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;110<br>

(hashtable-update!&nbsp;ht&nbsp;'a<br>

&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;2))<br>

&nbsp;&nbsp;0)<br>

(hashtable-ref&nbsp;ht&nbsp;'a&nbsp;0)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;220</tt>
<p><a name="./objects:s284"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-delete!&nbsp;<i>hashtable</i>&nbsp;<i>key</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable hashtable.
<tt><i>key</i></tt> should be an appropriate key for the hashtable's
hash and equivalence functions.

<p>
<tt>hashtable-delete!</tt> drops any association
for <tt><i>key</i></tt> from <tt><i>hashtable</i></tt>.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;p1&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(define&nbsp;p2&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(hashtable-set!&nbsp;ht&nbsp;p1&nbsp;73)<br>

(hashtable-contains?&nbsp;ht&nbsp;p1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(hashtable-delete!&nbsp;ht&nbsp;p1)<br>

(hashtable-contains?&nbsp;ht&nbsp;p1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(hashtable-contains?&nbsp;ht&nbsp;p2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(hashtable-delete!&nbsp;ht&nbsp;p2)</tt>
<p><a name="./objects:s285"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-size&nbsp;<i>hashtable</i>)</tt></span>
<br>
<b>returns: </b>number of entries in <tt><i>hashtable</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;p1&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(define&nbsp;p2&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(hashtable-size&nbsp;ht)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(hashtable-set!&nbsp;ht&nbsp;p1&nbsp;73)<br>

(hashtable-size&nbsp;ht)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;1<br>

(hashtable-delete!&nbsp;ht&nbsp;p1)<br>

(hashtable-size&nbsp;ht)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0</tt>
<p><a name="./objects:s286"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-copy&nbsp;<i>hashtable</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(hashtable-copy&nbsp;<i>hashtable</i>&nbsp;<i>mutable?</i>)</tt></span>
<br>
<b>returns: </b>a new hashtable containing the same entries as <tt><i>hashtable</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p>If <tt><i>mutable?</i></tt> is present and not false, the copy is mutable;
otherwise, the copy is immutable.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;p1&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(hashtable-set!&nbsp;ht&nbsp;p1&nbsp;"c")<br>

(define&nbsp;ht-copy&nbsp;(hashtable-copy&nbsp;ht))<br>

(hashtable-mutable?&nbsp;ht-copy)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(hashtable-delete!&nbsp;ht&nbsp;p1)<br>

(hashtable-ref&nbsp;ht&nbsp;p1&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(hashtable-delete!&nbsp;ht-copy&nbsp;p1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;not&nbsp;mutable</i><br>

(hashtable-ref&nbsp;ht-copy&nbsp;p1&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;"c"</tt>
<p><a name="./objects:s287"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-clear!&nbsp;<i>hashtable</i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(hashtable-clear!&nbsp;<i>hashtable</i>&nbsp;<i>size</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p><tt><i>hashtable</i></tt> must be a mutable hashtable.
If <tt><i>size</i></tt> is provided, it must be a nonnegative exact integer.

<p>
<tt>hashtable-clear!</tt> removes all entries from <tt><i>hashtable</i></tt>.
If size is provided, the hashtable is reset to the given size,
as if newly created by one of the hashtable creation operations
with size argument <tt><i>size</i></tt>.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;p1&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(define&nbsp;p2&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(hashtable-set!&nbsp;ht&nbsp;p1&nbsp;"first")<br>

(hashtable-set!&nbsp;ht&nbsp;p2&nbsp;"second")<br>

(hashtable-size&nbsp;ht)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2<br>

(hashtable-clear!&nbsp;ht)<br>

(hashtable-size&nbsp;ht)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;0<br>

(hashtable-ref&nbsp;ht&nbsp;p1&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s288"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-keys&nbsp;<i>hashtable</i>)</tt></span>
<br>
<b>returns: </b>a vector containing the keys in <tt><i>hashtable</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p>The keys may appear in any order in the returned vector.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;p1&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(define&nbsp;p2&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(hashtable-set!&nbsp;ht&nbsp;p1&nbsp;"one")<br>

(hashtable-set!&nbsp;ht&nbsp;p2&nbsp;"two")<br>

(hashtable-set!&nbsp;ht&nbsp;'q&nbsp;"three")<br>

(hashtable-keys&nbsp;ht)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#((a&nbsp;.&nbsp;b)&nbsp;q&nbsp;(a&nbsp;.&nbsp;b))</tt>
<p><a name="./objects:s289"></a><span class=formdef><b>procedure</b>: <tt>(hashtable-entries&nbsp;<i>hashtable</i>)</tt></span>
<br>
<b>returns: </b>two vectors: one of keys and a second of values
<br>
<b>libraries: </b><tt>(rnrs&nbsp;hashtables)</tt>, <tt>(rnrs)</tt>

<p><tt>hashtable-entries</tt> returns two values.
The first is a vector containing the keys in <tt><i>hashtable</i></tt>, and the second
is a vector containing the corresponding values.
The keys and values may appear in any order, but the order is the same
for the keys and for the corresponding values.

<p>

<p><tt>(define&nbsp;ht&nbsp;(make-eq-hashtable))<br>

(define&nbsp;p1&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(define&nbsp;p2&nbsp;(cons&nbsp;'a&nbsp;'b))<br>

(hashtable-set!&nbsp;ht&nbsp;p1&nbsp;"one")<br>

(hashtable-set!&nbsp;ht&nbsp;p2&nbsp;"two")<br>

(hashtable-set!&nbsp;ht&nbsp;'q&nbsp;"three")<br>

(hashtable-entries&nbsp;ht)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#((a&nbsp;.&nbsp;b)&nbsp;q&nbsp;(a&nbsp;.&nbsp;b))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="gifs/ghostRightarrow.gif">&nbsp;#("two"&nbsp;"three"&nbsp;"one")</tt>
<p>
<h3><a name="g120"></a><a name="./objects:h14"></a>Section 6.14. Enumerations<a name="SECTENUMERATIONS"></a></h3>



<p>
Enumerations are ordered sets of symbols, typically used to name and manipulate
options, as with the buffer modes and file options that may be specified when
files are created.

<p>
<a name="./objects:s290"></a><span class=formdef><b>syntax</b>: <tt>(define-enumeration&nbsp;<i>name</i>&nbsp;(<i>symbol</i>&nbsp;...)&nbsp;<i>constructor</i>)</tt></span>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;enums)</tt>, <tt>(rnrs)</tt>

<p>A <tt>define-enumeration</tt> form is a definition and can appear
anywhere any other definition can appear.

<p>
The <tt>define-enumeration</tt> syntax creates a new enumeration set with
the specified symbols in the specified order forming the enumeration's universe.
It defines a new syntactic form named by <tt><i>name</i></tt> that may be used to verify
that a symbol is in the universe.
If <tt><i>x</i></tt> is in the universe, <tt>(<i>name <i>x</i></i>)</tt> evaluates to
<tt><i>x</i></tt>.
It is a syntax violation if <tt><i>x</i></tt> is not in the universe.

<p>
<tt>define-enumeration</tt> also defines
a new syntactic form named by <tt><i>constructor</i></tt> that may be used to create
subsets of the enumeration type.
If <tt><i>x</i>&nbsp;...</tt> are each in the universe,
<tt><i>(constructor <i>x</i></i> ...)</tt> evaluates to an enumeration set
containing <tt><i>x</i>&nbsp;...</tt>.
Otherwise, it is a syntax violation.
The same symbol may appear more than once in <tt><i>x</i>&nbsp;...</tt>,
but the resulting set contains only one occurrence of the symbol.

<p>

<p><tt>(define-enumeration&nbsp;weather-element<br>

&nbsp;&nbsp;(hot&nbsp;warm&nbsp;cold&nbsp;sunny&nbsp;rainy&nbsp;snowy&nbsp;windy)<br>

&nbsp;&nbsp;weather)
<br>
<br>
(weather-element&nbsp;hot)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;hot<br>

(weather-element&nbsp;fun)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>syntax&nbsp;violation</i><br>

(weather&nbsp;hot&nbsp;sunny&nbsp;windy)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#&lt;enum-set&gt;<br>

(enum-set-&gt;list&nbsp;(weather&nbsp;rainy&nbsp;cold&nbsp;rainy))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(cold&nbsp;rainy)</tt>
<p><a name="./objects:s291"></a><span class=formdef><b>procedure</b>: <tt>(make-enumeration&nbsp;<i>symbol-list</i>)</tt></span>
<br>
<b>returns: </b>an enumeration set
<br>
<b>libraries: </b><tt>(rnrs&nbsp;enums)</tt>, <tt>(rnrs)</tt>

<p>This procedure creates a new enumeration type whose universe comprises
the elements of <tt><i>symbol-list</i></tt>, which must be
a list of symbols, in the order of their first appearance in the list.
It returns the universe of the new enumeration type as an enumeration
set.

<p>

<p><tt>(define&nbsp;positions&nbsp;(make-enumeration&nbsp;'(top&nbsp;bottom&nbsp;above&nbsp;top&nbsp;beside)))<br>

(enum-set-&gt;list&nbsp;positions)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(top&nbsp;bottom&nbsp;above&nbsp;beside)</tt>
<p><a name="./objects:s292"></a><span class=formdef><b>procedure</b>: <tt>(enum-set-constructor&nbsp;<i>enum-set</i>)</tt></span>
<br>
<b>returns: </b>an enumeration-set construction procedure
<br>
<b>libraries: </b><tt>(rnrs&nbsp;enums)</tt>, <tt>(rnrs)</tt>

<p>This procedure returns a procedure <tt><i>p</i></tt> that may be used to create
subsets of the universe of <tt><i>enum-set</i></tt>.
<tt><i>p</i></tt> must be passed a list of symbols, and each element of the list
must be an element of the universe of <tt><i>enum-set</i></tt>.
The enumeration set returned by <tt><i>p</i></tt> contains all and only the
symbols in the list it is passed.
The value returned by <tt><i>p</i></tt> may contain elements not in <tt><i>enum-set</i></tt>
if the universe of <tt><i>enum-set</i></tt> contains those elements.

<p>

<p><tt>(define&nbsp;e1&nbsp;(make-enumeration&nbsp;'(one&nbsp;two&nbsp;three&nbsp;four)))<br>

(define&nbsp;p1&nbsp;(enum-set-constructor&nbsp;e1))<br>

(define&nbsp;e2&nbsp;(p1&nbsp;'(one&nbsp;three)))<br>

(enum-set-&gt;list&nbsp;e2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(one&nbsp;three)<br>

(define&nbsp;p2&nbsp;(enum-set-constructor&nbsp;e2))<br>

(define&nbsp;e3&nbsp;(p2&nbsp;'(one&nbsp;two&nbsp;four)))<br>

(enum-set-&gt;list&nbsp;e3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(one&nbsp;two&nbsp;four)</tt>
<p><a name="./objects:s293"></a><span class=formdef><b>procedure</b>: <tt>(enum-set-universe&nbsp;<i>enum-set</i>)</tt></span>
<br>
<b>returns: </b>the universe of <tt><i>enum-set</i></tt>, as an enumeration set
<br>
<b>libraries: </b><tt>(rnrs&nbsp;enums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(define&nbsp;e1&nbsp;(make-enumeration&nbsp;'(a&nbsp;b&nbsp;c&nbsp;a&nbsp;b&nbsp;c&nbsp;d)))<br>

(enum-set-&gt;list&nbsp;(enum-set-universe&nbsp;e1))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)<br>

(define&nbsp;e2&nbsp;((enum-set-constructor&nbsp;e1)&nbsp;'(c)))<br>

(enum-set-&gt;list&nbsp;(enum-set-universe&nbsp;e2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)</tt>
<p><a name="./objects:s294"></a><span class=formdef><b>procedure</b>: <tt>(enum-set-&gt;list&nbsp;<i>enum-set</i>)</tt></span>
<br>
<b>returns: </b>a list of the elements of <tt><i>enum-set</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;enums)</tt>, <tt>(rnrs)</tt>

<p>The symbols in the resulting list appear in the order given to
them when the enumeration type of <tt>enum-set</tt> was created.

<p>

<p><tt>(define&nbsp;e1&nbsp;(make-enumeration&nbsp;'(a&nbsp;b&nbsp;c&nbsp;a&nbsp;b&nbsp;c&nbsp;d)))<br>

(enum-set-&gt;list&nbsp;e1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)<br>

(define&nbsp;e2&nbsp;((enum-set-constructor&nbsp;e1)&nbsp;'(d&nbsp;c&nbsp;a&nbsp;b)))<br>

(enum-set-&gt;list&nbsp;e2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)</tt>
<p><a name="./objects:s295"></a><span class=formdef><b>procedure</b>: <tt>(enum-set-subset?&nbsp;<i>enum-set<sub>1</sub></i>&nbsp;<i>enum-set<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>enum-set<sub>1</sub></i></tt> is a subset of <tt><i>enum-set<sub>2</sub></i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;enums)</tt>, <tt>(rnrs)</tt>

<p>An enumeration set <tt><i>enum-set<sub>1</sub></i></tt> is a subset of an enumeration set <tt><i>enum-set<sub>2</sub></i></tt>
if and only if the universe of <tt><i>enum-set<sub>1</sub></i></tt> is a subset of the universe of <tt><i>enum-set<sub>2</sub></i></tt>
and each element of <tt><i>enum-set<sub>1</sub></i></tt> is an element of <tt><i>enum-set<sub>2</sub></i></tt>.

<p>

<p><tt>(define&nbsp;e1&nbsp;(make-enumeration&nbsp;'(a&nbsp;b&nbsp;c)))<br>

(define&nbsp;e2&nbsp;(make-enumeration&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)))<br>

(enum-set-subset?&nbsp;e1&nbsp;e2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(enum-set-subset?&nbsp;e2&nbsp;e1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(define&nbsp;e3&nbsp;((enum-set-constructor&nbsp;e2)&nbsp;'(a&nbsp;c)))<br>

(enum-set-subset?&nbsp;e3&nbsp;e1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(enum-set-subset?&nbsp;e3&nbsp;e2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p><a name="./objects:s296"></a><span class=formdef><b>procedure</b>: <tt>(enum-set=?&nbsp;<i>enum-set<sub>1</sub></i>&nbsp;<i>enum-set<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>enum-set<sub>1</sub></i></tt> and <tt><i>enum-set<sub>2</sub></i></tt> are equivalent, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;enums)</tt>, <tt>(rnrs)</tt>

<p>Two enumeration sets <tt><i>enum-set<sub>1</sub></i></tt> and <tt><i>enum-set<sub>2</sub></i></tt> are equivalent if each is
a subset of the other.

<p>

<p><tt>(define&nbsp;e1&nbsp;(make-enumeration&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d)))<br>

(define&nbsp;e2&nbsp;(make-enumeration&nbsp;'(b&nbsp;d&nbsp;c&nbsp;a)))<br>

(enum-set=?&nbsp;e1&nbsp;e2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(define&nbsp;e3&nbsp;((enum-set-constructor&nbsp;e1)&nbsp;'(a&nbsp;c)))<br>

(define&nbsp;e4&nbsp;((enum-set-constructor&nbsp;e2)&nbsp;'(a&nbsp;c)))<br>

(enum-set=?&nbsp;e3&nbsp;e4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(enum-set=?&nbsp;e3&nbsp;e2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><tt>enum-set=?</tt> could be defined in terms of <tt>enum-set-subset?</tt> as follows.

<p>

<p><tt>(define&nbsp;enum-set=?<br>

&nbsp;&nbsp;(lambda&nbsp;(e1&nbsp;e2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(enum-set-subset?&nbsp;e1&nbsp;e2)&nbsp;(enum-set-subset?&nbsp;e2&nbsp;e1))))</tt>
<p><a name="./objects:s297"></a><span class=formdef><b>procedure</b>: <tt>(enum-set-member?&nbsp;<i>symbol</i>&nbsp;<i>enum-set</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if symbol is an element of <tt><i>enum-set</i></tt>, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;enums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(define&nbsp;e1&nbsp;(make-enumeration&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e)))<br>

(define&nbsp;e2&nbsp;((enum-set-constructor&nbsp;e1)&nbsp;'(d&nbsp;b)))<br>

(enum-set-member?&nbsp;'c&nbsp;e1)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(enum-set-member?&nbsp;'c&nbsp;e2)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f</tt>
<p><a name="./objects:s298"></a><span class=formdef><b>procedure</b>: <tt>(enum-set-union&nbsp;<i>enum-set<sub>1</sub></i>&nbsp;<i>enum-set<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the union of <tt><i>enum-set<sub>1</sub></i></tt> and <tt><i>enum-set<sub>2</sub></i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(enum-set-intersection&nbsp;<i>enum-set<sub>1</sub></i>&nbsp;<i>enum-set<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the intersection of <tt><i>enum-set<sub>1</sub></i></tt> and <tt><i>enum-set<sub>2</sub></i></tt>
<br>
<span class=formdef><b>procedure</b>: <tt>(enum-set-difference&nbsp;<i>enum-set<sub>1</sub></i>&nbsp;<i>enum-set<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the difference of <tt><i>enum-set<sub>1</sub></i></tt> and <tt><i>enum-set<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;enums)</tt>, <tt>(rnrs)</tt>

<p><tt><i>enum-set<sub>1</sub></i></tt> and <tt><i>enum-set<sub>2</sub></i></tt> must have the same enumeration type.
Each procedure returns a new enumeration set representing the union, intersection,
or difference of the two sets.

<p>

<p><tt>(define&nbsp;e1&nbsp;(make-enumeration&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d)))<br>

(define&nbsp;e2&nbsp;((enum-set-constructor&nbsp;e1)&nbsp;'(a&nbsp;c)))<br>

(define&nbsp;e3&nbsp;((enum-set-constructor&nbsp;e1)&nbsp;'(b&nbsp;c)))<br>

(enum-set-&gt;list&nbsp;(enum-set-union&nbsp;e2&nbsp;e3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)<br>

(enum-set-&gt;list&nbsp;(enum-set-intersection&nbsp;e2&nbsp;e3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(c)<br>

(enum-set-&gt;list&nbsp;(enum-set-difference&nbsp;e2&nbsp;e3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a)<br>

(enum-set-&gt;list&nbsp;(enum-set-difference&nbsp;e3&nbsp;e2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b)<br>

(define&nbsp;e4&nbsp;(make-enumeration&nbsp;'(b&nbsp;d&nbsp;c&nbsp;a)))<br>

(enum-set-union&nbsp;e1&nbsp;e4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;different&nbsp;enumeration&nbsp;types</i></tt>
<p><a name="./objects:s299"></a><span class=formdef><b>procedure</b>: <tt>(enum-set-complement&nbsp;<i>enum-set</i>)</tt></span>
<br>
<b>returns: </b>the complement of <tt><i>enum-set</i></tt> relative to its universe
<br>
<b>libraries: </b><tt>(rnrs&nbsp;enums)</tt>, <tt>(rnrs)</tt>

<p>
<p><tt>
(define&nbsp;e1&nbsp;(make-enumeration&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d)))<br>

(enum-set-&gt;list&nbsp;(enum-set-complement&nbsp;e1))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;()<br>

(define&nbsp;e2&nbsp;((enum-set-constructor&nbsp;e1)&nbsp;'(a&nbsp;c)))<br>

(enum-set-&gt;list&nbsp;(enum-set-complement&nbsp;e2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;d)</tt>
<p><a name="./objects:s300"></a><span class=formdef><b>procedure</b>: <tt>(enum-set-projection&nbsp;<i>enum-set<sub>1</sub></i>&nbsp;<i>enum-set<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>the projection of <tt><i>enum-set<sub>1</sub></i></tt> into the universe of <tt><i>enum-set<sub>2</sub></i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;enums)</tt>, <tt>(rnrs)</tt>

<p>Any elements of <tt><i>enum-set<sub>1</sub></i></tt> not in the universe of <tt><i>enum-set<sub>2</sub></i></tt> are dropped.
The result is of the same enumeration type as <tt><i>enum-set<sub>2</sub></i></tt>.

<p>

<p><tt>(define&nbsp;e1&nbsp;(make-enumeration&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d)))<br>

(define&nbsp;e2&nbsp;(make-enumeration&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d&nbsp;e&nbsp;f&nbsp;g)))<br>

(define&nbsp;e3&nbsp;((enum-set-constructor&nbsp;e1)&nbsp;'(a&nbsp;d)))<br>

(define&nbsp;e4&nbsp;((enum-set-constructor&nbsp;e2)&nbsp;'(a&nbsp;c&nbsp;e&nbsp;g)))<br>

(enum-set-&gt;list&nbsp;(enum-set-projection&nbsp;e4&nbsp;e3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;c)<br>

(enum-set-&gt;list<br>

&nbsp;&nbsp;(enum-set-union&nbsp;e3<br>

&nbsp;&nbsp;&nbsp;&nbsp;(enum-set-projection&nbsp;e4&nbsp;e3)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;c&nbsp;d)</tt>
<p><a name="./objects:s301"></a><span class=formdef><b>procedure</b>: <tt>(enum-set-indexer&nbsp;<i>enum-set</i>)</tt></span>
<br>
<b>returns: </b>a procedure that returns the index of a symbol in the universe of <tt><i>enum-set</i></tt>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;enums)</tt>, <tt>(rnrs)</tt>

<p><tt>enum-set-indexer</tt> returns a procedure <tt><i>p</i></tt> that, when applied to a symbol
in the universe of <tt><i>enum-set</i></tt>, returns the index of the symbol (zero-based) in
the ordered set of symbols that form the universe.
If applied to a symbol not in the universe, <tt><i>p</i></tt> returns <tt>#f</tt>.

<p>

<p><tt>(define&nbsp;e1&nbsp;(make-enumeration&nbsp;'(a&nbsp;b&nbsp;c&nbsp;d)))<br>

(define&nbsp;e2&nbsp;((enum-set-constructor&nbsp;e1)&nbsp;'(a&nbsp;d)))<br>

(define&nbsp;p&nbsp;(enum-set-indexer&nbsp;e2))<br>

(list&nbsp;(p&nbsp;'a)&nbsp;(p&nbsp;'c)&nbsp;(p&nbsp;'e))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(0&nbsp;2&nbsp;#f)</tt>
<p>



<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
