<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Syntactic Extension</title>
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g133"></a>
<a name="./syntax:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch8.png"><img src="canned/jph.png">
</div>
<h1>Chapter 8. Syntactic Extension<a name="CHPTSYNTAX"></a></h1>





<p>
<a name="./syntax:s0"></a><a name="./syntax:s1"></a><i>Syntactic extensions</i>,
or <a name="./syntax:s2"></a><i>macros</i>, are used to simplify and regularize
repeated patterns in a program, to introduce syntactic forms with
new evaluation rules, and to perform transformations that help make
programs more efficient.

<p>
A syntactic extension most often takes the form
<tt>(<i>keyword</i>&nbsp;<i>subform</i>&nbsp;...)</tt>,
where <tt><i>keyword</i></tt> is the identifier that names the syntactic
extension.
The syntax of each <tt><i>subform</i></tt> varies from one syntactic
extension to another.
Syntactic extensions can also take the form of improper lists
or even singleton identifiers.

<p>
New syntactic extensions are defined by associating keywords with
transformation procedures, or <i>transformers</i>.
Syntactic extensions are defined using
<a name="./syntax:s3"></a><tt>define-syntax</tt> forms or
using
<a name="./syntax:s4"></a><tt>let-syntax</tt> or
<a name="./syntax:s5"></a><tt>letrec-syntax</tt>.
Transformers may be created using
<a name="./syntax:s6"></a><tt>syntax-rules</tt>, which
allows simple pattern-based transformations to be performed.
They may also be ordinary procedures that accept one argument and
perform arbitrary computations.
In this case, <a name="./syntax:s7"></a><tt>syntax-case</tt> is normally used
to destructure the input and
<a name="./syntax:s8"></a><tt>syntax</tt> is normally
used to construct the output.
The <a name="./syntax:s9"></a><tt>identifier-syntax</tt>
form and
<a name="./syntax:s10"></a><tt>make-variable-transformer</tt>
procedure allow the creation of transformers that match singleton
identifiers and assignments to those identifiers, the former being
restricted to simple patterns like <tt>syntax-rules</tt> and the
latter allowing arbitrary computations to be performed.

<p>
Syntactic extensions are expanded into core forms at the start of
evaluation (before compilation or interpretation) by a syntax <i>expander</i>.
If the expander encounters a syntactic extension, it invokes
the associated transformer to expand the syntactic extension, then
repeats the expansion process for the form returned by the transformer.
If the expander encounters a core syntactic form, it recursively
processes the subforms, if any, and reconstructs the form from the
expanded subforms.
Information about identifier bindings is maintained during expansion
to enforce lexical scoping for variables and keywords.

<p>
The syntactic extension mechanisms described in this chapter are part of
the "syntax-case" system.
A portable implementation of the system that also supports libraries
and top-level programs is available at
<a  href=http://www.cs.indiana.edu/syntax-case/>http://www.cs.indiana.edu/syntax-case/</a>.
A description of the motivations behind and implementation of the
system can be found in the article
"Syntactic Abstraction in Scheme"&nbsp;[<a class=citation href="bibliography.html#g230">12</a>].
Additional features that have not yet been standardized, including
<tt>modules</tt>, local <tt>import</tt>, and meta definitions, are
described in the <i>Chez Scheme User's Guide</i>&nbsp;[<a class=citation href="bibliography.html#g227">9</a>].

<p>

<h3><a name="g134"></a><a name="./syntax:h1"></a>Section 8.1. Keyword Bindings<a name="SECTSYNTAXDEFINITIONS"></a></h3>



<p>
This section describes forms that establish
bindings between <a name="./syntax:s11"></a>keywords and transformers.
Keyword bindings may be established within a top-level program
or library body using <tt>define-syntax</tt> and in any local
scope using <tt>define-syntax</tt>, <tt>let-syntax</tt>, or
<tt>letrec-syntax</tt>.

<p>
<a name="./syntax:s12"></a><span class=formdef><b>syntax</b>: <tt>(define-syntax&nbsp;<i>keyword</i>&nbsp;<i>expr</i>)</tt></span>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt><i>expr</i></tt> must evaluate to a transformer.

<p>
The following example defines <tt>let*</tt> as a syntactic extension,
specifying the transformer with <tt>syntax-rules</tt> (see Section&nbsp;<a href="syntax.html#g135">8.2</a>).

<p>

<p><tt>(define-syntax&nbsp;let*<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;(let&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((i1&nbsp;e1)&nbsp;(i2&nbsp;e2)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([i1&nbsp;e1])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;([i2&nbsp;e2]&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...))]))</tt>
<p>All bindings established by a set of internal definitions, whether
keyword or variable definitions, are visible everywhere within the
immediately enclosing body, including within the definitions themselves.
For example, the expression

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(define&nbsp;even?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(=&nbsp;x&nbsp;0)&nbsp;(odd?&nbsp;(-&nbsp;x&nbsp;1)))))<br>

&nbsp;&nbsp;(define-syntax&nbsp;odd?<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;(not&nbsp;(even?&nbsp;x))]))<br>

&nbsp;&nbsp;(even?&nbsp;10))</tt>
<p>is valid and should evaluate to <tt>#t</tt>.

<p>
<a name="body-expansion"></a>The expander processes the initial forms in a <tt>library</tt>, <tt>lambda</tt>, or other
body from left to right.
If it encounters a variable definition, it records the fact that the
defined identifier is a variable but defers expansion of the
right-hand-side expression until after all of the definitions have
been processed.
If it encounters a keyword definition, it expands and evaluates the
right-hand-side expression and binds the keyword to the resulting
transformer.
If it encounters an expression, it fully expands all deferred
right-hand-side expressions along with the current and remaining
body expressions.

<p>
An implication of the left-to-right processing order is that one
internal definition can affect whether a subsequent form is also a
definition.
For example, the expression

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(define-syntax&nbsp;bind-to-zero<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;id)&nbsp;(define&nbsp;id&nbsp;0)]))<br>

&nbsp;&nbsp;(bind-to-zero&nbsp;x)<br>

&nbsp;&nbsp;x)</tt>
<p>evaluates to <tt>0</tt>, regardless of any binding for
<tt>bind-to-zero</tt> that might appear outside of the <tt>let</tt>
expression.


<p>
<a name="./syntax:s13"></a><span class=formdef><b>syntax</b>: <tt>(let-syntax&nbsp;((<i>keyword</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(letrec-syntax&nbsp;((<i>keyword</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>Each <tt><i>expr</i></tt> must evaluate to a transformer.
For <tt>let-syntax</tt> and <tt>letrec-syntax</tt> both, each <tt><i>keyword</i></tt>
is bound within the
forms <tt><i>form<sub>1</sub></i>&nbsp;<i>form<sub>2</sub></i>&nbsp;...</tt>.
For <tt>letrec-syntax</tt> the binding scope also includes each <tt><i>expr</i></tt>.

<p>
<a name="letsyntaximplicitbegin"></a>A <tt>let-syntax</tt> or <tt>letrec-syntax</tt> form may expand into one or more
expressions anywhere expressions are permitted, in which case the
resulting expressions are treated as if enclosed in a <tt>begin</tt>
expression.
It may also expand into zero or more definitions anywhere definitions are permitted,
in which case the definitions are treated as if they appeared in place
of the <tt>let-syntax</tt> or <tt>letrec-syntax</tt> form.

<p>
The following example highlights how <tt>let-syntax</tt>
and <tt>letrec-syntax</tt> differ.

<p>

<p><tt>(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))])<br>

&nbsp;&nbsp;(let-syntax&nbsp;([f&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;x])]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[g&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;(f&nbsp;x)])])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(f&nbsp;1)&nbsp;(g&nbsp;1))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2)
<br>
<br>
(let&nbsp;([f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))])<br>

&nbsp;&nbsp;(letrec-syntax&nbsp;([f&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;x])]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[g&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x)&nbsp;(f&nbsp;x)])])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(f&nbsp;1)&nbsp;(g&nbsp;1))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;1)</tt>
<p>The two expressions are identical except that the <tt>let-syntax</tt> form
in the first expression is a <tt>letrec-syntax</tt> form in the second.
In the first expression, the <tt>f</tt> occurring in <tt>g</tt> refers to
the <tt>let</tt>-bound variable <tt>f</tt>, whereas in the second it refers
to the keyword <tt>f</tt> whose binding is established by the
<tt>letrec-syntax</tt> form.


<p>

<h3><a name="g135"></a><a name="./syntax:h2"></a>Section 8.2. Syntax-Rules Transformers<a name="SECTSYNTAXRULES"></a></h3>



<p>
The <tt>syntax-rules</tt> form described in this
section permits simple transformers to be specified in a
convenient manner.
These transformers may be bound to keywords using the mechanisms
described in Section&nbsp;<a href="syntax.html#g134">8.1</a>.
While it is much less expressive than the mechanism described in
Section&nbsp;<a href="syntax.html#g136">8.3</a>, it is sufficient for defining many common
syntactic extensions.

<p>
<a name="./syntax:s14"></a><span class=formdef><b>syntax</b>: <tt>(syntax-rules&nbsp;(<i>literal</i>&nbsp;...)&nbsp;<i>clause</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a transformer
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>Each <a name="./syntax:s15"></a><tt><i>literal</i></tt> must be an identifier other than
an underscore (&nbsp;<tt>_</tt>&nbsp;) or ellipsis (&nbsp;<tt>...</tt>&nbsp;).
Each clause must take the form below.

<p>

<p><tt>(<i>pattern</i>&nbsp;<i>template</i>)</tt>
<p>Each <tt><i>pattern</i></tt> specifies one possible syntax that the input
form might take, and the corresponding <tt><i>template</i></tt> specifies
how the output should appear.

<p>
<a name="./syntax:s16"></a>Patterns consist of list structure, vector structure,
identifiers, and
constants.
Each identifier within a pattern is either a <tt><i>literal</i></tt>,
a <a name="./syntax:s17"></a><i>pattern variable</i>,
an <a name="./syntax:s18"></a><a name="./syntax:s19"></a><i>underscore</i>,
or an
<a name="./syntax:s20"></a><a name="./syntax:s21"></a><i>ellipsis</i>.
The identifier <tt>_</tt> is an underscore, and
the identifier <tt>...</tt> is an ellipsis.
Any identifier other than <tt>_</tt> or <tt>...</tt> is a literal if it appears
in the list of literals
<tt>(<i>literal</i>&nbsp;...)</tt>;
otherwise, it is a pattern variable.
Literals serve as <a name="./syntax:s22"></a>auxiliary keywords, such as <tt>else</tt> in
<tt>case</tt> and <tt>cond</tt> expressions.
List and vector structure within a pattern specifies the basic structure
required of the input, the underscore and pattern variables specify arbitrary
substructure, and literals and constants specify atomic pieces
that must match exactly.
Ellipses specify repeated occurrences of the subpatterns they
follow.

<p>
<a name="patterns"></a>An input form <tt><i>F</i></tt> matches a pattern <tt><i>P</i></tt> if and only if

<p>
<ul>
<li><tt><i>P</i></tt> is an underscore or pattern variable,

<p>
<li><tt><i>P</i></tt> is a literal identifier
and <tt><i>F</i></tt> is an identifier with
the same binding as determined by the predicate
<tt>free-identifier=?</tt>
(Section&nbsp;<a href="syntax.html#g136">8.3</a>),

<p>
<li><tt><i>P</i></tt> is of the form
<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>
and <tt><i>F</i></tt> is a list of <i>n</i> elements that match <tt><i>P<sub>1</sub></i></tt> through
<tt><i>P<sub>n</sub></i></tt>,

<p>
<li><tt><i>P</i></tt> is of the form
<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>&nbsp;.&nbsp;<i>P<sub>x</sub></i>)</tt>
and <tt><i>F</i></tt> is a list or improper list of <i>n</i> or more elements
whose first <i>n</i> elements match <tt><i>P<sub>1</sub></i></tt> through <tt><i>P<sub>n</sub></i></tt>
and
whose <i>n</i>th cdr matches <tt><i>P<sub>x</sub></i></tt>,

<p>
<li><tt><i>P</i></tt> is of the form
<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>k</sub></i>&nbsp;<i>P<sub>e</sub></i>&nbsp;<i>ellipsis</i>&nbsp;<i>P<sub><i>m</i>+1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>,
where <tt><i>ellipsis</i></tt> is the identifier <tt>...</tt>
and <tt><i>F</i></tt> is a proper list of <i>n</i>
elements whose first <i>k</i> elements match <tt><i>P<sub>1</sub></i></tt> through <tt><i>P<sub>k</sub></i></tt>,
whose next <i>m</i> - <i>k</i> elements each match <tt><i>P<sub>e</sub></i></tt>,
and
whose remaining <i>n</i> - <i>m</i> elements match <tt><i>P<sub><i>m</i>+1</sub></i></tt> through <tt><i>P<sub>n</sub></i></tt>,

<p>
<li><tt><i>P</i></tt> is of the form
<tt>(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>k</sub></i>&nbsp;<i>P<sub>e</sub></i>&nbsp;<i>ellipsis</i>&nbsp;<i>P<sub><i>m</i>+1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>&nbsp;.&nbsp;<i>P<sub>x</sub></i>)</tt>,
where <tt><i>ellipsis</i></tt> is the identifier <tt>...</tt>
and <tt><i>F</i></tt> is a list or improper list of <i>n</i>
elements whose first <i>k</i> elements match <tt><i>P<sub>1</sub></i></tt> through <tt><i>P<sub>k</sub></i></tt>,
whose next <i>m</i> - <i>k</i> elements each match <tt><i>P<sub>e</sub></i></tt>,
whose next <i>n</i> - <i>m</i> elements match <tt><i>P<sub><i>m</i>+1</sub></i></tt> through <tt><i>P<sub>n</sub></i></tt>,
and 
whose <i>n</i>th and final cdr matches <tt><i>P<sub>x</sub></i></tt>,

<p>
<li><tt><i>P</i></tt> is of the form
<tt>#(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>
and <tt><i>F</i></tt> is a vector of <i>n</i> elements that match <tt><i>P<sub>1</sub></i></tt> through
<tt><i>P<sub>n</sub></i></tt>,

<p>
<li><tt><i>P</i></tt> is of the form
<tt>#(<i>P<sub>1</sub></i>&nbsp;...&nbsp;<i>P<sub>k</sub></i>&nbsp;<i>P<sub>e</sub></i>&nbsp;<i>ellipsis</i>&nbsp;<i>P<sub><i>m</i>+1</sub></i>&nbsp;...&nbsp;<i>P<sub>n</sub></i>)</tt>,
where <tt><i>ellipsis</i></tt> is the identifier <tt>...</tt>
and <tt><i>F</i></tt> is a vector of <i>n</i> or more elements
whose first <i>k</i> elements match <tt><i>P<sub>1</sub></i></tt> through <tt><i>P<sub>k</sub></i></tt>,
whose next <i>m</i> - <i>k</i> elements each match <tt><i>P<sub>e</sub></i></tt>,
and
whose remaining <i>n</i> - <i>m</i> elements match <tt><i>P<sub><i>m</i>+1</sub></i></tt> through <tt><i>P<sub>n</sub></i></tt>,
or

<p>
<li><tt><i>P</i></tt> is a pattern datum (any nonlist, nonvector, nonsymbol
object) and <tt><i>F</i></tt> is equal to <tt><i>P</i></tt> in the sense of the
<tt>equal?</tt> procedure.
</ul>
<p>

<p>
The outermost structure of a <tt>syntax-rules</tt> <tt><i>pattern</i></tt>
must actually be in one of the list-structured forms above, although
subpatterns of the pattern may be in any of the above forms.
Furthermore, the first element of the outermost pattern is ignored,
since it is always assumed to be the keyword naming the
syntactic form.
(These statements do not apply to <tt>syntax-case</tt>; see
Section&nbsp;<a href="syntax.html#g136">8.3</a>.)

<p>
If an input form passed to a <tt>syntax-rules</tt> transformer
matches the pattern for a given clause, the clause
is accepted and the form is transformed as specified by the
associated template.
As this transformation takes place,
pattern variables appearing in the pattern
are bound to the corresponding input subforms.
Pattern variables appearing within a subpattern followed by
one or more ellipses may be bound to a sequence or sequences of zero or more
input subforms.

<p>
<a name="./syntax:s23"></a>A template is a pattern variable, an identifier that
is not a pattern
variable, a pattern datum, a list of subtemplates
<tt>(<i>S<sub>1</sub></i>&nbsp;...&nbsp;<i>S<sub>n</sub></i>)</tt>, an improper list of subtemplates
<tt>(<i>S<sub>1</sub></i>&nbsp;<i>S<sub>2</sub></i>&nbsp;...&nbsp;<i>S<sub>n</sub></i>&nbsp;.&nbsp;<i>T</i>)</tt>, or a
vector of subtemplates <tt>#(<i>S<sub>1</sub></i>&nbsp;...&nbsp;<i>S<sub>n</sub></i>)</tt>.
Each subtemplate <tt><i>S<sub>i</sub></i></tt> is a template
followed by zero or more ellipses.
The final element <tt><i>T</i></tt> of an improper subtemplate list is a template.

<p>
Pattern variables appearing within a template are replaced in
the output by the input subforms to which they are bound.
Pattern data and identifiers that are not pattern variables
are inserted directly into the output.
List and vector structure within the template remains list and vector
structure in the output.
A subtemplate followed by an ellipsis expands
into zero or more occurrences of the subtemplate.
The subtemplate
must contain at least one pattern variable from a subpattern
followed by an ellipsis.
(Otherwise, the expander could not determine how many times the subform
should be repeated in the output.)
Pattern variables that occur in subpatterns followed by one or more
ellipses may occur only in subtemplates that are
followed by (at least) as many ellipses.
These pattern variables are replaced in the output by the input
subforms to which  they are bound, distributed as specified.
If a pattern variable is followed by more ellipses in the template
than in the associated pattern, the input form is replicated as
necessary.

<p>
A template of the form
<tt>(...&nbsp;<i>template</i>)</tt> is identical to <tt><i>template</i></tt>, except that
ellipses within the template have no special meaning.
That is, any ellipses contained within <tt><i>template</i></tt> are
treated as ordinary identifiers.
In particular, the template <tt>(...&nbsp;...)</tt> produces a single
ellipsis, <tt>...</tt>.
This allows syntactic extensions to expand into forms containing
ellipses, including <tt>syntax-rules</tt> or <tt>syntax-case</tt>
patterns and templates.

<p>
<p>The definition of <tt>or</tt> below demonstrates the use of
<tt>syntax-rules</tt>.

<p>

<p><tt>(define-syntax&nbsp;or<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_)&nbsp;#f]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)&nbsp;e]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;e3&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;e1])&nbsp;(if&nbsp;t&nbsp;t&nbsp;(or&nbsp;e2&nbsp;e3&nbsp;...)))]))</tt>
<p>The input patterns specify that the input must consist of the
keyword and zero or more subexpressions.
An <a name="./syntax:s24"></a><a name="./syntax:s25"></a>underscore (&nbsp;<tt>_</tt>&nbsp;),
which is a special pattern symbol that matches any input,
is often used for the keyword position to remind the programmer
and anyone reading the definition that the keyword
position never fails to contain the expected keyword and need not be
matched.
(In fact, as mentioned above, <tt>syntax-rules</tt> ignores what appears
in the keyword position.)
If more than one subexpression is present (third clause), the
expanded code both tests the value of the first subexpression
and returns the value if it is not false.
To avoid evaluating the expression twice, the transformer
introduces a binding for the temporary variable&nbsp;<tt>t</tt>.

<p>
The expansion algorithm maintains lexical scoping automatically
by renaming local identifiers as necessary.
Thus, the binding for <tt>t</tt> introduced by the transformer is visible
only within code introduced by the transformer and not within
subforms of the input.
Similarly, the references to the identifiers <tt>let</tt> and <tt>if</tt> are
unaffected by any bindings present in the context of the input.

<p>

<p><tt>(let&nbsp;([if&nbsp;#f])<br>

&nbsp;&nbsp;(let&nbsp;([t&nbsp;'okay])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;if&nbsp;t)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;okay</tt>
<p>This expression is transformed during expansion to the equivalent of
the expression below.

<p>

<p><tt>((lambda&nbsp;(if1)<br>

&nbsp;&nbsp;&nbsp;((lambda&nbsp;(t1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(t2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;t2&nbsp;t2&nbsp;t1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;'okay))<br>

&nbsp;#f)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;okay</tt>
<p>In this sample expansion, <tt>if1</tt>, <tt>t1</tt>, and <tt>t2</tt>
represent identifiers to which <tt>if</tt> and <tt>t</tt> in the
original expression and <tt>t</tt> in the expansion of <tt>or</tt> have
been renamed.

<p>
The definition of a simplified version of <tt>cond</tt> below
(simplified because it requires
at least one output expression per clause and 
does not support the auxiliary keyword <tt>=&gt;</tt>)
demonstrates how auxiliary keywords such as <tt>else</tt> are recognized
in the input to a transformer, via inclusion in the list of
literals.

<p>

<p><tt>(define-syntax&nbsp;cond<br>

&nbsp;&nbsp;(syntax-rules&nbsp;(else)<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(else&nbsp;e1&nbsp;e2&nbsp;...))&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(e0&nbsp;e1&nbsp;e2&nbsp;...))&nbsp;(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(e0&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;c1&nbsp;c2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;(cond&nbsp;c1&nbsp;c2&nbsp;...))]))</tt>
<p><a name="./syntax:s26"></a><span class=formdef><b>syntax</b>: <tt>_</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>...</tt></span>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>

<p>These identifiers are auxiliary keywords for <tt>syntax-rules</tt>,
<tt>identifier-syntax</tt>, and <tt>syntax-case</tt>.
The second (&nbsp;<tt>...</tt>&nbsp;) is also an auxiliary keyword for
<tt>syntax</tt> and <tt>quasisyntax</tt>.
It is a syntax violation to reference these identifiers except in
contexts where they are recognized as auxiliary keywords.


<p>
<a name="./syntax:s27"></a><span class=formdef><b>syntax</b>: <tt>(identifier-syntax&nbsp;<i>tmpl</i>)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(identifier-syntax&nbsp;(<i>id<sub>1</sub></i>&nbsp;<i>tmpl<sub>1</sub></i>)&nbsp;((set!&nbsp;<i>id<sub>2</sub></i>&nbsp;<i>e<sub>2</sub></i>)&nbsp;<i>tmpl<sub>2</sub></i>))</tt></span>
<br>
<b>returns: </b>a transformer
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>When a keyword is bound to a transformer produced by the first form of
<tt>identifier-syntax</tt>, references to the keyword within the scope
of the binding are replaced by <tt><i>tmpl</i></tt>.

<p>

<p><tt>(let&nbsp;()<br>

&nbsp;&nbsp;(define-syntax&nbsp;a&nbsp;(identifier-syntax&nbsp;car))<br>

&nbsp;&nbsp;(list&nbsp;(a&nbsp;'(1&nbsp;2&nbsp;3))&nbsp;a))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;#&lt;procedure&gt;)</tt>
<p>With the first form of <tt>identifier-syntax</tt>, an apparent assignment
of the associated keyword with <tt>set!</tt> is a syntax violation.
The second, more general, form of <tt>identifier-syntax</tt> permits
the transformer to specify what happens when <tt>set!</tt> is used.

<p>

<p><tt>(let&nbsp;([ls&nbsp;(list&nbsp;0)])<br>

&nbsp;&nbsp;(define-syntax&nbsp;a<br>

&nbsp;&nbsp;&nbsp;&nbsp;(identifier-syntax<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[id&nbsp;(car&nbsp;ls)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(set!&nbsp;id&nbsp;e)&nbsp;(set-car!&nbsp;ls&nbsp;e)]))<br>

&nbsp;&nbsp;(let&nbsp;([before&nbsp;a])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;a&nbsp;1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;before&nbsp;a&nbsp;ls)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(0&nbsp;1&nbsp;(1))</tt>
<p><a name="./syntax:s28"></a>A definition of <tt>identifier-syntax</tt> in terms of
<tt>make-variable-transformer</tt> is shown on
page&nbsp;<a href="syntax.html#defn:identifier-syntax">307</a>.

<p>

<h3><a name="g136"></a><a name="./syntax:h3"></a>Section 8.3. Syntax-Case Transformers<a name="SECTSYNTAXCASE"></a></h3>



<p>
This section describes a more expressive mechanism for creating
transformers, based on <tt>syntax-case</tt>, a generalized version of
<tt>syntax-rules</tt>.
This mechanism permits arbitrarily complex transformations to be specified,
including transformations that "bend" lexical scoping in a
controlled manner, allowing a much broader class of syntactic
extensions to be defined.
Any transformer that may be defined using <tt>syntax-rules</tt> may be
rewritten easily to use <tt>syntax-case</tt> instead;
in fact, <tt>syntax-rules</tt>
itself may be defined as a syntactic extension in terms of
<tt>syntax-case</tt>, as demonstrated within the description of
<tt>syntax</tt> below.

<p>
<a name="./syntax:s29"></a>With this mechanism, transformers are procedures of one argument.
The argument is a <i>syntax object</i> representing the form to be
processed.
The return value is a syntax object representing the output form.
A syntax object may be any of the following.

<p>
<ul>
<li>a nonpair, nonvector, nonsymbol value,
<li>a pair of syntax objects,
<li>a vector of syntax objects, or
<li>a wrapped object.
</ul>
<p>

<p>
The <i>wrap</i> on a wrapped syntax object contains contextual information
about a form in addition to its structure.
This contextual information is used by the expander to maintain
lexical scoping.
The wrap may also contain information used by the implementation to
correlate source and object code, e.g., track file, line, and character 
information through the expansion and compilation process.

<p>
The contextual information must be present for all identifiers,
which is why the definition of syntax object above does not allow
symbols unless they are wrapped.
A syntax object representing an identifier is itself referred to as
an identifier; thus, the term <i>identifier</i> may refer either to
the syntactic entity (symbol, variable, or keyword) or to the
concrete representation of the syntactic entity as a syntax object.

<p>
Transformers normally destructure their input with <tt>syntax-case</tt> and rebuild
their output with <tt>syntax</tt>.
These two forms alone are sufficient for defining many syntactic extensions,
including any that can be defined using <tt>syntax-rules</tt>.
They are described below along with a set of additional forms and
procedures that provide added functionality.

<p>
<a name="./syntax:s30"></a><span class=formdef><b>syntax</b>: <tt>(syntax-case&nbsp;<i>expr</i>&nbsp;(<i>literal</i>&nbsp;...)&nbsp;<i>clause</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>

<p>Each <tt><i>literal</i></tt> must be an identifier.
Each <tt><i>clause</i></tt> must take one of the following two forms.

<p>

<p><tt>(<i>pattern</i>&nbsp;<i>output-expression</i>)<br>

(<i>pattern</i>&nbsp;<i>fender</i>&nbsp;<i>output-expression</i>)</tt>
<p><tt>syntax-case</tt> patterns may be in any of the forms described
in Section&nbsp;<a href="syntax.html#g135">8.2</a>.

<p>
<tt>syntax-case</tt> first evaluates <tt><i>expr</i></tt>, then attempts
to match the resulting value against the pattern from the first
<tt><i>clause</i></tt>.
This value may be any Scheme object.
If the value matches the pattern and no
<a name="./syntax:s31"></a><tt><i>fender</i></tt> is present,
<tt><i>output-expression</i></tt> is evaluated and its values returned as the
values of the <tt>syntax-case</tt> expression.
If the value does not match the pattern, the value is compared against
the next clause, and so on.
It is a syntax violation if the value does not match any of the patterns.

<p>
If the optional <tt><i>fender</i></tt> is present, it serves as an additional
constraint on acceptance of a clause.
If the value of the <tt>syntax-case</tt> <tt><i>expr</i></tt> matches the pattern for a given
clause, the corresponding <tt><i>fender</i></tt> is evaluated.
If <tt><i>fender</i></tt> evaluates to a true value, the clause is accepted;
otherwise, the clause is rejected as if the input had failed to match
the pattern.
Fenders are logically a part of the matching process, i.e., they
specify additional matching constraints beyond the basic structure of
an expression.

<p>
<a name="./syntax:s32"></a>Pattern variables contained within a clause's
<tt><i>pattern</i></tt> are bound to the corresponding pieces of the input
value within the clause's <tt><i>fender</i></tt> (if present) and
<tt><i>output-expression</i></tt>.
Pattern variables occupy the same namespace as program variables and
keywords; pattern variable bindings created by <tt>syntax-case</tt>
can shadow (and be shadowed by) program variable and keyword bindings as
well as other pattern variable bindings.
Pattern variables, however, can be referenced only within <tt>syntax</tt>
expressions.

<p>
See the examples following the description of <tt>syntax</tt>.

<p>
<a name="./syntax:s33"></a><span class=formdef><b>syntax</b>: <tt>(syntax&nbsp;<i>template</i>)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>#'<i>template</i></tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>

<p><tt>#'<i>template</i></tt> is equivalent to <tt>(syntax&nbsp;<i>template</i>)</tt>.
The abbreviated form is converted into the longer form when a program
is read, prior to macro expansion.

<p>
A <tt>syntax</tt> expression is like a <tt>quote</tt> expression except that the
values of pattern variables appearing within <tt><i>template</i></tt> are
inserted into <tt><i>template</i></tt>, and
contextual information associated both with the input and with the template is
retained in the output to support lexical scoping.
A <tt>syntax</tt> <tt><i>template</i></tt> is identical to a <tt>syntax-rules</tt>
<tt><i>template</i></tt> and is treated similarly.

<p>
List and vector structures within the template become true lists or
vectors (suitable for direct application of list or vector operations,
like <tt>map</tt> or <tt>vector-ref</tt>) to the extent that the
list or vector structures must be copied to insert the values of
pattern variables, and empty lists are never wrapped.
For example, <tt>#'(x&nbsp;...)</tt>, <tt>#'(a&nbsp;b&nbsp;c)</tt>, <tt>#'()</tt> are
all lists if <tt>x</tt>, <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> are
pattern variables.

<p>
The definition of <tt>or</tt> below is equivalent to the one given in
Section&nbsp;<a href="syntax.html#g135">8.2</a> except that it employs <tt>syntax-case</tt> and
<tt>syntax</tt> in place of <tt>syntax-rules</tt>.

<p>

<p><tt>(define-syntax&nbsp;or<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_)&nbsp;#'#f]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)&nbsp;#'e]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;e3&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([t&nbsp;e1])&nbsp;(if&nbsp;t&nbsp;t&nbsp;(or&nbsp;e2&nbsp;e3&nbsp;...)))])))</tt>
<p>In this version, the <tt>lambda</tt> expression that produces the
transformer is explicit, as are the <tt>syntax</tt> forms in the output
part of each clause.
Any <tt>syntax-rules</tt> form can be expressed with
<tt>syntax-case</tt> by making the <tt>lambda</tt> expression and
<tt>syntax</tt> expressions explicit.
This observation leads to the following definition of
<a name="./syntax:s34"></a><tt>syntax-rules</tt> in terms of
<tt>syntax-case</tt>.

<p>

<p><tt>(define-syntax&nbsp;syntax-rules<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(i&nbsp;...)&nbsp;((keyword&nbsp;.&nbsp;pattern)&nbsp;template)&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;(i&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;.&nbsp;pattern)&nbsp;#'template]&nbsp;...))])))</tt>
<p>An underscore is used in place of
each <tt>keyword</tt> since the first position
of each <tt>syntax-rules</tt> pattern is always ignored.

<p>
Since the <tt>lambda</tt> and <tt>syntax</tt> expressions are
implicit in a <tt>syntax-rules</tt> form, definitions expressed with
<tt>syntax-rules</tt> are often shorter than the equivalent definitions
expressed with <tt>syntax-case</tt>.
The choice of which to use when either suffices is a matter of
taste, but many transformers that can be written easily with
<tt>syntax-case</tt> cannot be written easily or at all with <tt>syntax-rules</tt>
(see Section&nbsp;<a href="syntax.html#g137">8.4</a>).

<p>
<a name="./syntax:s35"></a><span class=formdef><b>procedure</b>: <tt>(identifier?&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt>#t</tt> if <tt><i>obj</i></tt> is an identifier, <tt>#f</tt> otherwise
<br>
<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>

<p><tt>identifier?</tt> is often used within <a name="./syntax:s36"></a>fenders to verify
that certain subforms of an input form are identifiers, as in the
definition of unnamed <tt>let</tt> below.

<p>

<p><tt>(define-syntax&nbsp;let<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;ids?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(identifier?&nbsp;(car&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ids?&nbsp;(cdr&nbsp;ls))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((i&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ids?&nbsp;#'(i&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;(i&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)])))</tt>
<p>Syntactic extensions ordinarily take the form
<tt>(<i>keyword</i>&nbsp;<i>subform</i>&nbsp;...)</tt>, but the
<tt>syntax-case</tt> system permits them to take the form of singleton
identifiers as well.
For example, the keyword <tt>pcar</tt> in the expression below may be used
both as an identifier (in which case it expands into a call to <tt>car</tt>)
or as a structured form (in which case it expands
into a call to <tt>set-car!</tt>).

<p>

<p><tt>(let&nbsp;([p&nbsp;(cons&nbsp;0&nbsp;#f)])<br>

&nbsp;&nbsp;(define-syntax&nbsp;pcar<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;(identifier?&nbsp;x)&nbsp;#'(car&nbsp;p)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)&nbsp;#'(set-car!&nbsp;p&nbsp;e)])))<br>

&nbsp;&nbsp;(let&nbsp;([a&nbsp;pcar])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(pcar&nbsp;1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;a&nbsp;pcar)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(0&nbsp;1)</tt>
<p>The fender <tt>(identifier?&nbsp;x)</tt> is used to recognize the singleton
identifier case.


<p>
<a name="./syntax:s37"></a><span class=formdef><b>procedure</b>: <tt>(free-identifier=?&nbsp;<i>identifier<sub>1</sub></i>&nbsp;<i>identifier<sub>2</sub></i>)</tt></span>
<br>
<span class=formdef><b>procedure</b>: <tt>(bound-identifier=?&nbsp;<i>identifier<sub>1</sub></i>&nbsp;<i>identifier<sub>2</sub></i>)</tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>

<p>Symbolic names alone do not distinguish identifiers unless the
identifiers are to be used only as symbolic data.
The predicates <tt>free-identifier=?</tt> and <tt>bound-identifier=?</tt>
are used to compare identifiers according to their <i>intended use</i>
as free references or bound identifiers in a given context.

<p>
<tt>free-identifier=?</tt> is used to determine whether two
identifiers would be equivalent if they were to appear as free identifiers
in the output of a transformer.
Because identifier references are lexically scoped, this means
<tt>(free-identifier=?&nbsp;<i>id<sub>1</sub></i>&nbsp;<i>id<sub>2</sub></i>)</tt> is true if and only if the
identifiers <tt><i>id<sub>1</sub></i></tt> and <tt><i>id<sub>2</sub></i></tt> refer to the same
binding.
(For this comparison, two like-named identifiers are assumed to have the
same binding if neither is bound.)
Literal identifiers (auxiliary keywords) appearing in
<tt>syntax-case</tt> patterns (such as <tt>else</tt> in <tt>case</tt>
and <tt>cond</tt>)
are matched with <tt>free-identifier=?</tt>.

<p>
Similarly, <tt>bound-identifier=?</tt> is used to
determine whether two identifiers would be equivalent if they were to appear as
bound identifiers in the output of a transformer.
In other words, if <tt>bound-identifier=?</tt> returns true for two
identifiers, a binding for one will capture references to the
other within its scope.
In general, two identifiers are <tt>bound-identifier=?</tt> only if
both are present in the original program or both are introduced by the
same transformer application
(perhaps implicitly---see <tt>datum-&gt;syntax</tt>).
<tt>bound-identifier=?</tt> can be used for detecting
duplicate identifiers in a binding construct or for other
preprocessing of a binding construct that requires detecting instances
of the bound identifiers.

<p>
The definition below is equivalent to the earlier definition
of a simplified version of <tt>cond</tt> with <tt>syntax-rules</tt>, except that
<tt>else</tt> is recognized via an explicit call to <tt>free-identifier?</tt> within
a fender rather than via inclusion in the literals list.

<p>

<p><tt>(define-syntax&nbsp;cond<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(e0&nbsp;e1&nbsp;e2&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(identifier?&nbsp;#'e0)&nbsp;(free-identifier=?&nbsp;#'e0&nbsp;#'else))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(begin&nbsp;e1&nbsp;e2&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(e0&nbsp;e1&nbsp;e2&nbsp;...))&nbsp;#'(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(e0&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;c1&nbsp;c2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;(cond&nbsp;c1&nbsp;c2&nbsp;...))])))</tt>
<p>With either definition of <tt>cond</tt>, <tt>else</tt> is not
recognized as an auxiliary
keyword if an enclosing lexical binding for <tt>else</tt> exists.
For example,

<p>

<p><tt>(let&nbsp;([else&nbsp;#f])<br>

&nbsp;&nbsp;(cond&nbsp;[else&nbsp;(write&nbsp;"oops")]))</tt>
<p>does <i>not</i> write <tt>"oops"</tt>, since <tt>else</tt> is bound
lexically and is
therefore not the same <tt>else</tt> that appears in the definition of
<tt>cond</tt>.

<p>
The following definition of unnamed <tt>let</tt>
uses <tt>bound-identifier=?</tt> to detect duplicate identifiers.

<p>

<p><tt>(define-syntax&nbsp;let<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;ids?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(identifier?&nbsp;(car&nbsp;ls))&nbsp;(ids?&nbsp;(cdr&nbsp;ls))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;unique-ids?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(not&nbsp;(memp<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(bound-identifier=?&nbsp;x&nbsp;(car&nbsp;ls)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cdr&nbsp;ls)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unique-ids?&nbsp;(cdr&nbsp;ls))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((i&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(ids?&nbsp;#'(i&nbsp;...))&nbsp;(unique-ids?&nbsp;#'(i&nbsp;...)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;(i&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)])))</tt>
<p>With the definition of <tt>let</tt> above, the expression

<p>

<p><tt>(let&nbsp;([a&nbsp;3]&nbsp;[a&nbsp;4])&nbsp;(+&nbsp;a&nbsp;a))</tt>
<p>is a syntax violation, whereas

<p>

<p><tt>(let&nbsp;([a&nbsp;0])<br>

&nbsp;&nbsp;(let-syntax&nbsp;([dolet&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;b)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([a&nbsp;3]&nbsp;[b&nbsp;4])&nbsp;(+&nbsp;a&nbsp;b))]))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(dolet&nbsp;a)))</tt>
<p>evaluates to <tt>7</tt> since the identifier <tt>a</tt> introduced by <tt>dolet</tt>
and the identifier <tt>a</tt> extracted from the input form are not
<tt>bound-identifier=?</tt>.
Since both occurrences of <tt>a</tt>, however, if left as free references,
would refer to the same binding for <tt>a</tt>, <tt>free-identifier=?</tt>
would not distinguish them.

<p>
Two identifiers that are <tt>free-identifier=?</tt> may not be
<tt>bound-identifier=?</tt>.
An identifier introduced by a transformer may refer to the same
enclosing binding as an identifier not introduced by the transformer,
but an introduced binding for one will not capture references to the other.
On the other hand, identifiers that are <tt>bound-identifier=?</tt> are
<tt>free-identifier=?</tt>, as long as the identifiers have valid
bindings in the context where they are compared.


<p>
<a name="./syntax:s38"></a><span class=formdef><b>syntax</b>: <tt>(with-syntax&nbsp;((<i>pattern</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the values of the final body expression
<br>
<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>

<p>It is sometimes useful to construct a transformer's output in separate
pieces, then put the pieces together.
<tt>with-syntax</tt> facilitates this by allowing the creation of local
pattern bindings.

<p>
<tt><i>pattern</i></tt> is identical in form to a <tt>syntax-case</tt> pattern.
The value of each <tt><i>expr</i></tt> is computed and destructured according
to the corresponding <tt><i>pattern</i></tt>, and pattern variables within
the <tt><i>pattern</i></tt> are bound as with <tt>syntax-case</tt> to appropriate
portions of the value within the body <tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt>,
which is processed and evaluated like a <tt>lambda</tt> body.

<p>
<tt>with-syntax</tt> may be defined as a syntactic extension in terms of
<tt>syntax-case</tt>.

<p>

<p><tt>(define-syntax&nbsp;with-syntax<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((p&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(syntax-case&nbsp;(list&nbsp;e&nbsp;...)&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(p&nbsp;...)&nbsp;(let&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...)])])))</tt>
<p>The following definition of full <a name="./syntax:s39"></a><tt>cond</tt>
demonstrates the use of <tt>with-syntax</tt> to support transformers
that employ recursion internally to construct their output.

<p>

<p><tt>(define-syntax&nbsp;cond<a name="defn:cond"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;c1&nbsp;c2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([c1&nbsp;#'c1]&nbsp;[cmore&nbsp;#'(c2&nbsp;...)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;cmore)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;c1&nbsp;(else&nbsp;=&gt;)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(else&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;#'(begin&nbsp;e1&nbsp;e2&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0)&nbsp;#'(let&nbsp;([t&nbsp;e0])&nbsp;(if&nbsp;t&nbsp;t))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0&nbsp;=&gt;&nbsp;e1)&nbsp;#'(let&nbsp;([t&nbsp;e0])&nbsp;(if&nbsp;t&nbsp;(e1&nbsp;t)))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;#'(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([rest&nbsp;(f&nbsp;(car&nbsp;cmore)&nbsp;(cdr&nbsp;cmore))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;c1&nbsp;(=&gt;)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0)&nbsp;#'(let&nbsp;([t&nbsp;e0])&nbsp;(if&nbsp;t&nbsp;t&nbsp;rest))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0&nbsp;=&gt;&nbsp;e1)&nbsp;#'(let&nbsp;([t&nbsp;e0])&nbsp;(if&nbsp;t&nbsp;(e1&nbsp;t)&nbsp;rest))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(e0&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(if&nbsp;e0&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;rest)]))))])))</tt>
<p><a name="./syntax:s40"></a><span class=formdef><b>syntax</b>: <tt>(quasisyntax&nbsp;<i>template</i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>#`<i>template</i></tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(unsyntax&nbsp;<i>template</i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>#,<i>template</i></tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(unsyntax-splicing&nbsp;<i>template</i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>#,@<i>template</i></tt></span>
<br>
<b>returns: </b>see below
<br>
<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>

<p><tt>#`<i>template</i></tt> is equivalent to <tt>(quasisyntax&nbsp;<i>template</i>)</tt>,
while
<tt>#,<i>template</i></tt> is equivalent to <tt>(unsyntax&nbsp;<i>template</i>)</tt>, and
<tt>#,@<i>template</i></tt> to <tt>(unsyntax-splicing&nbsp;<i>template</i>)</tt>.
The abbreviated forms are converted into the longer forms when the program
is read, prior to macro expansion.

<p>
<tt>quasisyntax</tt> is similar to <tt>syntax</tt>, but it allows parts
of the quoted text to be evaluated, in a manner similar to
<tt>quasiquote</tt> (Section&nbsp;<a href="objects.html#g107">6.1</a>).

<p>
Within a <tt>quasisyntax</tt> <tt><i>template</i></tt>, subforms of
<tt>unsyntax</tt> and <tt>unsyntax-splicing</tt> forms are evaluated,
and everything else is treated as ordinary template material, as
with <tt>syntax</tt>.
The value of each <tt>unsyntax</tt> subform is inserted into the output
in place of the <tt>unsyntax</tt> form, while the value of each
<tt>unsyntax-splicing</tt> subform is spliced into the surrounding list
or vector structure.
<tt>unsyntax</tt> and <tt>unsyntax-splicing</tt> are valid only within
<tt>quasisyntax</tt> expressions.

<p>
<tt>quasisyntax</tt> expressions may be nested, with each <tt>quasisyntax</tt>
introducing a new level of syntax quotation and each <tt>unsyntax</tt> or
<tt>unsyntax-splicing</tt> taking away a level of quotation.
An expression nested within <i>n</i> <tt>quasisyntax</tt> expressions must
be within <i>n</i> <tt>unsyntax</tt> or <tt>unsyntax-splicing</tt> expressions to
be evaluated.

<p>
<tt>quasisyntax</tt> can be used in place of <tt>with-syntax</tt> in many
cases.
For example, the following definition of
<a name="./syntax:s41"></a><tt>case</tt> employs <tt>quasisyntax</tt> to
construct its output, using internal recursion in a manner similar to the
definition of <tt>cond</tt> given under the description of
<tt>with-syntax</tt> above.

<p>

<p><tt>(define-syntax&nbsp;case<a name="defn:case"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;c1&nbsp;c2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#`(let&nbsp;([t&nbsp;e])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#,(let&nbsp;f&nbsp;([c1&nbsp;#'c1]&nbsp;[cmore&nbsp;#'(c2&nbsp;...)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;cmore)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;c1&nbsp;(else)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(else&nbsp;e1&nbsp;e2&nbsp;...)&nbsp;#'(begin&nbsp;e1&nbsp;e2&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[((k&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(if&nbsp;(memv&nbsp;t&nbsp;'(k&nbsp;...))&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;c1&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[((k&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#`(if&nbsp;(memv&nbsp;t&nbsp;'(k&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#,(f&nbsp;(car&nbsp;cmore)&nbsp;(cdr&nbsp;cmore)))]))))])))</tt>
<p><tt>unsyntax</tt> and <tt>unsyntax-splicing</tt> forms that contain
zero or more than
one subform are valid only in splicing (list or vector) contexts.
<tt>(unsyntax&nbsp;<i>template</i>&nbsp;...)</tt> is equivalent to
<tt>(unsyntax&nbsp;<i>template</i>)&nbsp;...</tt>, and
<tt>(unsyntax-splicing&nbsp;<i>template</i>&nbsp;...)</tt> is equivalent to
<tt>(unsyntax-splicing&nbsp;<i>template</i>)&nbsp;...</tt>.
These forms are primarily useful as intermediate forms in the output
of the <tt>quasisyntax</tt> expander.
They support certain useful nested quasiquotation (<tt>quasisyntax</tt>)
idioms&nbsp;[<a class=citation href="bibliography.html#g221">3</a>], such as <tt>#,@#,@</tt>, which has the
effect of a doubly indirect splicing when used within a doubly nested
and doubly evaluated <tt>quasisyntax</tt> expression, as with the
nested <tt>quasiquote</tt> examples shown in Section&nbsp;<a href="objects.html#g107">6.1</a>.

<p>
<tt>unsyntax</tt> and <tt>unsyntax-splicing</tt> are auxiliary keywords for
<tt>quasisyntax</tt>.
It is a syntax violation to reference these identifiers except in contexts
where they are recognized as auxiliary keywords.

<p>
<a name="./syntax:s42"></a><a name="desc:make-variable-transformer"></a>
<span class=formdef><b>procedure</b>: <tt>(make-variable-transformer&nbsp;<i>procedure</i>)</tt></span>
<br>
<b>returns: </b>a variable transformer
<br>
<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>

<p>As described in the lead-in to this section, transformers may simply be
procedures that accept one argument,
a syntax object representing the input form, and return a new syntax object
representing the output form.
The form passed to a transformer usually represents a parenthesized form whose
first subform is the keyword bound to the transformer or just the keyword
itself.
<tt>make-variable-transformer</tt> may be used to convert a procedure into
a special kind of transformer to which the expander also passes <tt>set!</tt>
forms in which the keyword appears just after the <tt>set!</tt> keyword, as
if it were a variable to be assigned.
This allows the programmer to control what happens when the keyword appears
in such contexts.
The argument, <tt><i>procedure</i></tt>, should accept one argument.

<p>

<p><tt>(let&nbsp;([ls&nbsp;(list&nbsp;0)])<br>

&nbsp;&nbsp;(define-syntax&nbsp;a<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-variable-transformer<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[id&nbsp;(identifier?&nbsp;#'id)&nbsp;#'(car&nbsp;ls)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(set!&nbsp;_&nbsp;e)&nbsp;#'(set-car!&nbsp;ls&nbsp;e)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;...)&nbsp;#'((car&nbsp;ls)&nbsp;e&nbsp;...)]))))<br>

&nbsp;&nbsp;(let&nbsp;([before&nbsp;a])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;a&nbsp;1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;before&nbsp;a&nbsp;ls)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(0&nbsp;1&nbsp;(1))</tt>
<p><a name="./syntax:s43"></a>This syntactic abstraction can be defined more succinctly using
<tt>identifier-syntax</tt>, as shown in Section&nbsp;<a href="syntax.html#g135">8.2</a>,
but <tt>make-variable-transformer</tt> can be used to create
transformers that perform arbitrary computations, while
<tt>identifier-syntax</tt> is limited to simple term rewriting,
like <tt>syntax-rules</tt>.
<tt>identifier-syntax</tt> can be defined
in terms of <tt>make-variable-transformer</tt>, as shown below.

<p>

<p><tt>(define-syntax&nbsp;identifier-syntax<a name="defn:identifier-syntax"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;(set!)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[id&nbsp;(identifier?&nbsp;#'id)&nbsp;#'e]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;(...&nbsp;...))&nbsp;#'(e&nbsp;x&nbsp;(...&nbsp;...))]))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(id&nbsp;exp1)&nbsp;((set!&nbsp;var&nbsp;val)&nbsp;exp2))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(identifier?&nbsp;#'id)&nbsp;(identifier?&nbsp;#'var))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(make-variable-transformer<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;(set!)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(set!&nbsp;var&nbsp;val)&nbsp;#'exp2]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(id&nbsp;x&nbsp;(...&nbsp;...))&nbsp;#'(exp1&nbsp;x&nbsp;(...&nbsp;...))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[id&nbsp;(identifier?&nbsp;#'id)&nbsp;#'exp1])))])))</tt>
<p><a name="./syntax:s44"></a><span class=formdef><b>procedure</b>: <tt>(syntax-&gt;datum&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b><tt><i>obj</i></tt> stripped of syntactic information
<br>
<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>

<p>The procedure <tt>syntax-&gt;datum</tt>
strips all syntactic information from a syntax
object and returns the corresponding Scheme "datum."
Identifiers stripped in this manner are converted to their symbolic
names, which can then be compared with <tt>eq?</tt>.
Thus, a predicate <tt>symbolic-identifier=?</tt> might be defined as follows.

<p>

<p><tt>(define&nbsp;symbolic-identifier=?<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(eq?&nbsp;(syntax-&gt;datum&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-&gt;datum&nbsp;y))))</tt>
<p>Two identifiers that are <tt>free-identifier=?</tt> need not be
<tt>symbolic-identifier=?</tt>: two identifiers that refer to the
same binding usually have the same name, but the <tt>rename</tt> and
<tt>prefix</tt> subforms of the library's <tt>import</tt> form
(page&nbsp;<a href="libraries.html#desc:import">345</a>) may
result in two identifiers with different names but the same binding.

<p>
<a name="./syntax:s45"></a><span class=formdef><b>procedure</b>: <tt>(datum-&gt;syntax&nbsp;<i>template-identifier</i>&nbsp;<i>obj</i>)</tt></span>
<br>
<b>returns: </b>a syntax object
<br>
<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>

<p><tt>datum-&gt;syntax</tt> constructs a syntax object from <tt><i>obj</i></tt> that
contains the same contextual information as
<tt><i>template-identifier</i></tt>, with the effect that the
syntax object behaves
as if it were introduced into the code when
<tt><i>template-identifier</i></tt> was introduced.
The template identifier is often the keyword of an input form,
extracted from the form, and the object is often a symbol naming an
identifier to be constructed.

<p>
<tt>datum-&gt;syntax</tt> allows a transformer to "bend" lexical
scoping rules by creating <i>implicit identifiers</i>
that behave as if they were present in the input form,
thus permitting the definition of syntactic
extensions that introduce visible bindings for or references to
identifiers that do not appear explicitly in the input form.
For example, we can define a <a name="./syntax:s46"></a><tt>loop</tt> expression that
binds the variable <a name="./syntax:s47"></a><tt>break</tt> to an escape procedure
within the loop body.

<p>

<p><tt>(define-syntax&nbsp;loop<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(k&nbsp;e&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([break&nbsp;(datum-&gt;syntax&nbsp;#'k&nbsp;'break)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(break)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;()&nbsp;e&nbsp;...&nbsp;(f)))))])))
<br>
<br>
(let&nbsp;([n&nbsp;3]&nbsp;[ls&nbsp;'()])<br>

&nbsp;&nbsp;(loop<br>

&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;n&nbsp;0)&nbsp;(break&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;ls&nbsp;(cons&nbsp;'a&nbsp;ls))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;n&nbsp;(-&nbsp;n&nbsp;1))))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;a&nbsp;a)</tt>
<p>Were we to define <tt>loop</tt> as

<p>

<p><tt>(define-syntax&nbsp;loop<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(call/cc<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(break)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;()&nbsp;e&nbsp;...&nbsp;(f))))])))</tt>
<p>the variable <tt>break</tt> would not be visible in <tt>e&nbsp;...</tt>.

<p>
It is also useful for <tt><i>obj</i></tt> to represent an arbitrary
Scheme form, as demonstrated by the following definition of
<a name="./syntax:s48"></a><tt>include</tt>.

<p>

<p><tt>(define-syntax&nbsp;include<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;read-file<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(fn&nbsp;k)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([p&nbsp;(open-input-file&nbsp;fn)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([x&nbsp;(read&nbsp;p)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(eof-object?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(close-port&nbsp;p)&nbsp;'())<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(datum-&gt;syntax&nbsp;k&nbsp;x)&nbsp;(f&nbsp;(read&nbsp;p))))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(k&nbsp;filename)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([fn&nbsp;(syntax-&gt;datum&nbsp;#'filename)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([(expr&nbsp;...)&nbsp;(read-file&nbsp;fn&nbsp;#'k)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(begin&nbsp;expr&nbsp;...)))])))</tt>
<p><tt>(include&nbsp;"filename")</tt> expands into a <tt>begin</tt> expression
containing the forms found in the file named by
<tt>"filename"</tt>.
For example, if the file <tt>f-def.ss</tt> contains the expression
<tt>(define&nbsp;f&nbsp;(lambda&nbsp;()&nbsp;x))</tt>, the expression

<p>

<p><tt>(let&nbsp;([x&nbsp;"okay"])<br>

&nbsp;&nbsp;(include&nbsp;"f-def.ss")<br>

&nbsp;&nbsp;(f))</tt>
<p>evaluates to <tt>"okay"</tt>.

<p>
The definition of <tt>include</tt> uses <tt>datum-&gt;syntax</tt> to convert
the objects read from the file into syntax objects in the proper
lexical context, so that identifier references and definitions within
those expressions are scoped where the <tt>include</tt> form appears.

<p>
<a name="./syntax:s49"></a><span class=formdef><b>procedure</b>: <tt>(generate-temporaries&nbsp;<i>list</i>)</tt></span>
<br>
<b>returns: </b>a list of distinct generated identifiers
<br>
<b>libraries: </b><tt>(rnrs&nbsp;syntax-case)</tt>, <tt>(rnrs)</tt>

<p>Transformers can introduce a fixed number of identifiers into their
output by naming each identifier.
In some cases, however, the number of identifiers to be introduced depends
upon some characteristic of the input expression.
A straightforward definition of <tt>letrec</tt>, for example,
requires as many
temporary identifiers as there are binding pairs in the
input expression.
The procedure <tt>generate-temporaries</tt> is used to construct
lists of temporary identifiers.

<p>
<tt><i>list</i></tt> may be any list; its contents are not important.
The number of temporaries generated is the number of elements
in <tt><i>list</i></tt>.
Each temporary is guaranteed to be different from all other
identifiers.

<p>
A definition of <a name="./syntax:s50"></a><tt>letrec</tt> that
uses <tt>generate-temporaries</tt> is shown below.

<p>

<p><tt>(define-syntax&nbsp;letrec<a name="defn:letrec"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((i&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([(t&nbsp;...)&nbsp;(generate-temporaries&nbsp;#'(i&nbsp;...))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;([i&nbsp;#f]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;e]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;i&nbsp;t)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;()&nbsp;b1&nbsp;b2&nbsp;...))))])))</tt>
<p>Any transformer that uses <tt>generate-temporaries</tt> in this fashion can
be rewritten to avoid using it, albeit with a loss of clarity.
The trick is to use a recursively defined intermediate form that
generates one temporary per expansion step and completes the
expansion after enough temporaries have been generated.
<a name="fullletvalues"></a>Here is a definition of <a name="./syntax:s51"></a><tt>let-values</tt>
(page&nbsp;<a href="binding.html#desc:let-values">99</a>) that uses this technique to support
multiple sets of bindings.

<p>

<p><tt>(define-syntax&nbsp;let-values<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;()&nbsp;f1&nbsp;f2&nbsp;...)&nbsp;(let&nbsp;()&nbsp;f1&nbsp;f2&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((fmls1&nbsp;expr1)&nbsp;(fmls2&nbsp;expr2)&nbsp;...)&nbsp;f1&nbsp;f2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lvhelp&nbsp;fmls1&nbsp;()&nbsp;()&nbsp;expr1&nbsp;((fmls2&nbsp;expr2)&nbsp;...)&nbsp;(f1&nbsp;f2&nbsp;...))]))
<br>
<br>
(define-syntax&nbsp;lvhelp<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(x1&nbsp;.&nbsp;fmls)&nbsp;(x&nbsp;...)&nbsp;(t&nbsp;...)&nbsp;e&nbsp;m&nbsp;b)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lvhelp&nbsp;fmls&nbsp;(x&nbsp;...&nbsp;x1)&nbsp;(t&nbsp;...&nbsp;tmp)&nbsp;e&nbsp;m&nbsp;b)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;()&nbsp;(x&nbsp;...)&nbsp;(t&nbsp;...)&nbsp;e&nbsp;m&nbsp;b)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call-with-values<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;e)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(t&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;m&nbsp;(let&nbsp;([x&nbsp;t]&nbsp;...)&nbsp;.&nbsp;b))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;xr&nbsp;(x&nbsp;...)&nbsp;(t&nbsp;...)&nbsp;e&nbsp;m&nbsp;b)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(call-with-values<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;e)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(t&nbsp;...&nbsp;.&nbsp;tmpr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-values&nbsp;m&nbsp;(let&nbsp;([x&nbsp;t]&nbsp;...&nbsp;[xr&nbsp;tmpr])&nbsp;.&nbsp;b))))]))</tt>
<p>The implementation of <tt>lvhelp</tt> is complicated by the need
to evaluate all of the right-hand-side expressions before creating
any of the bindings and by the need to support improper formals
lists.

<p>

<h3><a name="g137"></a><a name="./syntax:h4"></a>Section 8.4. Examples<a name="SECTSYNTAXEXAMPLES"></a></h3>



<p>
This section presents a series of illustrative syntactic extensions
defined with either <tt>syntax-rules</tt> or <tt>syntax-case</tt>, starting with
a few simple but useful syntactic extensions and ending with a
fairly complex mechanism for defining structures with automatically
generated constructors, predicates, field accessors, and field
setters.

<p>
The simplest example in this section is the following definition
of <a name="./syntax:s52"></a><tt>rec</tt>.
<tt>rec</tt> is a syntactic extension that permits internally recursive
anonymous (not externally named) procedures to be created with
minimal effort.

<p>

<p><tt>(define-syntax&nbsp;rec<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;e)&nbsp;(letrec&nbsp;([x&nbsp;e])&nbsp;x)]))
<br>
<br>
(map&nbsp;(rec&nbsp;sum<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(=&nbsp;x&nbsp;0)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;(sum&nbsp;(-&nbsp;x&nbsp;1))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'(0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(0&nbsp;1&nbsp;3&nbsp;6&nbsp;10&nbsp;15)</tt>
<p>Using <tt>rec</tt>, we can define the full <tt>let</tt> (both
unnamed and named) as follows.

<p>

<p><tt>(define-syntax&nbsp;let<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;f&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((rec&nbsp;f&nbsp;(lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...))&nbsp;e&nbsp;...)]))</tt>
<p>We can also define <tt>let</tt> directly in terms of
<tt>letrec</tt>, although the definition is a bit less clear.

<p>

<p><tt>(define-syntax&nbsp;let<a name="defn:let"></a><br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;f&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((letrec&nbsp;([f&nbsp;(lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)])&nbsp;f)&nbsp;e&nbsp;...)]))</tt>
<p>These definitions rely upon the fact that the first pattern cannot
match a named <tt>let</tt>, since the first subform of a named
<tt>let</tt> must
be an identifier, not a list of bindings.
The following definition uses a fender to make this check more
robust.

<p>

<p><tt>(define-syntax&nbsp;let<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;f&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(identifier?&nbsp;#'f)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((rec&nbsp;f&nbsp;(lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...))&nbsp;e&nbsp;...)])))</tt>
<p>With the fender, we can even put the clauses in the opposite order.

<p>

<p><tt>(define-syntax&nbsp;let<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;f&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(identifier?&nbsp;#'f)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((rec&nbsp;f&nbsp;(lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...))&nbsp;e&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)])))</tt>
<p>To be completely robust, the <tt>ids?</tt> and <tt>unique-ids?</tt> checks
employed in the definition of unnamed <tt>let</tt> in Section&nbsp;<a href="syntax.html#g136">8.3</a>
should be employed here as well.

<p>
<p>Both variants of <tt>let</tt> are easily described by simple one-line patterns,
but <tt>do</tt> requires a bit more work.
The precise syntax of <a name="./syntax:s53"></a><tt>do</tt> cannot be expressed directly with a
single pattern because some of the bindings in a <tt>do</tt>
expression's binding list may take the form <tt>(var&nbsp;val)</tt> while
others take the form <tt>(var&nbsp;val&nbsp;update)</tt>.
The following definition of <tt>do</tt> uses <tt>syntax-case</tt>
internally to parse the bindings separately from the overall form.

<p>

<p><tt>(define-syntax&nbsp;do<a name="defn:do"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(binding&nbsp;...)&nbsp;(test&nbsp;res&nbsp;...)&nbsp;expr&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([((var&nbsp;val&nbsp;update)&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(b)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;b&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(var&nbsp;val)&nbsp;#'(var&nbsp;val&nbsp;var)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(var&nbsp;val&nbsp;update)&nbsp;#'(var&nbsp;val&nbsp;update)]))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(binding&nbsp;...))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(let&nbsp;doloop&nbsp;([var&nbsp;val]&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;test<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;(if&nbsp;#f&nbsp;#f)&nbsp;res&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;expr&nbsp;...&nbsp;(doloop&nbsp;update&nbsp;...)))))])))</tt>
<p>The odd-looking expression <tt>(if&nbsp;#f&nbsp;#f)</tt> is inserted before the
result expressions <tt>res&nbsp;...</tt> in case no result expressions are
provided, since <tt>begin</tt> requires at least one subexpression.
The value of <tt>(if&nbsp;#f&nbsp;#f)</tt> is unspecified, which is what we want
since the value of <tt>do</tt> is unspecified if no result expressions
are provided.
At the expense of a bit more code, we could use <tt>syntax-case</tt> to
determine whether any result expressions are provided and to produce a
loop with either a one- or two-armed <tt>if</tt> as appropriate.
The resulting expansion would be cleaner but semantically equivalent.

<p>
<p>As mentioned in Section&nbsp;<a href="syntax.html#g135">8.2</a>,
ellipses lose their special meaning
within templates of the form <tt>(...&nbsp;<i>template</i>)</tt>.
This fact allows syntactic extensions
to expand into syntax definitions containing ellipses.
This usage is illustrated by the definition below of
<a name="./syntax:s54"></a><tt>be-like-begin</tt>.

<p>

<p><tt>(define-syntax&nbsp;be-like-begin<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;name)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;name<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e0&nbsp;e1&nbsp;(...&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;e0&nbsp;e1&nbsp;(...&nbsp;...))]))]))</tt>
<p>With <tt>be-like-begin</tt> defined in this manner,
<tt>(be-like-begin&nbsp;sequence)</tt> has the same effect as
the following definition of <a name="./syntax:s55"></a><tt>sequence</tt>.

<p>

<p><tt>(define-syntax&nbsp;sequence<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e0&nbsp;e1&nbsp;...)&nbsp;(begin&nbsp;e0&nbsp;e1&nbsp;...)]))</tt>
<p>That is, a <tt>sequence</tt> form becomes equivalent to a <tt>begin</tt>
form so that, for example:

<p>

<p><tt>(sequence&nbsp;(display&nbsp;"Say&nbsp;what?")&nbsp;(newline))</tt>
<p>prints "Say what?" followed by a newline.

<p>
<p>The following example shows how one might restrict
<tt>if</tt> expressions within a given expression to require the
"else" (alternative) subexpression by defining a local <tt>if</tt> in
terms of the built-in <tt>if</tt>.
Within the body of the <tt>let-syntax</tt> binding below,
two-armed <tt>if</tt> works as always:

<p>

<p><tt>(let-syntax&nbsp;([if&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;e3)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(if&nbsp;e1&nbsp;e2&nbsp;e3)]))])<br>

&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;1&nbsp;5)&nbsp;2&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;2</tt>
<p>but one-armed if results in a syntax error.

<p>

<p><tt>(let-syntax&nbsp;([if&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2&nbsp;e3)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(if&nbsp;e1&nbsp;e2&nbsp;e3)]))])<br>

&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;1&nbsp;5)&nbsp;2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>syntax&nbsp;violation</i></tt>
<p>Although this local definition of <tt>if</tt> looks simple enough,
there are a few subtle ways in which an attempt to write it might go
wrong.
If <a name="./syntax:s56"></a><tt>letrec-syntax</tt> were used in
place of <a name="./syntax:s57"></a><tt>let-syntax</tt>,
the identifier <tt>if</tt> inserted into the 
output would refer to the local <tt>if</tt>
rather than the built-in <tt>if</tt>, and expansion would loop
indefinitely.

<p>
Similarly, if the underscore were replaced with the identifier
<tt>if</tt>, expansion would again loop indefinitely.
The <tt>if</tt> appearing in the template <tt>(if&nbsp;e1&nbsp;e2&nbsp;e3)</tt> would be treated
as a pattern variable bound to the corresponding identifier <tt>if</tt>
from the input form, which denotes the local version of <tt>if</tt>.

<p>
Placing <tt>if</tt> in the list of literals in an attempt
to patch up the latter version would not work either.
This would cause <tt>syntax-case</tt> to compare the literal
<tt>if</tt> in the pattern, which would be scoped outside the
<tt>let-syntax</tt> expression, with the <tt>if</tt> in the
input expression, which would be scoped inside the <tt>let-syntax</tt>.
Since they would not refer to the same binding, they would not be
<tt>free-identifier=?</tt>, and a syntax violation would result.

<p>
The conventional use of
<a name="./syntax:s58"></a><a name="./syntax:s59"></a>underscore (&nbsp;<tt>_</tt>&nbsp;)
helps the programmer avoid situations like these in which the wrong
identifier is matched against or inserted by accident.

<p>
<p>It is a syntax violation to generate a reference to an identifier that is not
present within the context of an input form, which can happen if the
"closest enclosing lexical binding" for an identifier inserted into
the output of a transformer does not also enclose the input form.
For example,

<p>

<p><tt>(let-syntax&nbsp;([divide&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([/&nbsp;+])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;e1&nbsp;e2)&nbsp;#'(/&nbsp;e1&nbsp;e2)])))])<br>

&nbsp;&nbsp;(let&nbsp;([/&nbsp;*])&nbsp;(divide&nbsp;2&nbsp;1)))</tt>
<p>should result in a syntax violation with a message to the effect that&nbsp;<tt>/</tt>&nbsp;is referenced in an
invalid context, since the occurrence of&nbsp;<tt>/</tt>&nbsp;in the output of
<tt>divide</tt> is a reference to the variable&nbsp;<tt>/</tt>&nbsp;bound by the <tt>let</tt>
expression within the transformer.

<p>
<a name="./syntax:s60"></a>The next example defines a
<a name="./syntax:s61"></a><tt>define-integrable</tt>
form that is similar
to <tt>define</tt> for procedure definitions except that it causes the
code for the procedure to be <i>integrated</i>, or inserted, wherever
a direct call to the procedure is found.

<p>

<p><tt>(define-syntax&nbsp;define-integrable<br>

&nbsp;&nbsp;(syntax-rules&nbsp;(lambda)<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;name&nbsp;(lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;xname&nbsp;(lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;name<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;(identifier?&nbsp;x)&nbsp;#'xname]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;arg&nbsp;(...&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(...&nbsp;...))]))))]))</tt>
<p>The form <tt>(define-integrable&nbsp;<i>name</i>&nbsp;<i>lambda-expression</i>)</tt>
expands into a pair of definitions:  a syntax definition of <tt><i>name</i></tt> and
a variable definition of <tt>xname</tt>.
The transformer for <tt><i>name</i></tt> converts apparent calls to
<tt><i>name</i></tt> into direct calls to <tt><i>lambda-expression</i></tt>.
Since the resulting forms are merely direct <tt>lambda</tt> applications
(the equivalent of <tt>let</tt> expressions),
the actual parameters are evaluated exactly once and before evaluation
of the procedure's body, as required.
All other references to <tt><i>name</i></tt> are replaced with references to
<tt>xname</tt>.
The definition of <tt>xname</tt> binds it to the value of
<tt><i>lambda-expression</i></tt>.
This allows the procedure to be used as a first-class value.
The <tt>define-integrable</tt> transformer does nothing special to
maintain lexical scoping within the <tt>lambda</tt> expression or at the
call site, since lexical scoping is maintained automatically by the
expander.
Also, because <tt>xname</tt> is introduced by the transformer, the binding
for <tt>xname</tt> is not visible anywhere except where references to it
are introduced by the the transformer for <tt><i>name</i></tt>.

<p>
The above definition of <tt>define-integrable</tt> does not work for
recursive procedures, since a recursive call would cause an indefinite
number of expansion steps, likely resulting in exhaustion
of memory at expansion time.
A solution to this problem for directly recursive procedures is to wrap
each occurrence of the <tt>lambda</tt> expression with a <tt>let-syntax</tt>
binding that unconditionally expands <tt><i>name</i></tt> to <tt>xname</tt>.

<p>

<p><tt>(define-syntax&nbsp;define-integrable<br>

&nbsp;&nbsp;(syntax-rules&nbsp;(lambda)<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;name&nbsp;(lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;xname<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-syntax&nbsp;([name&nbsp;(identifier-syntax&nbsp;xname)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;name<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;(identifier?&nbsp;x)&nbsp;#'xname]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;arg&nbsp;(...&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'((let-syntax&nbsp;([name&nbsp;(identifier-syntax&nbsp;xname)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;formals&nbsp;form1&nbsp;form2&nbsp;...))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg&nbsp;(...&nbsp;...))]))))]))</tt>
<p>This problem can be solved for mutually recursive procedures by
replacing the <tt>let-syntax</tt> forms with the nonstandard
<tt>fluid-let-syntax</tt> form, which is described in the <i>Chez Scheme
User's Guide</i>&nbsp;[<a class=citation href="bibliography.html#g227">9</a>].

<p>
<p>Both definitions of <tt>define-integrable</tt> treat
the case where an identifier appears
in the first position of a structured expression differently from
the case where it appears elsewhere, as does the <tt>pcar</tt> example given
in the description for <tt>identifier?</tt>.
In other situations, both cases must be treated the same.
The form <a name="./syntax:s62"></a><tt>identifier-syntax</tt>
can make doing so more
convenient<a name="./syntax:s63"></a>.

<p>

<p><tt>(let&nbsp;([x&nbsp;0])<br>

&nbsp;&nbsp;(define-syntax&nbsp;x++<br>

&nbsp;&nbsp;&nbsp;&nbsp;(identifier-syntax<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([t&nbsp;x])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;x&nbsp;(+&nbsp;t&nbsp;1))&nbsp;t)))<br>

&nbsp;&nbsp;(let&nbsp;([a&nbsp;x++])&nbsp;(list&nbsp;a&nbsp;x)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(0&nbsp;1)</tt>
<p><p>The following example uses
<a name="./syntax:s64"></a><tt>identifier-syntax</tt>,
<a name="./syntax:s65"></a><tt>datum-&gt;syntax</tt>,
and local syntax definitions to define a form of <i>method</i>, one
of the basic building blocks of
<a name="./syntax:s66"></a>object-oriented programming (OOP)
systems.
A <a name="./syntax:s67"></a><tt>method</tt> expression is similar to
a <tt>lambda</tt> expression, except
that in addition to the formal parameters and body, a <tt>method</tt>
expression also contains a list of instance variables <tt>(ivar&nbsp;...)</tt>.
When a method is invoked, it is always passed an <i>object</i>
(<i>instance</i>),
represented as a vector of <i>fields</i> corresponding to the
instance variables, and zero or more additional arguments.
Within the method body, the object is bound implicitly to the
identifier <tt>self</tt> and the additional arguments are bound to the
formal parameters.
The fields of the object may be accessed or altered within the
method body via instance variable references or assignments.

<p>

<p><tt>(define-syntax&nbsp;method<a name="defn:method"></a><br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(k&nbsp;(ivar&nbsp;...)&nbsp;formals&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([(index&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([i&nbsp;0]&nbsp;[ls&nbsp;#'(ivar&nbsp;...)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;i&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1)&nbsp;(cdr&nbsp;ls)))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self&nbsp;(datum-&gt;syntax&nbsp;#'k&nbsp;'self)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[set!&nbsp;(datum-&gt;syntax&nbsp;#'k&nbsp;'set!)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(lambda&nbsp;(self&nbsp;.&nbsp;formals)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-syntax&nbsp;([ivar&nbsp;(identifier-syntax<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-ref&nbsp;self&nbsp;index))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-syntax&nbsp;([set!<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;(ivar&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;ivar&nbsp;e)&nbsp;(vector-set!&nbsp;self&nbsp;index&nbsp;e)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;x&nbsp;e)&nbsp;(set!&nbsp;x&nbsp;e)])])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b1&nbsp;b2&nbsp;...))))])))</tt>
<p>Local bindings for <tt>ivar&nbsp;...</tt> and for <tt>set!</tt> make the fields of
the object appear to be ordinary variables, with references and
assignments translated into calls to <tt>vector-ref</tt> and <tt>vector-set!</tt>.
<tt>datum-&gt;syntax</tt> is used to make the introduced
bindings of <tt>self</tt> and <tt>set!</tt> visible in the method body.
Nested <tt>let-syntax</tt> expressions are needed so that the identifiers
<tt>ivar&nbsp;...</tt> serving as auxiliary keywords for the local version of
<tt>set!</tt> are scoped properly.

<p>
<a name="./syntax:s68"></a>By using the general form of <tt>identifier-syntax</tt> to handle <tt>set!</tt>
forms more directly, we can simplify the definition of <tt>method</tt>.

<p>

<p><tt>(define-syntax&nbsp;method<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(k&nbsp;(ivar&nbsp;...)&nbsp;formals&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([(index&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([i&nbsp;0]&nbsp;[ls&nbsp;#'(ivar&nbsp;...)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ls)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;i&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1)&nbsp;(cdr&nbsp;ls)))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self&nbsp;(datum-&gt;syntax&nbsp;#'k&nbsp;'self)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(lambda&nbsp;(self&nbsp;.&nbsp;formals)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let-syntax&nbsp;([ivar&nbsp;(identifier-syntax<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[_&nbsp;(vector-ref&nbsp;self&nbsp;index)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(set!&nbsp;_&nbsp;e)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-set!&nbsp;self&nbsp;index&nbsp;e)])]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b1&nbsp;b2&nbsp;...)))])))</tt>
<p>The examples below demonstrate simple uses of <tt>method</tt>.

<p>

<p><tt>(let&nbsp;([m&nbsp;(method&nbsp;(a)&nbsp;(x)&nbsp;(list&nbsp;a&nbsp;x&nbsp;self))])<br>

&nbsp;&nbsp;(m&nbsp;#(1)&nbsp;2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;#(1))
<br>
<br>
(let&nbsp;([m&nbsp;(method&nbsp;(a)&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;a&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;x&nbsp;(+&nbsp;a&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;a&nbsp;x&nbsp;self))])<br>

&nbsp;&nbsp;(m&nbsp;#(1)&nbsp;2))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2&nbsp;4&nbsp;#(2))</tt>
<p>In a complete OOP system based on <tt>method</tt>, the instance variables
<tt>ivar&nbsp;...</tt> would likely be drawn from class declarations, not
listed explicitly in the <tt>method</tt> forms, although the same techniques
would be used to make instance variables appear as ordinary variables
within method bodies.

<p>
<p><a name="./syntax:s69"></a>The final example of this section defines a simple structure
definition facility that represents structures as vectors with
named fields.
Structures are defined with
<a name="./syntax:s70"></a><tt>define-structure</tt>, which takes the
form

<p>

<p><tt>(define-structure&nbsp;<i>name</i>&nbsp;<i>field</i>&nbsp;...)</tt>
<p>where <tt><i>name</i></tt> names the structure and <tt><i>field</i>&nbsp;...</tt> names its
fields.
<tt>define-structure</tt> expands into a series of generated definitions:
a constructor <tt>make-<i>name</i></tt>, a type predicate <tt><i>name</i>?</tt>,
and one accessor <tt><i>name</i>-<i>field</i></tt> and setter
<tt>set-<i>name</i>-<i>field</i>!</tt> per field name.

<p>


<p><tt>(define-syntax&nbsp;define-structure<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;gen-id<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(template-id&nbsp;.&nbsp;args)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(datum-&gt;syntax&nbsp;template-id<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(apply&nbsp;string-append<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(string?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(symbol-&gt;string&nbsp;(syntax-&gt;datum&nbsp;x))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args))))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case&nbsp;x&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;name&nbsp;field&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(with-syntax&nbsp;([constructor&nbsp;(gen-id&nbsp;#'name&nbsp;"make-"&nbsp;#'name)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[predicate&nbsp;(gen-id&nbsp;#'name&nbsp;#'name&nbsp;"?")]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(access&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)&nbsp;(gen-id&nbsp;x&nbsp;#'name&nbsp;"-"&nbsp;x))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(field&nbsp;...))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(assign&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(gen-id&nbsp;x&nbsp;"set-"&nbsp;#'name&nbsp;"-"&nbsp;x&nbsp;"!"))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(field&nbsp;...))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[structure-length&nbsp;(+&nbsp;(length&nbsp;#'(field&nbsp;...))&nbsp;1)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(index&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;f&nbsp;([i&nbsp;1]&nbsp;[ids&nbsp;#'(field&nbsp;...)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(null?&nbsp;ids)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;i&nbsp;(f&nbsp;(+&nbsp;i&nbsp;1)&nbsp;(cdr&nbsp;ids)))))])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#'(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;constructor<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(field&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector&nbsp;'name&nbsp;field&nbsp;...)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;predicate<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(vector?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(=&nbsp;(vector-length&nbsp;x)&nbsp;structure-length)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eq?&nbsp;(vector-ref&nbsp;x&nbsp;0)&nbsp;'name))))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;access<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-ref&nbsp;x&nbsp;index)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;assign<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;update)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-set!&nbsp;x&nbsp;index&nbsp;update)))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...))])))</tt>
<p>
<p>The constructor accepts as many arguments as there are fields in the
structure and creates a vector whose first element is the symbol
<tt><i>name</i></tt> and whose remaining elements are the argument values.
The type predicate returns true if its argument is a vector
of the expected length whose first element is <tt><i>name</i></tt>.

<p>
Since a <tt>define-structure</tt> form expands into a <tt>begin</tt> containing
definitions, it is itself a definition and can be used wherever
definitions are valid.

<p>
The generated identifiers are created with
<a name="./syntax:s71"></a><tt>datum-&gt;syntax</tt> to allow the identifiers to be visible
where the <tt>define-structure</tt> form appears.

<p>
The examples below demonstrate the use of <tt>define-structure</tt>.

<p>

<p><tt>(define-structure&nbsp;tree&nbsp;left&nbsp;right)<br>

(define&nbsp;t<br>

&nbsp;&nbsp;(make-tree<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-tree&nbsp;0&nbsp;1)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(make-tree&nbsp;2&nbsp;3)))
<br>
<br>
t&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(tree&nbsp;#(tree&nbsp;0&nbsp;1)&nbsp;#(tree&nbsp;2&nbsp;3))<br>

(tree?&nbsp;t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(tree-left&nbsp;t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(tree&nbsp;0&nbsp;1)<br>

(tree-right&nbsp;t)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(tree&nbsp;2&nbsp;3)<br>

(set-tree-left!&nbsp;t&nbsp;0)<br>

t&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#(tree&nbsp;0&nbsp;#(tree&nbsp;2&nbsp;3))</tt>
<p>



<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
