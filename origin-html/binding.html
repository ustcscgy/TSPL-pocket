<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
  "http://www.w3.org/TR/html4/loose.dtd"><!-- DO NOT EDIT THIS FILE-->
<!-- Edit the .tex version instead-->

<html>
<head>
<title>Procedures and Variable Bindings</title>
<link href="tspl.css" rel="stylesheet" type="text/css">
</head>
<body>
<a name="g88"></a>
<a name="./binding:h0"></a>

<div style="font-size: 12px; width: 500px; height: 500px; border: solid thin">
<img style="padding: 20px 10px 20px 20px" src="canned/ch4.png"><img src="canned/jph.png">
</div>
<h1>Chapter 4. Procedures and Variable Bindings<a name="CHPTBINDING"></a></h1>





<p>
<a name="./binding:s0"></a><a name="./binding:s1"></a>Procedures and variable
bindings are the fundamental building blocks of Scheme programs.
This chapter describes the small set of syntactic forms whose
primary purpose is to create procedures and manipulate variable
bindings.
It begins with the two most fundamental building blocks of Scheme
programs: variable references and <tt>lambda</tt> expressions,
and continues with descriptions of
the variable binding and assignment forms such as <tt>define</tt>,
<tt>letrec</tt>, <tt>let-values</tt>, and <tt>set!</tt>.

<p>
Various other forms that bind or assign variables for which the binding or
assignment is not the primary purpose (such as named <tt>let</tt>) are found
in Chapter&nbsp;<a href="control.html#g96">5</a>.

<p>

<h3><a name="g89"></a><a name="./binding:h1"></a>Section 4.1. Variable References<a name="SECTVARREF"></a></h3>



<p>
<a name="./binding:s2"></a><span class=formdef><b>syntax</b>: <tt><i>variable</i></tt></span>
<br>
<b>returns: </b>the value of <tt><i>variable</i></tt>

<p>Any identifier appearing as an expression in a program is a variable
if a visible variable binding for the identifier exists, e.g., the
identifier appears within the scope of a binding created by <tt>define</tt>,
<tt>lambda</tt>, <tt>let</tt>, or some other variable-binding construct.

<p>

<p><tt>list&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#&lt;procedure&gt;<br>

(define&nbsp;x&nbsp;'a)<br>

(list&nbsp;x&nbsp;x)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;a)<br>

(let&nbsp;([x&nbsp;'b])<br>

&nbsp;&nbsp;(list&nbsp;x&nbsp;x))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(b&nbsp;b)<br>

(let&nbsp;([let&nbsp;'let])&nbsp;let)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;let</tt>
<p>It is a syntax violation for an identifier reference to appear within a
<tt>library</tt> form or top-level program if it is not bound as a variable,
keyword, record name, or other entity.
Since the scope of the definitions in a <tt>library</tt>, top-level
program, <tt>lambda</tt>, or other local body is the entire body, it
is not necessary for the definition of a variable to appear before
its first reference appears, as long as the reference is not actually
evaluated until the definition has been completed.
So, for example, the reference to <tt>g</tt> within the definition of
<tt>f</tt> below

<p>

<p><tt>(define&nbsp;f<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(g&nbsp;x)))<br>

(define&nbsp;g<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;x)))</tt>
<p>is okay, but the reference to <tt>g</tt> in the definition of
<tt>q</tt> below is not.

<p>

<p><tt>(define&nbsp;q&nbsp;(g&nbsp;3))<br>

(define&nbsp;g<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;x)))</tt>
<p>
<h3><a name="g90"></a><a name="./binding:h2"></a>Section 4.2. Lambda<a name="SECTLAMBDA"></a></h3>



<p>
<a name="./binding:s3"></a><span class=formdef><b>syntax</b>: <tt>(lambda&nbsp;<i>formals</i>&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a procedure
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>The <tt>lambda</tt> syntactic form is used to create <a name="./binding:s4"></a>procedures.
Any operation that creates a procedure or establishes local variable
bindings is ultimately defined in terms of <tt>lambda</tt> or
<tt>case-lambda</tt>.

<p>
The variables in <tt><i>formals</i></tt> are the <a name="./binding:s5"></a>formal parameters of the
procedure, and the sequence of subforms
<tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt> is its body.

<p>
<a name="./binding:s6"></a>The body may begin with a sequence of
definitions, in which case the bindings created by the definitions are
local to the body.
If definitions are present, the keyword bindings are used and discarded
while expanding the body, and the body is expanded into a
<tt>letrec*</tt> expression formed from the variable definitions and the
remaining expressions, as described on page&nbsp;<a href="syntax.html#body-expansion">292</a>.
The remainder of this description of <tt>lambda</tt> assumes that this
transformation has taken place, if necessary, so that the body is a
sequence of expressions without definitions.

<p>
When the procedure is created, the bindings of all variables occurring
free within the body, excluding the formal parameters, are retained with
the procedure.
Subsequently, whenever the procedure is applied to a sequence of
<a name="./binding:s7"></a>actual parameters, the formal parameters are bound to the actual
parameters, the retained bindings are restored, and the body is
evaluated.

<p>
Upon application, the <a name="./binding:s8"></a>formal parameters defined by <tt><i>formals</i></tt> are
bound to the actual parameters as follows.

<p>
<ul>
<li>If <tt><i>formals</i></tt> is a proper list of variables, e.g., <tt>(x&nbsp;y&nbsp;z)</tt>, each
variable is bound to the corresponding actual parameter.
An exception with condition type <tt>&amp;assertion</tt> is raised
if too few or too many actual parameters are supplied.

<p>
<li>If <tt><i>formals</i></tt> is a single variable (not in a list), e.g., <tt>z</tt>, it
is bound to a list of the actual parameters.

<p>
<li>If <tt><i>formals</i></tt> is an improper list of variables terminated by a
variable, e.g., <tt>(x&nbsp;y&nbsp;.&nbsp;z)</tt>, each variable but the last is bound
to the corresponding actual parameter.
The last variable is bound to a list of the remaining actual parameters.
An exception with condition type <tt>&amp;assertion</tt> is raised
if too few actual parameters are supplied.
</ul>
<p>

<p>
When the body is evaluated, the expressions in the body are evaluated in sequence,
and the procedure returns the values of the last expression.

<p>
Procedures do not have a printed representation in the usual sense.
Scheme systems print procedures in different ways; this book uses the
notation <tt>#&lt;procedure&gt;</tt>.

<p>

<p><tt>(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#&lt;procedure&gt;<br>

((lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;3))&nbsp;7)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;10<br>

((lambda&nbsp;(x&nbsp;y)&nbsp;(*&nbsp;x&nbsp;(+&nbsp;x&nbsp;y)))&nbsp;7&nbsp;13)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;140<br>

((lambda&nbsp;(f&nbsp;x)&nbsp;(f&nbsp;x&nbsp;x))&nbsp;+&nbsp;11)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;22<br>

((lambda&nbsp;()&nbsp;(+&nbsp;3&nbsp;4)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;7
<br>
<br>
((lambda&nbsp;(x&nbsp;.&nbsp;y)&nbsp;(list&nbsp;x&nbsp;y))<br>

&nbsp;28&nbsp;37)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(28&nbsp;(37))<br>

((lambda&nbsp;(x&nbsp;.&nbsp;y)&nbsp;(list&nbsp;x&nbsp;y))<br>

&nbsp;28&nbsp;37&nbsp;47&nbsp;28)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(28&nbsp;(37&nbsp;47&nbsp;28))<br>

((lambda&nbsp;(x&nbsp;y&nbsp;.&nbsp;z)&nbsp;(list&nbsp;x&nbsp;y&nbsp;z))<br>

&nbsp;1&nbsp;2&nbsp;3&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;(3&nbsp;4))<br>

((lambda&nbsp;x&nbsp;x)&nbsp;7&nbsp;13)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(7&nbsp;13)</tt>
<p>
<h3><a name="g91"></a><a name="./binding:h3"></a>Section 4.3. Case-Lambda<a name="SECTOPTARGS"></a></h3>



<p>
A Scheme <a name="./binding:s9"></a><tt>lambda</tt> expression always
produces a procedure with a fixed number of arguments or with an
indefinite number of arguments greater than or equal to a certain
number.
In particular,

<p>

<p><tt>(lambda&nbsp;(<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>accepts exactly <tt><i>n</i></tt> arguments,

<p>

<p><tt>(lambda&nbsp;<i>r</i>&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>accepts zero or more arguments, and

<p>

<p><tt>(lambda&nbsp;(<i>var<sub>1</sub></i>&nbsp;...&nbsp;<i>var<sub>n</sub></i>&nbsp;.&nbsp;<i>r</i>)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>accepts <tt><i>n</i></tt> or more arguments.

<p>
<tt>lambda</tt> cannot directly produce, however, a procedure that accepts,
say, either two or three arguments.
In particular, procedures that accept <a name="./binding:s10"></a>optional arguments are not
supported directly by <tt>lambda</tt>.
The latter form of <tt>lambda</tt> shown above can be used, in conjunction
with length checks and compositions of <tt>car</tt> and <tt>cdr</tt>, to implement
procedures with optional arguments, though at the cost of clarity and
efficiency.

<p>
The <a name="./binding:s11"></a><tt>case-lambda</tt> syntactic form directly supports
procedures with optional arguments as well as procedures with
fixed or indefinite numbers of arguments.
<tt>case-lambda</tt> is based on
the <a name="./binding:s12"></a><tt>lambda*</tt> syntactic form introduced
in the article "A New Approach to Procedures with Variable
Arity"&nbsp;[<a class=citation href="bibliography.html#g229">11</a>].

<p>
<a name="./binding:s13"></a><span class=formdef><b>syntax</b>: <tt>(case-lambda&nbsp;<i>clause</i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>a procedure
<br>
<b>libraries: </b><tt>(rnrs&nbsp;control)</tt>, <tt>(rnrs)</tt>

<p>A <tt>case-lambda</tt> expression consists of a set of clauses, each
resembling a <tt>lambda</tt> expression.
Each <tt><i>clause</i></tt> has the form below.

<p>

<p><tt>[<i>formals</i>&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...]</tt>
<p>The formal parameters of a clause are defined by <tt><i>formals</i></tt> in the
same manner as for a <tt>lambda</tt> expression.
The number of arguments accepted by the procedure value of a
<tt>case-lambda</tt> expression is
determined by the numbers of arguments accepted by the individual
clauses.

<p>
When a procedure created with <tt>case-lambda</tt> is invoked, the clauses
are considered in order.
The first clause that accepts the given number of actual parameters is
selected, the formal parameters defined by its <tt><i>formals</i></tt> are
bound to the corresponding actual parameters, and the body is
evaluated as described for <tt>lambda</tt> above.
If <tt><i>formals</i></tt> in a clause is a proper list of identifiers, then
the clause accepts exactly as many actual parameters as there are
formal parameters (identifiers) in <tt><i>formals</i></tt>.
As with a <tt>lambda</tt> <tt><i>formals</i></tt>, a <tt>case-lambda</tt> clause
<tt><i>formals</i></tt>
may be a single identifier, in which case the clause accepts any
number of arguments, or an improper list of identifiers terminated
by an identifier, in which
case the clause accepts any number of arguments greater than or
equal to the number of formal parameters excluding the terminating
identifier.
If no clause accepts the number of actual parameters supplied, an
exception with condition type <tt>&amp;assertion</tt> is raised.

<p>
The following definition for <a name="./binding:s14"></a><tt>make-list</tt> uses <tt>case-lambda</tt> to
support an optional fill parameter.

<p>

<p><tt>(define&nbsp;make-list<br>

&nbsp;&nbsp;(case-lambda<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(n)&nbsp;(make-list&nbsp;n&nbsp;#f)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(n&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(do&nbsp;([n&nbsp;n&nbsp;(-&nbsp;n&nbsp;1)]&nbsp;[ls&nbsp;'()&nbsp;(cons&nbsp;x&nbsp;ls)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((zero?&nbsp;n)&nbsp;ls))]))</tt>
<p>The <a name="./binding:s15"></a><tt>substring</tt> procedure may be extended with <tt>case-lambda</tt> to
accept either no <tt><i>end</i></tt> index, in which case it defaults to the
end of the string, or no <tt><i>start</i></tt> and <tt><i>end</i></tt> indices, in which
case <tt>substring</tt> is equivalent to <tt>string-copy</tt>:

<p>

<p><tt>(define&nbsp;substring1<br>

&nbsp;&nbsp;(case-lambda<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(s)&nbsp;(substring1&nbsp;s&nbsp;0&nbsp;(string-length&nbsp;s))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(s&nbsp;start)&nbsp;(substring1&nbsp;s&nbsp;start&nbsp;(string-length&nbsp;s))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(s&nbsp;start&nbsp;end)&nbsp;(substring&nbsp;s&nbsp;start&nbsp;end)]))</tt>
<p>It is also possible to default the <tt><i>start</i></tt> index rather than
the <tt><i>end</i></tt> index when only one index is supplied:

<p>

<p><tt>(define&nbsp;substring2<br>

&nbsp;&nbsp;(case-lambda<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(s)&nbsp;(substring2&nbsp;s&nbsp;0&nbsp;(string-length&nbsp;s))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(s&nbsp;end)&nbsp;(substring2&nbsp;s&nbsp;0&nbsp;end)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(s&nbsp;start&nbsp;end)&nbsp;(substring&nbsp;s&nbsp;start&nbsp;end)]))</tt>
<p>It is even possible to require that both or neither of the <tt><i>start</i></tt>
and <tt><i>end</i></tt> indices be supplied, simply by leaving out the middle
clause:

<p>

<p><tt>(define&nbsp;substring3<br>

&nbsp;&nbsp;(case-lambda<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(s)&nbsp;(substring3&nbsp;s&nbsp;0&nbsp;(string-length&nbsp;s))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(s&nbsp;start&nbsp;end)&nbsp;(substring&nbsp;s&nbsp;start&nbsp;end)]))</tt>
<p>
<h3><a name="g92"></a><a name="./binding:h4"></a>Section 4.4. Local Binding<a name="SECTLOCALBINDING"></a></h3>



<p>
<a name="./binding:s16"></a><span class=formdef><b>syntax</b>: <tt>(let&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the values of the final body expression
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>let</tt> establishes <a name="./binding:s17"></a>local variable bindings.
Each variable <tt><i>var</i></tt> is bound to the value of the corresponding
expression <tt><i>expr</i></tt>.
The body of the <tt>let</tt>, in which the variables are bound, is
the sequence of subforms <tt><i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...</tt> and is
processed and evaluated like a <tt>lambda</tt> body.

<p>
The forms <tt>let</tt>, <tt>let*</tt>, <tt>letrec</tt>, and <tt>letrec*</tt>
(the others are described after <tt>let</tt>) are similar but serve
slightly different purposes.
With <tt>let</tt>, in contrast with <tt>let*</tt>, <tt>letrec</tt>, and <tt>letrec*</tt>,
the expressions <tt><i>expr</i>&nbsp;...</tt> are all outside the scope of
the variables <tt><i>var</i>&nbsp;...</tt>.
Also, in contrast with <tt>let*</tt> and <tt>letrec*</tt>, no ordering is implied for the
evaluation of the expressions <tt><i>expr</i>&nbsp;...</tt>.
They may be evaluated from left to right, from right to left, or
in any other order at the discretion of the implementation.
Use <tt>let</tt> whenever the values are independent of the variables
and the order of evaluation is unimportant.

<p>

<p><tt>(let&nbsp;([x&nbsp;(*&nbsp;3.0&nbsp;3.0)]&nbsp;[y&nbsp;(*&nbsp;4.0&nbsp;4.0)])<br>

&nbsp;&nbsp;(sqrt&nbsp;(+&nbsp;x&nbsp;y)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5.0
<br>
<br>
(let&nbsp;([x&nbsp;'a]&nbsp;[y&nbsp;'(b&nbsp;c)])<br>

&nbsp;&nbsp;(cons&nbsp;x&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(a&nbsp;b&nbsp;c)
<br>
<br>
(let&nbsp;([x&nbsp;0]&nbsp;[y&nbsp;1])<br>

&nbsp;&nbsp;(let&nbsp;([x&nbsp;y]&nbsp;[y&nbsp;x])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;x&nbsp;y)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;0)</tt>
<p>The following definition of <tt>let</tt> shows the
typical derivation of <tt>let</tt> from <tt>lambda</tt>.

<p>

<p><tt>(define-syntax&nbsp;let<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x&nbsp;e)&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(x&nbsp;...)&nbsp;b1&nbsp;b2&nbsp;...)&nbsp;e&nbsp;...)]))</tt>
<p>Another form of <tt>let</tt>, <i>named</i> <tt>let</tt>, is described in
Section&nbsp;<a href="control.html#g100">5.4</a>, and a definition of the full
<tt>let</tt> can be found on page&nbsp;<a href="syntax.html#defn:let">312</a>.


<p>
<a name="./binding:s18"></a><span class=formdef><b>syntax</b>: <tt>(let*&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the values of the final body expression
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>let*</tt> is similar to <tt>let</tt> except that the
expressions <tt><i>expr</i>&nbsp;...</tt> are evaluated in sequence
from left to right, and
each of these expressions is within the scope of the variables to the
left.
Use <tt>let*</tt> when there is a linear dependency among the values or
when the order of evaluation is important.

<p>

<p><tt>(let*&nbsp;([x&nbsp;(*&nbsp;5.0&nbsp;5.0)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[y&nbsp;(-&nbsp;x&nbsp;(*&nbsp;4.0&nbsp;4.0))])<br>

&nbsp;&nbsp;(sqrt&nbsp;y))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3.0
<br>
<br>
(let&nbsp;([x&nbsp;0]&nbsp;[y&nbsp;1])<br>

&nbsp;&nbsp;(let*&nbsp;([x&nbsp;y]&nbsp;[y&nbsp;x])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;x&nbsp;y)))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;1)</tt>
<p>Any <tt>let*</tt> expression may be converted to a set of
<a name="./binding:s19"></a>nested <tt>let</tt> expressions.
The following definition of <tt>let*</tt> demonstrates
the typical transformation.

<p>

<p><tt>(define-syntax&nbsp;let*<a name="defn:let*"></a><br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;()&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;()&nbsp;e1&nbsp;e2&nbsp;...)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;((x1&nbsp;v1)&nbsp;(x2&nbsp;v2)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((x1&nbsp;v1))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let*&nbsp;((x2&nbsp;v2)&nbsp;...)&nbsp;e1&nbsp;e2&nbsp;...))]))</tt>
<p><a name="./binding:s20"></a><span class=formdef><b>syntax</b>: <tt>(letrec&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the values of the final body expression
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>letrec</tt> is similar to <tt>let</tt> and <tt>let*</tt>, except
that all of the expressions <tt><i>expr</i>&nbsp;...</tt>
are within the scope of all of the variables <tt><i>var</i>&nbsp;...</tt>.
<tt>letrec</tt> allows the definition of
<a name="./binding:s21"></a>mutually recursive procedures.

<p>

<p><tt>(letrec&nbsp;([sum&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;(sum&nbsp;(-&nbsp;x&nbsp;1)))))])<br>

&nbsp;&nbsp;(sum&nbsp;5))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;15</tt>
<p>The order of evaluation of the expressions
<tt><i>expr</i>&nbsp;...</tt> is unspecified, so a program must not
evaluate a reference
to any of the variables bound by the <tt>letrec</tt> expression before
all of the values have been computed.
(Occurrence of a variable within a <tt>lambda</tt> expression does
not count as a reference, unless the resulting procedure is applied
before all of the values have been computed.)
If this restriction is violated, an exception with condition type
<tt>&amp;assertion</tt> is raised.

<p>
An <tt><i>expr</i></tt> should not return more than once.
That is, it should not return both normally and via the invocation of a
continuation obtained during its evaluation, and it should not return
twice via two invocations of such a continuation.
Implementations are not required to detect a violation of this restriction,
but if they do, an exception with condition type <tt>&amp;assertion</tt> is
raised.

<p>
Choose <tt>letrec</tt> over <tt>let</tt> or <tt>let*</tt> when there is a
circular dependency among the variables and their values and
when the order of evaluation is unimportant.
Choose <tt>letrec*</tt> over <tt>letrec</tt> when there is a circular
dependency and the bindings need to be evaluated from left to right.

<p>
A <tt>letrec</tt> expression of the form

<p>

<p><tt>(letrec&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>may be expressed in terms of <tt>let</tt> and <tt>set!</tt> as

<p>

<p><tt>(let&nbsp;((<i>var</i>&nbsp;#f)&nbsp;...)<br>

&nbsp;&nbsp;(let&nbsp;((<i>temp</i>&nbsp;<i>expr</i>)&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;<i>var</i>&nbsp;<i>temp</i>)&nbsp;...<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;()&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)))</tt>
<p>where <tt><i>temp</i>&nbsp;...</tt> are fresh variables, i.e., ones
that do not already appear in the <tt>letrec</tt> expression,
one for each <tt>(<i>var</i>&nbsp;<i>expr</i>)</tt> pair.
The outer <tt>let</tt> expression establishes the variable bindings.
The initial value given each variable is unimportant, so any value
suffices in place of <tt>#f</tt>.
The bindings are established first so that <tt><i>expr</i>&nbsp;...</tt>
may contain
occurrences of the variables, i.e., so that the expressions are computed
within the scope of the variables.
The middle <tt>let</tt> evaluates the values and binds them to the temporary
variables, and the <tt>set!</tt> expressions assign each variable
to the corresponding value.
The inner <tt>let</tt> is present in case the body contains internal
definitions.

<p>
A definition of <tt>letrec</tt> that uses this transformation is shown
on page&nbsp;<a href="syntax.html#defn:letrec">310</a>.

<p>
This transformation does not enforce the restriction that
the <tt><i>expr</i></tt> expressions must not evaluate any references of or
assignments to the variables.
More elaborate transformations that enforce this restriction and
actually produce more efficient code are
possible&nbsp;[<a class=citation href="bibliography.html#g249">31</a>].

<p>
<a name="./binding:s22"></a><a name="desc:letrec*"></a>
<span class=formdef><b>syntax</b>: <tt>(letrec*&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the values of the final body expression
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>letrec*</tt> is similar to <tt>letrec</tt>, except that
<tt>letrec*</tt> evaluates <tt><i>expr</i>&nbsp;...</tt> in sequence from left to right.
While programs must still not evaluate a reference to any <tt><i>var</i></tt>
before the corresponding <tt><i>expr</i></tt> has been evaluated, references to
<tt><i>var</i></tt> may be evaluated any time thereafter, including during
the evaluation of the <tt><i>expr</i></tt> of any subsequent binding.

<p>
A <tt>letrec*</tt> expression of the form

<p>

<p><tt>(letrec*&nbsp;((<i>var</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt>
<p>may be expressed in terms of <tt>let</tt> and <tt>set!</tt> as

<p>

<p><tt>(let&nbsp;((<i>var</i>&nbsp;#f)&nbsp;...)<br>

&nbsp;&nbsp;(set!&nbsp;<i>var</i>&nbsp;<i>expr</i>)&nbsp;...<br>

&nbsp;&nbsp;(let&nbsp;()&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...))</tt>
<p>The outer <tt>let</tt> expression creates the bindings, each assignment
evaluates an expression and immediately sets the corresponding variable
to its value, in sequence, and the inner let evaluates the body.
<tt>let</tt> is used in the latter case rather than <tt>begin</tt>
since the body may include internal definitions as well as expressions.

<p>

<p><tt>(letrec*&nbsp;([sum&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;(sum&nbsp;(-&nbsp;x&nbsp;1)))))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[f&nbsp;(lambda&nbsp;()&nbsp;(cons&nbsp;n&nbsp;n-sum))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[n&nbsp;15]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[n-sum&nbsp;(sum&nbsp;n)])<br>

&nbsp;&nbsp;(f))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(15&nbsp;.&nbsp;120)
<br>
<br>
(letrec*&nbsp;([f&nbsp;(lambda&nbsp;()&nbsp;(lambda&nbsp;()&nbsp;g))]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[g&nbsp;(f)])<br>

&nbsp;&nbsp;(eq?&nbsp;(g)&nbsp;g))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t
<br>
<br>
(letrec*&nbsp;([g&nbsp;(f)]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[f&nbsp;(lambda&nbsp;()&nbsp;(lambda&nbsp;()&nbsp;g))])<br>

&nbsp;&nbsp;(eq?&nbsp;(g)&nbsp;g))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;<i>exception:&nbsp;attempt&nbsp;to&nbsp;reference&nbsp;undefined&nbsp;variable&nbsp;f</i></tt>
<p>
<h3><a name="g93"></a><a name="./binding:h5"></a>Section 4.5. Multiple Values<a name="SECTLETVALUES"></a></h3>



<p>
<a name="./binding:s23"></a><a name="desc:let-values"></a>
<span class=formdef><b>syntax</b>: <tt>(let-values&nbsp;((<i>formals</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(let*-values&nbsp;((<i>formals</i>&nbsp;<i>expr</i>)&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>returns: </b>the values of the final body expression
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><tt>let-values</tt> is a convenient way to receive multiple
values and bind them to variables.
It is structured like <tt>let</tt> but permits an arbitrary
formals list (like <tt>lambda</tt>) on each left-hand
side.
<tt>let*-values</tt> is similar but performs the bindings in
left-to-right order, as with <tt>let*</tt>.
An exception with condition type <tt>&amp;assertion</tt> is raised
if the number of values returned by an <tt><i>expr</i></tt> is not appropriate
for the corresponding <tt><i>formals</i></tt>, as described in the entry
for <tt>lambda</tt> above.
A definition of <tt>let-values</tt> is given on page&nbsp;<a href="syntax.html#fullletvalues">310</a>.

<p>

<p><tt>(let-values&nbsp;([(a&nbsp;b)&nbsp;(values&nbsp;1&nbsp;2)]&nbsp;[c&nbsp;(values&nbsp;1&nbsp;2&nbsp;3)])<br>

&nbsp;&nbsp;(list&nbsp;a&nbsp;b&nbsp;c))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(1&nbsp;2&nbsp;(1&nbsp;2&nbsp;3))
<br>
<br>
(let*-values&nbsp;([(a&nbsp;b)&nbsp;(values&nbsp;1&nbsp;2)]&nbsp;[(a&nbsp;b)&nbsp;(values&nbsp;b&nbsp;a)])<br>

&nbsp;&nbsp;(list&nbsp;a&nbsp;b))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;(2&nbsp;1)</tt>
<p>
<h3><a name="g94"></a><a name="./binding:h6"></a>Section 4.6. Variable Definitions<a name="SECTDEFINITIONS"></a></h3>



<p>
<a name="./binding:s24"></a><span class=formdef><b>syntax</b>: <tt>(define&nbsp;<i>var</i>&nbsp;<i>expr</i>)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(define&nbsp;<i>var</i>)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(define&nbsp;(<i>var<sub>0</sub></i>&nbsp;<i>var<sub>1</sub></i>&nbsp;...)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(define&nbsp;(<i>var<sub>0</sub></i>&nbsp;.&nbsp;<i>var<sub>r</sub></i>)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<span class=formdef><b>syntax</b>: <tt>(define&nbsp;(<i>var<sub>0</sub></i>&nbsp;<i>var<sub>1</sub></i>&nbsp;<i>var<sub>2</sub></i>&nbsp;...&nbsp;.&nbsp;<i>var<sub>r</sub></i>)&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...)</tt></span>
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p>In the first form, <tt>define</tt> creates a new binding of <tt><i>var</i></tt> to
the value of <tt><i>expr</i></tt>.
The <tt><i>expr</i></tt> should not return more than once.
That is, it should not return both normally and via the invocation of a
continuation obtained during its evaluation, and it should not return
twice via two invocations of such a continuation.
Implementations are not required to detect a violation of this restriction,
but if they do, an exception with condition type <tt>&amp;assertion</tt> is
raised.

<p>
The second form is equivalent to <tt>(define&nbsp;<i>var</i>&nbsp;<i>unspecified</i>)</tt>,
where <tt><i>unspecified</i></tt> is some unspecified value.
<a name="./binding:s25"></a>The remaining are shorthand forms for
binding variables to
procedures; they are identical to the following definition in terms of
<tt>lambda</tt>.

<p>

<p><tt>(define&nbsp;<i>var</i><br>

&nbsp;&nbsp;(lambda&nbsp;<i>formals</i><br>

&nbsp;&nbsp;&nbsp;&nbsp;<i>body<sub>1</sub></i>&nbsp;<i>body<sub>2</sub></i>&nbsp;...))</tt>
<p>where <tt><i>formals</i></tt> is <tt>(<i>var<sub>1</sub></i>&nbsp;...)</tt>, <tt><i>var<sub>r</sub></i></tt>,
or <tt>(<i>var<sub>1</sub></i>&nbsp;<i>var<sub>2</sub></i>&nbsp;...&nbsp;.&nbsp;<i>var<sub>r</sub></i>)</tt> for the third,
fourth, and fifth <tt>define</tt> formats.

<p>
Definitions may appear at the front of a <tt>library</tt> body, anywhere
among the forms of a top-level-program body, and at the front of a
<tt>lambda</tt> or <tt>case-lambda</tt> body or the body of any form
derived from <tt>lambda</tt>, e.g., <tt>let</tt>, or <tt>letrec*</tt>.
Any body that begins with a sequence of definitions is transformed
during macro expansion into a <tt>letrec*</tt> expression as described
on page&nbsp;<a href="syntax.html#body-expansion">292</a>.

<p>
Syntax definitions may appear along with variable definitions wherever
variable definitions may appear; see Chapter&nbsp;<a href="syntax.html#g133">8</a>.

<p>

<p><tt>(define&nbsp;x&nbsp;3)<br>

x&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;3
<br>
<br>
(define&nbsp;f<br>

&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;(+&nbsp;x&nbsp;y)&nbsp;2)))<br>

(f&nbsp;5&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;18
<br>
<br>
(define&nbsp;(sum-of-squares&nbsp;x&nbsp;y)<br>

&nbsp;&nbsp;(+&nbsp;(*&nbsp;x&nbsp;x)&nbsp;(*&nbsp;y&nbsp;y)))<br>

(sum-of-squares&nbsp;3&nbsp;4)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;25
<br>
<br>
(define&nbsp;f<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;1)))<br>

(let&nbsp;([x&nbsp;2])<br>

&nbsp;&nbsp;(define&nbsp;f<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;y&nbsp;x)))<br>

&nbsp;&nbsp;(f&nbsp;3))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;5<br>

(f&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;4</tt>
<p>A set of definitions may be grouped by enclosing them in a
<a name="./binding:s26"></a><tt>begin</tt> form.
Definitions grouped in this manner may appear wherever ordinary
variable and syntax definitions may appear.
They are treated as if written separately, i.e., without the
enclosing <tt>begin</tt> form.
<a name="multi-define-syntax"></a>This feature allows syntactic extensions to
expand into groups of definitions.

<p>

<p><tt>(define-syntax&nbsp;multi-define-syntax<br>

&nbsp;&nbsp;(syntax-rules&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;[(_&nbsp;(var&nbsp;expr)&nbsp;...)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;var&nbsp;expr)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...)]))<br>

(let&nbsp;()<br>

&nbsp;&nbsp;(define&nbsp;plus<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(plus&nbsp;(sub1&nbsp;x)&nbsp;(add1&nbsp;y)))))<br>

&nbsp;&nbsp;(multi-define-syntax<br>

&nbsp;&nbsp;&nbsp;&nbsp;(add1&nbsp;(syntax-rules&nbsp;()&nbsp;[(_&nbsp;e)&nbsp;(+&nbsp;e&nbsp;1)]))<br>

&nbsp;&nbsp;&nbsp;&nbsp;(sub1&nbsp;(syntax-rules&nbsp;()&nbsp;[(_&nbsp;e)&nbsp;(-&nbsp;e&nbsp;1)])))<br>

&nbsp;&nbsp;(plus&nbsp;7&nbsp;8))&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;15</tt>
<p><a name="./binding:s27"></a>Many implementations support an interactive "top level" in which variable
and other definitions may be entered interactively or loaded from files.
The behavior of these top-level definitions is outside the scope of the
Revised<sup>6</sup> Report, but as long as top-level variables are defined before
any references or assignments to them are evaluated, the behavior is
consistent across most implementations.
So, for example, the reference to <tt>g</tt> in the top-level definition
of <tt>f</tt> below is okay if <tt><i>g</i></tt> is not already defined, and <tt>g</tt>
is assumed to name a variable to be defined at some later point.

<p>

<p><tt>(define&nbsp;f<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(g&nbsp;x)))</tt>
<p>If this is then followed by a definition of <tt>g</tt> before <tt>f</tt> is
evaluated, the assumption that <tt>g</tt> would be defined as a variable is
proven correct, and a call to <tt>f</tt> works as expected.

<p>

<p><tt>(define&nbsp;g<br>

&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;x)))<br>

(f&nbsp;3)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;6</tt>
<p>If <tt>g</tt> were defined instead as the keyword for a syntactic extension,
the assumption that <tt>g</tt> would be bound as a variable is
proven false, and if <tt>f</tt> is not redefined before it is invoked,
the implementation is likely to raise an exception.


<p>

<h3><a name="g95"></a><a name="./binding:h7"></a>Section 4.7. Assignment<a name="SECTASSIGNMENTS"></a></h3>



<p>
<a name="./binding:s28"></a><span class=formdef><b>syntax</b>: <tt>(set!&nbsp;<i>var</i>&nbsp;<i>expr</i>)</tt></span>
<br>
<b>returns: </b>unspecified
<br>
<b>libraries: </b><tt>(rnrs&nbsp;base)</tt>, <tt>(rnrs)</tt>

<p><a name="./binding:s29"></a><tt>set!</tt> does not establish a new binding for
<tt><i>var</i></tt> but rather alters the value of an existing binding.
<a name="./binding:s30"></a>It first evaluates <tt><i>expr</i></tt>, then assigns
<tt><i>var</i></tt> to the value of <tt><i>expr</i></tt>.
Any subsequent reference to <tt><i>var</i></tt> within the scope of the altered
binding evaluates to the new value.

<p>
Assignments are not employed as frequently in Scheme as in most other
languages, but they are useful for implementing state changes.<a name="./binding:s31"></a>

<p>

<p><tt>(define&nbsp;flip-flop<br>

&nbsp;&nbsp;(let&nbsp;([state&nbsp;#f])<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;state&nbsp;(not&nbsp;state))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state)))
<br>
<br>
(flip-flop)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t<br>

(flip-flop)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#f<br>

(flip-flop)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;#t</tt>
<p>Assignments are also useful for caching values.
The example below uses a technique called <i>memoization</i>,
in which a procedure records the values associated with old
input values so it need not recompute them, to implement a fast
version of the otherwise exponential doubly recursive definition
of the <a name="./binding:s32"></a>Fibonacci function (see
page&nbsp;<a href="further.html#fibonacci">69</a>).<a name="./binding:s33"></a>

<p>

<p><tt>(define&nbsp;memoize<br>

&nbsp;&nbsp;(lambda&nbsp;(proc)<br>

&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([cache&nbsp;'()])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(assq&nbsp;x&nbsp;cache)&nbsp;=&gt;&nbsp;cdr]<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[else<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;([ans&nbsp;(proc&nbsp;x)])<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;cache&nbsp;(cons&nbsp;(cons&nbsp;x&nbsp;ans)&nbsp;cache))<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans)])))))
<br>
<br>
(define&nbsp;fibonacci<br>

&nbsp;&nbsp;(memoize<br>

&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;n&nbsp;2)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(fibonacci&nbsp;(-&nbsp;n&nbsp;1))&nbsp;(fibonacci&nbsp;(-&nbsp;n&nbsp;2)))))))
<br>
<br>
(fibonacci&nbsp;100)&nbsp;<img src="math/tspl/0.gif" alt="<graphic>">&nbsp;573147844013817084101</tt>
<p>



<hr class=copyright align=left>
<p>
R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it><br>
Copyright &copy; 2009 <a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">The MIT Press</a>.  Electronically reproduced by permission.<br>
Illustrations &copy; 2009 <a class=plain href="http://hebert.kitp.ucsb.edu/">Jean-Pierre H&eacute;bert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a class=plain href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984">to order this book</a> / <a class=plain href="canned/about.html">about this book</a>
</p>
<p><a class=plain href="http://www.scheme.com">http://www.scheme.com</a></p>
</body>
</html>
